#!/usr/bin/env perl

# generate topic entity classifiers for Kimberly for ABC  https://agr-jira.atlassian.net/browse/SCRUM-2664  2023 06 09
#
# modified for cur_curdata for general topics without entities.  2023 08 15
#
# modified for cur_svmdata, cur_nncdata, cur_strdata, cfp_<*>   2023 08 17
#
# cur_strdata antibody only has data for the new pipeline, old data was overwritten or lost, only have 1 source now.
# dump afp_<datatype> data for afp_curator to curator/afp source, afp_author afp to author/afp source, 
# afp_author ack based on timestamp to author/ACKnowledge source.  2023 08 18
#
# account for okta tokens expire after 24 hours.  if % 1000 entries and >23 hours, reset okta token.  2023 08 21
#
# Updated to use new sources generated by Kimberly and Valerio.  2024 03 04
#
# Only send note field if there's text to send.
# Derive merged papers from pap_identifier.  2024 07 26
#
# negated data from afp_lasttouched only for afp time period.  2024 08 05
# 
# not using %entitytypes , not tested, so not commited to github  2024 10 10
#
# now outputs to error logs, there's a .err.processing for processing error, and .err.<4002|stage|prod> for errors 
# coming back from ABC.  2024 10 11
#
# Adding data_novelty because the API will fail otherwise, but it's not the correct term.  2025 09 17
#
# Added processing for extvariation.  Also afp_newstrains which does not have cfp or tfp.
# Loading datatype to atp mappings from flatfile that Kimberly can manage, but manually updated the database delete command.
# Fixed a bug that was looping getting the ABC source for each paper for a couple of sources.
#
# Added more datatypes to datatypesAfpCfp  removed a couple from the delete list.  some datatypes hasAfpButNoTfp or
# hasAfpButNoCfp some datatypes have an afp table afpWithOnlyThreeColumns and need to be queried differently.  2025 10 31
#
# strData can have negated true if the data is an empty string.  2025 10 03
#
# Some ATP should not be deleted because they're loaded from their entity scripts.  Some queries were returning
# timestamps with timezone and failing in the API.  2025 11 07
#
# Additional logging of api results.
# curl is unsafe if json payload has singlequotes, updated to use LWP::UserAgent and HTTP::Request 2025 11 09
#
# strData was looking at wrong hash value and making it always negated true, now correct.
# outputAfpAutData  antibody has special data novelty, everything else the same.
# now if author says something, that's data and note, else it's negated, regardless of what tfp says.
# if afp has json that means no data, treat it like an empty string.
# if strData is negated, confidence_level is NEG.  2025 11 10
#
# ranjana wants to treat old afp and cfp humdis as parent level disease  2025 11 12
#
# when populating afp and ack also make sure ack becomes humandisease which is disease model.  also cfp from afp is always disease.
# add disease atp 11 to the delete query.  2025 11 13
#
# kimberly and daniela want ack json from afp_ to extract name and publicationId to join with ; and objects with | .  2025 11 17
#
# Use cognito token instead of okta.  2025 12 09
#
# Expanded api failure handling and retry to API.
# More checks on reference_curie before sending to API.  2025 12 12
#
# Error handling to recreate token is not on success detail, it's on lack of success detail.
# If reference is not valid, don't retry, move on.  Log more different types of API responses in different counter.
# Typo in invalid reference handling.  2025 12 13
#
# Ranjana no longer wants human disease old afp nor cfp.
# Converting ACK data to note and deriving negated from json is only for otherantibody, everything else uses the string.
# Send WB:WBPaper IDs instead of AGRKB.  2025 12 15
#
# antibody from old afp should only have data novelty 335 not 229   2025 12 16
#
# afp_newstrains was creating negated for genetics, but we should skip it because it was never part of old afp.
# skip datatypes that didn't exist in old afp if source is old afp, currently only othergenefunc.  2026 01 07
#
# add more datatype envpheno chemphen to list to skip if old afp.  2026 01 28


# If reloading, drop all TET from WB sources manually (don't have an API for delete with sql), make sure it's the correct database.

#    DELETE FROM topic_entity_tag WHERE topic IN ('ATP:0000011', 'ATP:0000033', 'ATP:0000041', 'ATP:0000048', 'ATP:0000054', 'ATP:0000055', 'ATP:0000056', 'ATP:0000060', 'ATP:0000061', 'ATP:0000062', 'ATP:0000068', 'ATP:0000069', 'ATP:0000070', 'ATP:0000071', 'ATP:0000082', 'ATP:0000083', 'ATP:0000084', 'ATP:0000089', 'ATP:0000096', 'ATP:0000152', 'ATP:0000278', 'ATP:0000349', 'ATP:0000350', 'ATP:0000351', 'ATP:0000352') AND topic_entity_tag_source_id IN ( SELECT topic_entity_tag_source_id FROM topic_entity_tag_source WHERE secondary_data_provider_id = ( SELECT mod_id FROM mod WHERE abbreviation = 'WB' )) AND topic_entity_tag_source_id NOT IN (SELECT topic_entity_tag_source_id FROM topic_entity_tag_source WHERE source_method = 'abc_document_classifier') AND created_by != 'default_user';

#    SELECT COUNT(*) FROM topic_entity_tag WHERE topic IN ('ATP:0000011', 'ATP:0000033', 'ATP:0000041', 'ATP:0000048', 'ATP:0000054', 'ATP:0000055', 'ATP:0000056', 'ATP:0000060', 'ATP:0000061', 'ATP:0000062', 'ATP:0000068', 'ATP:0000069', 'ATP:0000070', 'ATP:0000071', 'ATP:0000082', 'ATP:0000083', 'ATP:0000084', 'ATP:0000089', 'ATP:0000096', 'ATP:0000152', 'ATP:0000278', 'ATP:0000349', 'ATP:0000350', 'ATP:0000351', 'ATP:0000352')
#      AND topic_entity_tag_source_id IN (
#      SELECT topic_entity_tag_source_id FROM topic_entity_tag_source WHERE secondary_data_provider_id = (
#      SELECT mod_id FROM mod WHERE abbreviation = 'WB' ))
#      AND topic_entity_tag_source_id NOT IN (SELECT topic_entity_tag_source_id FROM topic_entity_tag_source WHERE source_method = 'abc_document_classifier')
#      AND created_by != 'default_user';

# Do not delete ATP:0000005 gene.  ATP:0000123 species.  ATP:0000110 transgene.  ATP:0000285 variation.  ATP:0000027 strain



# Always run like 
# ./dump_classifier_topic_entity.pl
# but first change $output_format and $baseUrl



# to clean up, must delete validation first, then tags.
# DELETE FROM topic_entity_tag_validation WHERE validated_topic_entity_tag_id > 516 OR validating_topic_entity_tag_id > 516
# DELETE FROM topic_entity_tag WHERE topic_entity_tag_id > 516


use strict;
use diagnostics;
use DBI;
use JSON;
use LWP::UserAgent;
use HTTP::Request;
use Jex;
use Encode qw( from_to is_utf8 );
use Dotenv -load => '/usr/lib/.env';

use constant FALSE => \0;
use constant TRUE => \1;

my $start_time = time;

my $dbh = DBI->connect ( "dbi:Pg:dbname=$ENV{PSQL_DATABASE};host=$ENV{PSQL_HOST};port=$ENV{PSQL_PORT}", "$ENV{PSQL_USERNAME}", "$ENV{PSQL_PASSWORD}") or die "Cannot connect to database!\n";
# my $dbh = DBI->connect ( "dbi:Pg:dbname=testdb", "", "") or die "Cannot connect to database!\n"; 
my $result;

my $baseUrl = 'https://stage-literature-rest.alliancegenome.org/';
# my $baseUrl = 'https://dev4005-literature-rest.alliancegenome.org/';
# my $baseUrl = 'https://dev4002-literature-rest.alliancegenome.org/';
my $output_format = 'json';
# my $output_format = 'api';
my $tag_counter = 0;
my $success_counter = 0;
my $exists_counter = 0;
my $invalid_request_counter = 0;
my $invalid_reference_counter = 0;
my $unexpected_success_counter = 0;
my $unexpected_failure_counter = 0;
my $failure_counter = 0;
my $retry_counter = 0;

my @output_json;

my $mod = 'WB';

# my @wbpapers = qw( 00004952 00005199 00026609 00030933 00035427 );
# my @wbpapers = qw( 00004952 00005199 00046571 00057043 00064676 );	# SCRUM-3775
# my @wbpapers = qw( 00046571 );
# my @wbpapers = qw( 00005199 );
# my @wbpapers = qw( 00057043 );
# my @wbpapers = qw( 00004952 00005199 00026609 00030933 00035427 00046571 00057043 00064676 00037049 );
# my @wbpapers = qw( 00004952 00031697 00032245 00032467 00032959 00033036 00033406 00034728 00035977 00040400 00053203 00059003 00059712 00060296 00065201 00067387 00067433 00068170 );	# SCRUM-5255
# my @wbpapers = qw( 00001084 00004952 00031697 00032245 00032467 00032959 00033036 00033406 00034728 00035977 00040400 00053203 00059003 00059712 00060296 00065201 00067387 00067433 00068170 00068343 );	# 2025 10 09
# my @wbpapers = qw( 00067433 );	# 2025 10 31
# my @wbpapers = qw( 00068172 );	# 2025 11 03	# strData negated antibody
# my @wbpapers = qw( 00068715 );	# 2025 12 13	# not on stage
# my @wbpapers = qw( 00037758 );	# 2025 12 15	# API creating psycopg2.errors.UniqueViolation
# my @wbpapers = qw( 00036433 );	# 2025 12 15	# hum dis changes test paper
# my @wbpapers = qw( 00059003 );	# 2025 12 15	# hum dis negative ack test paper
# my @wbpapers = qw( 00034728 );	# 2025 12 16	# antibody from old afp should only have data novelty 335 not 229
# my @wbpapers = qw( 00031697 );	# 2026 01 07	# afp_newstrains was creating negated for genetics, but we should skip it instead 
my @wbpapers = qw( 00001084 00004952 00031697 00032245 00032467 00032959 00033036 00033206 00033406 00034728 00035977 00040400 00053203 00054648 00059003 00059712 00060296 00065201 00067387 00067433 00068170 00068172 00068343 );	# 2025 11 07

# 00004952 00005199 00026609 00030933 00035427 00046571 00057043 00064676 
# 00004952 00005199 00026609 00030933 00035427 00046571 00057043 00064676 00037049

my %datatypesAfpCfp;
my %datatypes;
# my %wbpToAgr;
my %papValid;
my %papMerge;

my %chosenPapers;

foreach my $joinkey (@wbpapers) { $chosenPapers{$joinkey}++; }
# $chosenPapers{all}++;

&populateDatatypesAndABC();


my %speciesToTaxon;
$result = $dbh->prepare( "SELECT * FROM obo_name_ncbitaxonid WHERE joinkey IN (SELECT DISTINCT(pap_species) FROM pap_species) " );
$result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
while (my @row = $result->fetchrow) { $speciesToTaxon{$row[1]} = $row[0]; }

my %premadeComments;
&populatePremadeComments();



my %strData;
my %svmData;
my %nncData;
my %curData;
my %cfpData;
my %tfpData;
my %afpContributor;
my %afpLasttouched;
my %afpAutData;
my %afpCurData;
my %oaData;
my %objsCurated;

my $abc_location = 'stage';
if ($baseUrl =~ m/dev4002/) { $abc_location = '4002'; }
elsif ($baseUrl =~ m/prod/) { $abc_location = 'prod'; }

my $date = &getSimpleSecDate();
my $outfile = 'populate_classifier_topic_entity.' . $date . '.' . $output_format . '.' . $abc_location;
open (OUT, ">$outfile") or die "Cannot create $outfile : $!";

my $perrfile = 'populate_classifier_topic_entity.' . $date . '.err.processing';
open (PERR, ">$perrfile") or die "Cannot create $perrfile : $!";

my $errfile = 'populate_classifier_topic_entity.' . $date . '.err.' . $abc_location;
if ($output_format eq 'api') {
  open (ERR, ">$errfile") or die "Cannot create $outfile : $!";
}

# my $okta_token = &generateOktaToken();
my $cognito_token = &generateCognitoToken();


# PUT THIS BACK
 &populateCurCurData();
 &outputCurCurData();
 &populateCurSvmData();
 &outputCurSvmData();
 &populateCurNncData();
 &outputCurNncData();
 &populateCurStrData();
 &outputCurStrData();
 &populateCfpData();
 &outputCfpData();
 &populateAfpData();
 &outputAfpAutData();
 &outputAfpCurData();
 &populateOaData();
 &outputOaData();


if ($output_format eq 'json') {
  my $json = to_json( \@output_json, { pretty => 1 } );
  print OUT qq($json);                            # for single json file output
}

if ($output_format eq 'api') {
  print OUT qq(Tags\t$tag_counter\tSuccess\t$success_counter\tExists\t$exists_counter\tInvalid Request\t$invalid_request_counter\tInvalid Reference\t$invalid_reference_counter\tUnexpected Success\t$unexpected_success_counter\tUnexpected Failure\t$unexpected_failure_counter\tFailure\t$failure_counter\n);
  print ERR qq(Tags\t$tag_counter\tSuccess\t$success_counter\tExists\t$exists_counter\tInvalid Request\t$invalid_request_counter\tInvalid Reference\t$invalid_reference_counter\tUnexpected Success\t$unexpected_success_counter\tUnexpected Failure\t$unexpected_failure_counter\tFailure\t$failure_counter\n);
  close (ERR) or die "Cannot close $errfile : $!";
}
close (OUT) or die "Cannot close $outfile : $!";
close (PERR) or die "Cannot close $perrfile : $!";


# TODO - need to figure out how to get curator and timestamp
sub outputOaData {
  my $data_provider = $mod;
  my $secondary_data_provider = $mod;
  my $source_evidence_assertion = 'ATP:0000036';
  my $source_method = 'ontology_annotator';
  my $source_id = &getSourceId($source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider);
  my $timestamp = &getPgDate();
  unless ($source_id) {
    print PERR qq(ERROR no source_id for $source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider\n);
    return;
  }
#   { "source_type": "professional_biocurator", "source_method": "wormbase_oa", "evidence": "eco_string", "description": "caltech curation tools", "mod_abbreviation": "WB" }
  foreach my $datatype (sort keys %oaData) {
    unless ($datatypes{$datatype}) {
      print PERR qq(no topic for oaData $datatype\n); 
      next;
    }
    foreach my $joinkey (sort keys %{ $oaData{$datatype} }) {
      next unless ($chosenPapers{$joinkey} || $chosenPapers{all});
      my ($joinkey) = &deriveValidPap($joinkey);
      next unless $papValid{$joinkey};
#       unless ($wbpToAgr{$joinkey}) { print PERR qq(ERROR paper $joinkey NOT AGRKB\n); next; }
      my %object;
      $object{'negated'}                    = FALSE;
      $object{'force_insertion'}            = TRUE;
      $object{'reference_curie'}            = "WB:WBPaper$joinkey";
#       $object{'reference_curie'}            = $wbpToAgr{$joinkey};
      $object{'topic'}                      = $datatypes{$datatype};
      $object{'topic_entity_tag_source_id'} = $source_id;
      $object{'data_novelty'}               = 'ATP:0000335';
      $object{'created_by'}                 = 'caltech_pipeline';
      $object{'updated_by'}                 = 'caltech_pipeline';
      $object{'date_created'}               = $timestamp;
      $object{'date_updated'}               = $timestamp;
      if ($output_format eq 'json') {
        push @output_json, \%object; }
      else {
        my $object_json = encode_json \%object;
        &createTag($object_json); }
} } }

sub outputAfpCurData {
  my $data_provider = $mod;
  my $secondary_data_provider = $mod;
  my $source_evidence_assertion = 'ATP:0000036';
  my $source_method = 'author_first_pass';
  my $source_id = &getSourceId($source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider);
  unless ($source_id) {
    print PERR qq(ERROR no source_id for $source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider\n);
    return;
  }
#   { "source_type": "professional_biocurator", "source_method": "wormbase_curation_status", "evidence": "eco_string", "description": "cur_curdata", "mod_abbreviation": "WB" }
  foreach my $datatype (sort keys %afpCurData) {
    unless ($datatypes{$datatype}) { 
      print PERR qq(no topic for afpCurData $datatype\n); 
      next;
    }
    foreach my $joinkey (sort keys %{ $afpCurData{$datatype} }) {
      next unless ($chosenPapers{$joinkey} || $chosenPapers{all});
      my ($joinkey) = &deriveValidPap($joinkey);
      next unless $papValid{$joinkey};
#       unless ($wbpToAgr{$joinkey}) { print PERR qq(ERROR paper $joinkey NOT AGRKB\n); next; }
      my $negated = FALSE;
      if ($afpCurData{$datatype}{$joinkey}{negated}) { $negated = TRUE; }
      my %object;
      $object{'negated'}                    = $negated;
      $object{'force_insertion'}            = TRUE;
      $object{'reference_curie'}            = "WB:WBPaper$joinkey";
#       $object{'reference_curie'}            = $wbpToAgr{$joinkey};
      $object{'topic'}                      = $datatypes{$datatype};
      $object{'topic_entity_tag_source_id'} = $source_id;
      $object{'data_novelty'}               = 'ATP:0000335';
      $object{'created_by'}                 = $afpCurData{$datatype}{$joinkey}{curator};
      $object{'updated_by'}                 = $afpCurData{$datatype}{$joinkey}{curator};
      $object{'date_created'}               = $afpCurData{$datatype}{$joinkey}{timestamp};
      $object{'date_updated'}               = $afpCurData{$datatype}{$joinkey}{timestamp};
      if ($output_format eq 'json') {
        push @output_json, \%object; }
      else {
        my $object_json = encode_json \%object;
        &createTag($object_json); }
} } }

sub outputAfpAutData {
  my $data_provider = $mod;
  my $secondary_data_provider = $mod;
  my $source_evidence_assertion = 'ATP:0000035';
  my $source_method = 'author_first_pass';
  my $source_id_afp = &getSourceId($source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider);
  unless ($source_id_afp) {
    print PERR qq(ERROR no source_id for $source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider\n);
    return;
  }

  $source_evidence_assertion = 'ATP:0000035';
  $source_method = 'ACKnowledge_form';
  my $source_id_ack = &getSourceId($source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider);
  unless ($source_id_ack) {
    print PERR qq(ERROR no source_id for $source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider\n);
    return;
  }

  $source_evidence_assertion = 'ATP:0000036';
  $source_method = 'genetics_g3_linking_curator';
  my $source_id_genetics = &getSourceId($source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider);
  unless ($source_id_genetics) {
    print PERR qq(ERROR no source_id for $source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider\n);
    return;
  }

  my %noOldAfp;
  $noOldAfp{'chemphen'}++;
  $noOldAfp{'envpheno'}++;
  $noOldAfp{'othergenefunc'}++;
#   { "source_type": "professional_biocurator", "source_method": "wormbase_curation_status", "evidence": "eco_string", "description": "cur_curdata", "mod_abbreviation": "WB" }
  foreach my $datatype (sort keys %afpAutData) {
    unless ($datatypes{$datatype}) { 
      print PERR qq(no topic for afpAutData $datatype\n); 
      next;
    }
    foreach my $joinkey (sort keys %{ $afpAutData{$datatype} }) {
      next unless ($chosenPapers{$joinkey} || $chosenPapers{all});
      my ($joinkey) = &deriveValidPap($joinkey);
      next unless $papValid{$joinkey};
#       unless ($wbpToAgr{$joinkey}) { print PERR qq(ERROR paper $joinkey NOT AGRKB\n); next; }
      my @auts;
      if ($afpContributor{$joinkey}) { foreach my $who (sort keys %{ $afpContributor{$joinkey} }) { push @auts, $who; } }
      if (scalar @auts < 1) { push @auts, 'unknown_author'; }
      foreach my $aut (@auts) {
        my %object;
        my $negated = FALSE;
        if ($afpAutData{$datatype}{$joinkey}{negated}) { $negated = TRUE; }
        my $source_id = $source_id_afp;
        if ($afpAutData{$datatype}{$joinkey}{source} eq 'ack') { $source_id = $source_id_ack; }
        if ( ($datatype eq 'extvariation') || ($datatype eq 'newstrains') ) { $source_id = $source_id_genetics; }
        if ( ($source_id eq $source_id_afp) && ($noOldAfp{$datatype}) ) { next; }	# skip datatypes that didn't exist in old afp if source is old afp  2026 01 07

        if ($afpAutData{$datatype}{$joinkey}{note}) {
          $object{'note'}                     = $afpAutData{$datatype}{$joinkey}{note}; }
        $object{'negated'}                    = $negated;
        $object{'force_insertion'}            = TRUE;
        $object{'reference_curie'}            = "WB:WBPaper$joinkey";
#         $object{'reference_curie'}            = $wbpToAgr{$joinkey};
        $object{'topic'}                      = $datatypes{$datatype};
        $object{'topic_entity_tag_source_id'} = $source_id;
        $object{'data_novelty'}               = 'ATP:0000335';
        if ( ($afpAutData{$datatype}{$joinkey}{source} eq 'ack') && ($datatype eq 'antibody') ) {
          $object{'data_novelty'}               = 'ATP:0000229'; }	# otherantibody still 335, 229 only for ack antibody
        $object{'created_by'}                 = $aut;
        $object{'updated_by'}                 = $aut;
        $object{'date_created'}               = $afpAutData{$datatype}{$joinkey}{timestamp};
        $object{'date_updated'}               = $afpAutData{$datatype}{$joinkey}{timestamp};
        # $object{'datatype'}                 = $datatype;		# for debugging
        if ($output_format eq 'json') {
          push @output_json, \%object; }
        else {
          my $object_json = encode_json \%object;
          &createTag($object_json); }
} } } }

sub convertAckToNote {
  my ($origdata, $datatype) = @_;
  if ($datatype ne 'otherantibody') {	# most data is just the data, but otherantibody needs to process json
    my $negated = 1;
    if ($origdata) { $negated = 0; }
    return ($origdata, $negated); }
  else {
    my $json = eval { decode_json($origdata) };
    return ('', 1) if $@ or ref($json) ne 'ARRAY';
    my @parts;
    for my $entry (@$json) {
      next unless ref($entry) eq 'HASH';
      my @fields;
      push @fields, $entry->{name}          if defined $entry->{name}          && $entry->{name} ne '';
      push @fields, $entry->{publicationId} if defined $entry->{publicationId} && $entry->{publicationId} ne '';
      next unless @fields;  # skip if no non-empty fields
      push @parts, join('; ', @fields);
    }
    my $data = join(' | ', @parts);
    my $negated = $data eq '' ? 1 : 0;
    return ($data, $negated); }
} # sub convertAckToNote

sub populateAfpData {
  &populateTfpData();
  &populateAfpContributor();
  &populateAfpLasttouched();
  my %afpWithOnlyThreeColumns;
  $afpWithOnlyThreeColumns{'additionalexpr'}++;
  $afpWithOnlyThreeColumns{'othergenefunc'}++;
  $afpWithOnlyThreeColumns{'otherantibody'}++;
  foreach my $datatype (sort keys %datatypesAfpCfp) {
    $result = $dbh->prepare( "SELECT joinkey, afp_$datatypesAfpCfp{$datatype}, afp_timestamp AT TIME ZONE 'UTC', afp_curator, afp_approve, afp_cur_timestamp AT TIME ZONE 'UTC' FROM afp_$datatypesAfpCfp{$datatype}" );
    if ($afpWithOnlyThreeColumns{$datatype}) {
      $result = $dbh->prepare( "SELECT joinkey, afp_$datatypesAfpCfp{$datatype}, afp_timestamp AT TIME ZONE 'UTC' FROM afp_$datatypesAfpCfp{$datatype}" ); }
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
    while (my @row = $result->fetchrow) {
      next unless ($chosenPapers{$row[0]} || $chosenPapers{all});
      my ($joinkey) = &deriveValidPap($row[0]);
      next unless $papValid{$joinkey};
#       my $data = ''; my $negated = 0;
#       if ($row[1] eq '[{"id":1,"name":"","publicationId":""}]') { $row[1] = ''; }
#       if ($row[1] eq '[{"id":1,"name":""}]') { $row[1] = ''; }
# previously author negative was based on tfp having some value, now we're treating author negative independent of tfp.  2025 11 10
#       if ($row[1]) { $data = $row[1]; }
#         elsif ($tfpData{$datatype}{$joinkey}{data}) { $negated = 1; }
#         else { next; }						# skip entry if no author data and no tfp_ data.
#       if ($row[1]) { $data = $row[1]; } else { $negated = 1; }		# if author says something, that's data and note, else it's negated
      my ($data, $negated) = &convertAckToNote($row[1], $datatype);
      # my $row = join"\t", @row;
      # print qq($datatype\tafp_$datatypesAfpCfp{$datatype}\t$row\n);
      my $tsdigits = &tsToDigits($row[2]);
      $data =~ s/\n/ /g; $data =~ s/ $//g;
      if ($tsdigits < '20190322') { 
        if ( ($datatype eq 'humandisease') || ($datatype eq 'humdis') ) {	# ranjana doesn't want old afp disease data 2025 12 15
#           $afpAutData{'disease'}{$joinkey}{note}      = $data;
#           $afpAutData{'disease'}{$joinkey}{negated}   = 0;		# there was no tfp_ data to validate old afp
#           $afpAutData{'disease'}{$joinkey}{source}    = 'author_first_pass';
#           $afpAutData{'disease'}{$joinkey}{timestamp} = $row[2];
          1; }	# ranjana doesn't want old afp disease data 2025 12 15
        else {
          $afpAutData{$datatype}{$joinkey}{note}      = $data;
          $afpAutData{$datatype}{$joinkey}{negated}   = 0;		# there was no tfp_ data to validate old afp
          $afpAutData{$datatype}{$joinkey}{source}    = 'author_first_pass';
          $afpAutData{$datatype}{$joinkey}{timestamp} = $row[2]; } }
      else {
        if ( ($datatype eq 'disease') || ($datatype eq 'humdis') ) {	# ranjana wants to treat ACK afp_humdis as parent level disease  2025 11 11
          $afpAutData{'humandisease'}{$joinkey}{note}      = $data;  
          $afpAutData{'humandisease'}{$joinkey}{negated}   = $negated;
          $afpAutData{'humandisease'}{$joinkey}{source}    = 'ack';
          $afpAutData{'humandisease'}{$joinkey}{timestamp} = $row[2]; }
        else {
          $afpAutData{$datatype}{$joinkey}{note}      = $data;  
          $afpAutData{$datatype}{$joinkey}{negated}   = $negated;
          $afpAutData{$datatype}{$joinkey}{source}    = 'ack';
          $afpAutData{$datatype}{$joinkey}{timestamp} = $row[2]; } }
      if ($row[3]) {
        my $curator = $row[3]; $curator =~ s/two/WBPerson/;
        my $negated = 0;
        if ($row[4] eq 'rejected') { $negated = 1; }
        if ( ($datatype eq 'humandisease') || ($datatype eq 'humdis') ) {	# ranjana doesn't want old afp disease data 2025 12 15
#           $afpCurData{'disease'}{$joinkey}{curator}   = $curator;
#           $afpCurData{'disease'}{$joinkey}{negated}   = $negated;
#           $afpCurData{'disease'}{$joinkey}{timestamp} = $row[5];
          1; }
        else {
          $afpCurData{$datatype}{$joinkey}{curator}   = $curator;
          $afpCurData{$datatype}{$joinkey}{negated}   = $negated;
          $afpCurData{$datatype}{$joinkey}{timestamp} = $row[5]; } }
    }
    foreach my $joinkey (sort keys %afpLasttouched) {
      unless ($afpAutData{$datatype}{$joinkey}) {
        my $tsdigits = &tsToDigits($afpLasttouched{$joinkey});
        next unless ($tsdigits < '20190322');
        next if ( ($datatype eq 'humandisease') || ($datatype eq 'humdis') );	# ranjana doesn't want old afp disease data 2025 12 15
        next if ($datatype eq 'newstrains');					# this was not part of afp  2026 01 07
        $afpAutData{$datatype}{$joinkey}{note}      = "no data entered by author";
        $afpAutData{$datatype}{$joinkey}{negated}   = 1;	# inferred negative by afp
        $afpAutData{$datatype}{$joinkey}{source}    = 'author_first_pass';
        $afpAutData{$datatype}{$joinkey}{timestamp} = $afpLasttouched{$joinkey}; } }
} }

sub populateAfpContributor {
  $result = $dbh->prepare( "SELECT joinkey, afp_contributor FROM afp_contributor" );
  $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
  while (my @row = $result->fetchrow) {
    next unless ($chosenPapers{$row[0]} || $chosenPapers{all});
    next unless ($row[1]);
    my ($joinkey) = &deriveValidPap($row[0]);
    next unless $papValid{$joinkey};
    my $who = $row[1]; $who =~ s/two/WBPerson/;
    $afpContributor{$row[0]}{$who}++;
} }

sub populateAfpLasttouched {
  $result = $dbh->prepare( "SELECT joinkey, afp_lasttouched, afp_timestamp  AT TIME ZONE 'UTC' FROM afp_lasttouched WHERE afp_timestamp < '2019-03-22 00:00:01'" );
  $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
  while (my @row = $result->fetchrow) {
    next unless ($chosenPapers{$row[0]} || $chosenPapers{all});
    my ($joinkey) = &deriveValidPap($row[0]);
    next unless $papValid{$joinkey};
    $afpLasttouched{$joinkey} = $row[2]; } }

# Valerio and Kimberly agreed there's no TFP data for topics, they'll be entities later.  But we do need the tfp_data to derive something about afp data.   2024 03 04
sub populateTfpData {
  return if (%tfpData);		# this called for generating tfpdata but also for afpdata, but don't need to read it twice if already has data
  my %hasAfpButNoTfp;
  $hasAfpButNoTfp{'newstrains'}++;		# 2025 10 09
  $hasAfpButNoTfp{'additionalexpr'}++;		# 2025 10 31
  $hasAfpButNoTfp{'othergenefunc'}++;		# 2025 10 31
  $hasAfpButNoTfp{'disease'}++;			# 2025 11 11	# not a real afp, mapping old afp/cfp for humdis to disease
  foreach my $datatype (sort keys %datatypesAfpCfp) {
    next if ($hasAfpButNoTfp{$datatype});	# has afp but not tfp
    $result = $dbh->prepare( "SELECT joinkey, tfp_$datatypesAfpCfp{$datatype}, tfp_timestamp AT TIME ZONE 'UTC' FROM tfp_$datatypesAfpCfp{$datatype}" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
    while (my @row = $result->fetchrow) {
      next unless ($chosenPapers{$row[0]} || $chosenPapers{all});
      next unless ($row[1]);
      my ($joinkey) = &deriveValidPap($row[0]);
      next unless $papValid{$joinkey};
      $row[1] =~ s/\n/ /g; $row[1] =~ s/ $//g;
      $tfpData{$datatype}{$joinkey}{data} = $row[1];
      $tfpData{$datatype}{$joinkey}{timestamp} = $row[2];
} } }

# Valerio and Kimberly agreed there's no TFP data for topics, they'll be entities later.  2024 03 04
# sub outputTfpData {
#   my $source_type = 'acknowledge_pipeline';
#   foreach my $datatype (sort keys %tfpData) {
#     unless ($datatypes{$datatype}) { 
#       print ERR qq(no topic for cur_tfpdata $datatype\n); 
#       next;
#     }
#     my $source_method = 'ACKnowledge';
#     my $source_id = &getSourceId($source_type, $source_method);
#     unless ($source_id) {
#       print qq(ERROR no source_id for $source_type and $source_method);
#       return;
#     }
#     foreach my $joinkey (sort keys %{ $tfpData{$datatype} }) {
#       my %object;
#       my $negated = FALSE;  
#       $object{'negated'}                    = $negated;
#       $object{'reference_curie'}            = $wbpToAgr{$joinkey};
#       $object{'topic'}                      = $datatypes{$datatype};
#       $object{'topic_entity_tag_source_id'} = $source_id;
#       $object{'data_novelty'}               = 'ATP:0000335';
#       $object{'created_by'}                 = 'caltech_pipeline';
#       $object{'updated_by'}                 = 'caltech_pipeline';
#       $object{'date_created'}               = $tfpData{$datatype}{$joinkey}{timestamp};
#       $object{'date_updated'}               = $tfpData{$datatype}{$joinkey}{timestamp};
#       if ($output_format eq 'json') {
#         push @output_json, \%object; }
#       else {
#         my $object_json = encode_json \%object;
#         &createTag($object_json); }
#   } }
# }


# sub populateAfpData_CURATION_STATUS {
#   foreach my $datatype (sort keys %chosenDatatypes) {
#     next unless $datatypesAfpCfp{$datatype};
#     my $pgtable_datatype = $datatypesAfpCfp{$datatype};
#     $result = $dbh->prepare( "SELECT * FROM afp_$pgtable_datatype" );
#     $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
#     while (my @row = $result->fetchrow) {
#       next unless ($curatablePapers{$row[0]});
#       $afpData{$datatype}{$row[0]} = $row[1]; }
#   } # foreach my $datatype (sort keys %chosenDatatypes)
# 
#   $result = $dbh->prepare( "SELECT * FROM afp_email" );
#   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
#   while (my @row = $result->fetchrow) {
#     next unless ($curatablePapers{$row[0]});
#     $afpEmailed{$row[0]}++; }
#   $result = $dbh->prepare( "SELECT * FROM afp_lasttouched" );
#   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
#   while (my @row = $result->fetchrow) {
#     next unless ($curatablePapers{$row[0]});
#     foreach my $datatype (sort keys %chosenDatatypes) {
#       $afpFlagged{$datatype}{$row[0]}++; } }
#   foreach my $datatype (sort keys %chosenDatatypes) {
#     foreach my $joinkey (sort keys %{ $afpFlagged{$datatype} }) {
#       if ($afpData{$datatype}{$joinkey}) { $afpPos{$datatype}{$joinkey}++; }
#         else { $afpNeg{$datatype}{$joinkey}++; } } }
# } # sub populateAfpData_CURATION_STATUS



sub outputCfpData {
  my $data_provider = $mod;
  my $secondary_data_provider = $mod;
  my $source_evidence_assertion = 'ATP:0000036';
  my $source_method = 'curator_first_pass';
  my $source_id = &getSourceId($source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider);
  unless ($source_id) {
    print PERR qq(ERROR no source_id for $source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider\n);
    return;
  }
#   { "source_type": "professional_biocurator", "source_method": "wormbase_curation_status", "evidence": "eco_string", "description": "cur_curdata", "mod_abbreviation": "WB" }
  foreach my $datatype (sort keys %cfpData) {
    unless ($datatypes{$datatype}) { 
      print PERR qq(no topic for cfpData $datatype\n); 
      next;
    }
    foreach my $joinkey (sort keys %{ $cfpData{$datatype} }) {
      next unless ($chosenPapers{$joinkey} || $chosenPapers{all});
      my ($joinkey) = &deriveValidPap($joinkey);
      next unless $papValid{$joinkey};
#       unless ($wbpToAgr{$joinkey}) { print PERR qq(ERROR paper $joinkey NOT AGRKB\n); next; }
      my $negated = FALSE;
      if ($cfpData{$datatype}{$joinkey}{data}) {
          if ($cfpData{$datatype}{$joinkey}{data} =~ m/false positive/i) { $negated = TRUE; } }
        else { $negated = TRUE; }
      my %object;
      $object{'negated'}                    = $negated;
      $object{'force_insertion'}            = TRUE;
      if ($cfpData{$datatype}{$joinkey}{data}) {
        $object{'note'}                     = $cfpData{$datatype}{$joinkey}{data}; }
      $object{'reference_curie'}            = "WB:WBPaper$joinkey";
#       $object{'reference_curie'}            = $wbpToAgr{$joinkey};
      $object{'topic'}                      = $datatypes{$datatype};
      $object{'topic_entity_tag_source_id'} = $source_id;
      $object{'data_novelty'}               = 'ATP:0000335';
      $object{'created_by'}                 = $cfpData{$datatype}{$joinkey}{curator};
      $object{'updated_by'}                 = $cfpData{$datatype}{$joinkey}{curator};
      $object{'date_created'}               = $cfpData{$datatype}{$joinkey}{timestamp};
      $object{'date_updated'}               = $cfpData{$datatype}{$joinkey}{timestamp};
      if ($output_format eq 'json') {
        push @output_json, \%object; }
      else {
        my $object_json = encode_json \%object;
        &createTag($object_json); }
  } }
}

sub populateCfpData {
  foreach my $datatype (sort keys %datatypesAfpCfp) {
    my %hasAfpButNoCfp;
    $hasAfpButNoCfp{'newstrains'}++;		# 2025 10 09
    $hasAfpButNoCfp{'additionalexpr'}++;	# 2025 10 31
    $hasAfpButNoCfp{'othergenefunc'}++;		# 2025 10 31
    $hasAfpButNoCfp{'otherantibody'}++;		# 2025 10 31	this has a cfp table, but it has no data
    next if ($hasAfpButNoCfp{$datatype});	# has afp but not cfp  2025 10 09
    $result = $dbh->prepare( "SELECT joinkey, cfp_$datatypesAfpCfp{$datatype}, cfp_curator, cfp_timestamp AT TIME ZONE 'UTC' FROM cfp_$datatypesAfpCfp{$datatype}" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
    while (my @row = $result->fetchrow) {
      next unless ($chosenPapers{$row[0]} || $chosenPapers{all});
      next unless ($row[2]);
      my ($joinkey) = &deriveValidPap($row[0]);
      next unless $papValid{$joinkey};
      my $curator = $row[2]; $curator =~ s/two/WBPerson/;
      $row[1] =~ s/\n/ /g; $row[1] =~ s/ $//g;
      next if ( ($datatype eq 'humandisease') || ($datatype eq 'humdis') );	# ranjana doesn't want cfp disease data 2025 12 15
      $cfpData{$datatype}{$joinkey}{data} = $row[1];
      $cfpData{$datatype}{$joinkey}{curator} = $curator;
      $cfpData{$datatype}{$joinkey}{timestamp} = $row[3];
#       my $row = join"\t", @row;
#       print qq($datatype\tcfp_$datatypesAfpCfp{$datatype}\t$row\n);
} } }


sub outputCurStrData {
  foreach my $datatype (sort keys %strData) {
    unless ($datatype eq 'antibody') {
      print PERR qq(Only allowed string type is antibody, no $datatype\n); 
      next;
    }
    unless ($datatypes{$datatype}) { 
      print PERR qq(no topic for cur_strdata $datatype\n); 
      next;
    }
    my $data_provider = $mod;
    my $secondary_data_provider = $mod;
    my $source_evidence_assertion = 'ECO:0008021';
    my $source_method = 'string_matching_antibody';
    my $source_id = &getSourceId($source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider);
    unless ($source_id) {
      print PERR qq(ERROR no source_id for $source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider\n);
      return;
    }
    # only data for 1 source exists, everything has date after 2019 03 22
    # my $source_method_2 = 'script_antibody_data_2';
    # my $source_id_2 = &getSourceId($source_type, $source_method_2);
    # unless ($source_id_2) {
    #   print qq(ERROR no source_id for $source_type and $source_method_2);
    #   return;
    # }
    foreach my $joinkey (sort keys %{ $strData{$datatype} }) {
      next unless ($chosenPapers{$joinkey} || $chosenPapers{all});
      my ($joinkey) = &deriveValidPap($joinkey);
      next unless $papValid{$joinkey};
#       unless ($wbpToAgr{$joinkey}) { print PERR qq(ERROR paper $joinkey NOT AGRKB\n); next; }
      my %object;
      # my $source_id = $source_id_1;
      # my $tsdigits = &tsToDigits($strData{$datatype}{$joinkey}{timestamp});
      # if ($tsdigits > '20190322') { $source_id = $source_id_2; }
      my $negated = TRUE;
      if ($strData{$datatype}{$joinkey}{result}) { $negated = FALSE; }
      $object{'negated'}                    = $negated;
      $object{'force_insertion'}            = TRUE;
      if ($negated == TRUE) {
        $object{'confidence_level'}         = 'NEG'; }
      if ($strData{$datatype}{$joinkey}{result}) {
        $object{'note'}                     = $strData{$datatype}{$joinkey}{result}; }
      $object{'reference_curie'}            = "WB:WBPaper$joinkey";
#       $object{'reference_curie'}            = $wbpToAgr{$joinkey};
      $object{'topic'}                      = $datatypes{$datatype};
      $object{'topic_entity_tag_source_id'} = $source_id;
      $object{'data_novelty'}               = 'ATP:0000335';
      $object{'created_by'}                 = 'caltech_pipeline';
      $object{'updated_by'}                 = 'caltech_pipeline';
      $object{'date_created'}               = $strData{$datatype}{$joinkey}{timestamp};
      $object{'date_updated'}               = $strData{$datatype}{$joinkey}{timestamp};
      if ($output_format eq 'json') {
        push @output_json, \%object; }
      else {
        my $object_json = encode_json \%object;
        &createTag($object_json); }
  } }
}

sub populateCurStrData {
  $result = $dbh->prepare( "SELECT cur_paper, cur_datatype, cur_date, cur_strdata, cur_version, cur_timestamp AT TIME ZONE 'UTC' FROM cur_strdata ORDER BY cur_timestamp" );     # in case multiple values get in for a paper-datatype (shouldn't happen), keep the latest
  $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
  while (my @row = $result->fetchrow) {
    next unless ($chosenPapers{$row[0]} || $chosenPapers{all});
    my ($joinkey) = &deriveValidPap($row[0]);
    next unless $papValid{$joinkey};
    $row[3] =~ s/\n/ /g; $row[3] =~ s/ $//g;
    $strData{$row[1]}{$joinkey}{date}       = $row[2];
    $strData{$row[1]}{$joinkey}{result}     = $row[3];
    $strData{$row[1]}{$joinkey}{version}    = $row[4];
    $strData{$row[1]}{$joinkey}{timestamp}  = $row[5]; }
} # sub populateCurStrData


sub outputCurNncData {
  foreach my $datatype (sort keys %nncData) {
    unless ($datatypes{$datatype}) { 
      print PERR qq(no topic for cur_nncdata $datatype\n); 
      next;
    }
    my $data_provider = $mod;
    my $secondary_data_provider = $mod;
    my $source_evidence_assertion = 'ECO:0008025';
    my $source_method = 'nnc_' . $datatype;
    my $source_id = &getSourceId($source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider);
    unless ($source_id) {
      print PERR qq(ERROR no source_id for $source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider);
      return;
    }

    foreach my $joinkey (sort keys %{ $nncData{$datatype} }) {
      next unless ($chosenPapers{$joinkey} || $chosenPapers{all});
      my ($joinkey) = &deriveValidPap($joinkey);
      next unless $papValid{$joinkey};
#       unless ($wbpToAgr{$joinkey}) { print PERR qq(ERROR paper $joinkey NOT AGRKB\n); next; }
      my %object;
      my $negated = FALSE;  
      if ($nncData{$datatype}{$joinkey}{result} eq 'NEG') { $negated = TRUE; }
      $object{'negated'}                    = $negated;
      $object{'force_insertion'}            = TRUE;
      $object{'confidence_level'}           = uc($nncData{$datatype}{$joinkey}{result});
      $object{'reference_curie'}            = "WB:WBPaper$joinkey";
#       $object{'reference_curie'}            = $wbpToAgr{$joinkey};
      $object{'topic'}                      = $datatypes{$datatype};
      $object{'topic_entity_tag_source_id'} = $source_id;
      $object{'data_novelty'}               = 'ATP:0000335';
      $object{'created_by'}                 = 'caltech_pipeline';
      $object{'updated_by'}                 = 'caltech_pipeline';
      $object{'date_created'}               = $nncData{$datatype}{$joinkey}{date};
      $object{'date_updated'}               = $nncData{$datatype}{$joinkey}{date};
      if ($output_format eq 'json') {
        push @output_json, \%object; }
      else {
        my $object_json = encode_json \%object;
        &createTag($object_json); }
  } }
}

sub populateCurNncData {
  $result = $dbh->prepare( "SELECT cur_paper, cur_datatype, cur_date, cur_nncdata, cur_timestamp AT TIME ZONE 'UTC' FROM cur_nncdata ORDER BY cur_timestamp" );     # in case multiple values get in for a paper-datatype (shouldn't happen), keep the latest
  $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
  while (my @row = $result->fetchrow) {
    next unless ($chosenPapers{$row[0]} || $chosenPapers{all});
    my ($joinkey) = &deriveValidPap($row[0]);
    next unless $papValid{$joinkey};
    $row[3] =~ s/\n/ /g; $row[3] =~ s/ $//g;
    my $date = $row[5];
    if ($row[2] =~ m/^(\d{4})(\d{2})(\d{2})$/) {
        my ($year, $mon, $day) = $row[2] =~ m/^(\d{4})(\d{2})(\d{2})$/;
        $date = $year . '-' . $mon . '-' . $day . ' 00:00:01'; }
      else { print qq(NO DATE @row\n); }
    $nncData{$row[1]}{$joinkey}{date}       = $date;
    $nncData{$row[1]}{$joinkey}{result}     = $row[3];
    $nncData{$row[1]}{$joinkey}{timestamp}  = $row[4]; }
} # sub populateCurNncData


sub outputCurSvmData {
  foreach my $datatype (sort keys %svmData) {
    unless ($datatypes{$datatype}) { 
      print PERR qq(no topic for cur_svmdata $datatype\n); 
      next;
    }
    my $data_provider = $mod;
    my $secondary_data_provider = $mod;
    my $source_evidence_assertion = 'ECO:0008019';
    my $source_method = 'svm_' . $datatype;
    my $source_id = &getSourceId($source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider);
    unless ($source_id) {
      print PERR qq(ERROR no source_id for $source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider\n);
      return;
    }
    foreach my $joinkey (sort keys %{ $svmData{$datatype} }) {
      next unless ($chosenPapers{$joinkey} || $chosenPapers{all});
      my ($joinkey) = &deriveValidPap($joinkey);
      next unless $papValid{$joinkey};
#       unless ($wbpToAgr{$joinkey}) { print PERR qq(ERROR paper $joinkey NOT AGRKB\n); next; }
      my %object;
      my $negated = FALSE;  
      if ($svmData{$datatype}{$joinkey}{result} eq 'NEG') { $negated = TRUE; }
      $object{'negated'}                    = $negated;
      $object{'force_insertion'}            = TRUE;
      $object{'confidence_level'}           = uc($svmData{$datatype}{$joinkey}{result});
      $object{'reference_curie'}            = "WB:WBPaper$joinkey";
#       $object{'reference_curie'}            = $wbpToAgr{$joinkey};
      $object{'topic'}                      = $datatypes{$datatype};
      $object{'topic_entity_tag_source_id'} = $source_id;
      $object{'data_novelty'}               = 'ATP:0000335';
      $object{'created_by'}                 = 'caltech_pipeline';
      $object{'updated_by'}                 = 'caltech_pipeline';
      $object{'date_created'}               = $svmData{$datatype}{$joinkey}{date};
      $object{'date_updated'}               = $svmData{$datatype}{$joinkey}{date};
      if ($output_format eq 'json') {
        push @output_json, \%object; }
      else {
        my $object_json = encode_json \%object;
        &createTag($object_json); }
  } }
}

sub populateCurSvmData {
  $result = $dbh->prepare( "SELECT cur_paper, cur_datatype, cur_date, cur_svmdata, cur_version, cur_timestamp AT TIME ZONE 'UTC' FROM cur_svmdata ORDER BY cur_timestamp" );     # in case multiple values get in for a paper-datatype (shouldn't happen), keep the latest
  $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
  while (my @row = $result->fetchrow) {
    next unless ($chosenPapers{$row[0]} || $chosenPapers{all});
    next if ($row[1] eq 'expression_cluster');	# Kimberly thinks Wen doesn't want this.  2025 10 30
    my ($joinkey) = &deriveValidPap($row[0]);
    next unless $papValid{$joinkey};
    $row[3] =~ s/\n/ /g; $row[3] =~ s/ $//g;
    my $date = $row[5];
    if ($row[2] =~ m/^(\d{4})(\d{2})(\d{2})$/) {
        my ($year, $mon, $day) = $row[2] =~ m/^(\d{4})(\d{2})(\d{2})$/;
        $date = $year . '-' . $mon . '-' . $day . ' 00:00:01'; }
      else { print qq(NO DATE @row\n); }
    $svmData{$row[1]}{$joinkey}{date}       = $date;
    $svmData{$row[1]}{$joinkey}{result}     = $row[3];
    $svmData{$row[1]}{$joinkey}{version}    = $row[4];
    $svmData{$row[1]}{$joinkey}{timestamp}  = $row[5]; }
} # sub populateCurSvmData


sub outputCurCurData {
  my $data_provider = $mod;
  my $secondary_data_provider = $mod;
  my $source_evidence_assertion = 'ATP:0000036';
  my $source_method = 'curation_status_form';
  my $source_id = &getSourceId($source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider);
  unless ($source_id) {
    print PERR qq(ERROR no source_id for $source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider\n);
    return;
  }
#   { "source_type": "professional_biocurator", "source_method": "wormbase_curation_status", "evidence": "eco_string", "description": "cur_curdata", "mod_abbreviation": "WB" }
  foreach my $datatype (sort keys %curData) {
    unless ($datatypes{$datatype}) { 
      print PERR qq(no topic for cur_curdata $datatype\n); 
      next;
    }
    foreach my $joinkey (sort keys %{ $curData{$datatype} }) {
# next unless ($joinkey eq '00005199');	# selcomment + txtcomment
# next unless ($joinkey eq '00037049');	# timestamp with timezone to utc different date 2018-06-27 17:31:33.510441-07 -> 2018-06-28 00:31:33.510441
      next unless ($chosenPapers{$joinkey} || $chosenPapers{all});
      my ($joinkey) = &deriveValidPap($joinkey);
      next unless $papValid{$joinkey};
#       unless ($wbpToAgr{$joinkey}) { print PERR qq(ERROR paper $joinkey NOT AGRKB\n); next; }
      my %object;
      my $negated = FALSE;  
      if ($curData{$datatype}{$joinkey}{donposneg} eq 'negative') { $negated = TRUE; }
      my @notes; my $note = undef;
      if ($curData{$datatype}{$joinkey}{selcomment}) { push @notes, $premadeComments{$curData{$datatype}{$joinkey}{selcomment}}; }
      if ($curData{$datatype}{$joinkey}{txtcomment}) { push @notes, $curData{$datatype}{$joinkey}{txtcomment}; }
      if (scalar @notes > 0) { $note = join " | ", @notes; }
      $object{'negated'}                    = $negated;
      $object{'force_insertion'}            = TRUE;
      if ($note) {
        $object{'note'}                     = $note; }
      $object{'reference_curie'}            = "WB:WBPaper$joinkey";
#       $object{'reference_curie'}            = $wbpToAgr{$joinkey};
      $object{'topic'}                      = $datatypes{$datatype};
      $object{'topic_entity_tag_source_id'} = $source_id;
      $object{'data_novelty'}               = 'ATP:0000335';
      $object{'created_by'}                 = $curData{$datatype}{$joinkey}{curator};
      $object{'updated_by'}                 = $curData{$datatype}{$joinkey}{curator};
      $object{'date_created'}               = $curData{$datatype}{$joinkey}{timestamp};
      $object{'date_updated'}               = $curData{$datatype}{$joinkey}{timestamp};
      if ($output_format eq 'json') {
        push @output_json, \%object; }
      else {
        my $object_json = encode_json \%object;
        &createTag($object_json); }
  } }
}

sub populateCurCurData {
  my $datatypeSource = 'caltech';
#   $result = $dbh->prepare( "SELECT * FROM cur_curdata WHERE cur_site = '$datatypeSource' ORDER BY cur_timestamp" );     # in case multiple values get in for a paper-datatype (shouldn't happen), keep the latest
  $result = $dbh->prepare( "SELECT cur_paper, cur_datatype, cur_site, cur_curator, cur_curdata, cur_selcomment, cur_txtcomment, cur_timestamp AT TIME ZONE 'UTC' FROM cur_curdata WHERE cur_site = '$datatypeSource' ORDER BY cur_timestamp" );     # in case multiple values get in for a paper-datatype (shouldn't happen), keep the latest
  $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
  while (my @row = $result->fetchrow) {
    next unless ($chosenPapers{$row[0]} || $chosenPapers{all});
    my ($joinkey) = &deriveValidPap($row[0]);
    next unless $papValid{$joinkey};
#     next unless ($chosenDatatypes{$row[1]});
    next if ( ($row[4] eq 'notvalidated') || ($row[4] eq '') );                                         # skip entries marked as notvalidated
# next unless ($row[0] eq '00005199');
# print qq(@row\n);
    $row[6] =~ s/\n/ /g; $row[6] =~ s/^ //g; $row[6] =~ s/ $//g;
    my $curator = $row[3]; $curator =~ s/two/WBPerson/;
    $curData{$row[1]}{$joinkey}{site}       = $row[2];
    $curData{$row[1]}{$joinkey}{curator}    = $curator;
    $curData{$row[1]}{$joinkey}{donposneg}  = $row[4];
    $curData{$row[1]}{$joinkey}{selcomment} = $row[5];
    $curData{$row[1]}{$joinkey}{txtcomment} = $row[6];
# print qq($row[5] $row[6]\n);
    $curData{$row[1]}{$joinkey}{timestamp}  = $row[7]; }
} # sub populateCurCurData


sub getSourceId {
  my ($source_evidence_assertion, $source_method, $data_provider, $secondary_data_provider) = @_;
  my $url = $baseUrl . 'topic_entity_tag/source/' . $source_evidence_assertion . '/' . $source_method . '/' . $data_provider . '/' . $secondary_data_provider;
#   my ($source_type, $source_method) = @_;
#   my $url = $baseUrl . 'topic_entity_tag/source/' . $source_type . '/' . $source_method . '/' . $mod;
#   print qq($url\n);
  my $api_json = `curl -X 'GET' $url -H 'accept: application/json' -H 'Authorization: Bearer $cognito_token' -H 'Content-Type: application/json'`;
  # print qq($api_json\n);
  my $hash_ref = decode_json $api_json;
  if ($$hash_ref{'topic_entity_tag_source_id'}) {
    my $source_id = $$hash_ref{'topic_entity_tag_source_id'};
    # print qq($source_id\n);
    return $source_id; }
  else { return ''; }
}

sub retryCreateTag {
  my ($object_json) = @_;
  $retry_counter++;
  if ($retry_counter > 4) {
    print ERR qq(api failed without response $retry_counter times, giving up\n);
    print OUT qq(api failed without response $retry_counter times, giving up\n);
    $retry_counter = 0; }
  else {
    print ERR qq(api failed $retry_counter times, retrying\n);
    print OUT qq(api failed $retry_counter times, retrying\n);
    my $sleep_amount = 4 ** $retry_counter;
    sleep $sleep_amount;
    &createTag($object_json); }
} # sub retryCreateTag

sub createTag {
  my ($object_json) = @_;
  $tag_counter++;
  if ($tag_counter % 1000 == 0) {
    my $date = &getSimpleSecDate();
    print qq(counter\t$tag_counter\t$date\n);
    my $now = time;
    if ($now - $start_time > 82800) {           # if 23 hours went by, update okta token
      $cognito_token = &generateCognitoToken();
      $start_time = $now;
    }
  }
  my $url = $baseUrl . 'topic_entity_tag/';
#   my $api_json = `curl -X 'POST' $url -H 'accept: application/json' -H 'Authorization: Bearer $cognito_token' -H 'Content-Type: application/json' --data '$object_json'`;	# this has issues with how the shell interprets special characters like parentheses ( and ) when passed directly in the command line.  instead avoid the shell and run the command through a pipe like  open my $fh, "-|", @args

  my $ua = LWP::UserAgent->new;
  my $req = HTTP::Request->new(POST => $url);
  $req->header('accept' => 'application/json');
  $req->header('Authorization' => "Bearer $cognito_token");
  $req->header('Content-Type' => 'application/json');
  $req->content($object_json);
  my $res = $ua->request($req);

  print OUT qq(create $object_json\n);
  my $api_json = $res->decoded_content;
  print OUT qq($api_json\n);
  if ($res->is_success) {
    if ($api_json =~ /"status":"success"/) {
      $success_counter++;
      $retry_counter = 0;
    }
    elsif ($api_json =~ /"status":"exists"/) {
      $exists_counter++;
      print ERR qq(create $object_json\n);
      print ERR qq(EXISTS	$api_json\n);
      $retry_counter = 0;
    }
    else {
      $unexpected_success_counter++;
      print ERR qq(create $object_json\n);
      print ERR qq(UNEXPECTED SUCCESS	$api_json\n);
      &retryCreateTag($object_json);
    }
  } else {
    $failure_counter++;
    print ERR qq(create $object_json\n);
    print ERR "HTTP Error: ", $res->status_line, "\n", $api_json, "\n";
    if ($api_json =~ /"detail":"Invalid or expired token: Signature has expired."/) {	# this never happens, it's not is_success
      print ERR qq(create $object_json\n);
      print ERR qq(EXPIRED TOKEN	$api_json\n);
      $cognito_token = &generateCognitoToken();
      print ERR qq(NEW TOKEN	$cognito_token\n);
      &retryCreateTag($object_json);
    }
    elsif ($api_json =~ /"detail":"invalid request"/) {
      $invalid_request_counter++;
      print ERR qq(create $object_json\n);
      print ERR qq(INVALID REQUEST	$api_json\n);
      $retry_counter = 0;
    }
    elsif ($api_json =~ /"detail":"Reference with the reference_id or curie/) {
      $invalid_reference_counter++;
      print ERR qq(create $object_json\n);
      print ERR qq(INVALID REFERENCE	$api_json\n);
      $retry_counter = 0;
    }
    else {
      $unexpected_failure_counter++;
      print ERR qq(create $object_json\n);
      print ERR qq(UNEXPECTED FAILURE	$api_json\n);
      &retryCreateTag($object_json);
    }
  }
} # sub createTag

sub generateCognitoToken {
  my $cognito_result = `curl -X POST "$ENV{COGNITO_TOKEN_URL}" \ -H "Content-Type: application/x-www-form-urlencoded" \ -d "grant_type=client_credentials" \ -d "client_id=$ENV{COGNITO_ADMIN_CLIENT_ID}" \ -d "client_secret=$ENV{COGNITO_ADMIN_CLIENT_SECRET}"`;
  my $hash_ref = decode_json $cognito_result;
  my $cognito_token = $$hash_ref{'access_token'};
#   print $cognito_token;
  print qq(GENERATE TOKEN $cognito_token\n);
  print OUT qq(GENERATE TOKEN $cognito_token\n);
  return $cognito_token;
}

sub generateOktaToken {
#   my $okta_token = `curl -s --request POST --url https://$ENV{OKTA_DOMAIN}/v1/token \    --header 'accept: application/json' \    --header 'cache-control: no-cache' \    --header 'content-type: application/x-www-form-urlencoded' \    --data "grant_type=client_credentials&scope=admin&client_id=$ENV{OKTA_CLIENT_ID}&client_secret=$ENV{OKTA_CLIENT_SECRET}" \      | jq '.access_token' | tr -d '"'`;
  my $okta_result = `curl -s --request POST --url https://$ENV{OKTA_DOMAIN}/v1/token \    --header 'accept: application/json' \    --header 'cache-control: no-cache' \    --header 'content-type: application/x-www-form-urlencoded' \    --data "grant_type=client_credentials&scope=admin&client_id=$ENV{OKTA_CLIENT_ID}&client_secret=$ENV{OKTA_CLIENT_SECRET}"`;
  my $hash_ref = decode_json $okta_result;
  my $okta_token = $$hash_ref{'access_token'};
#   print $okta_token;
  return $okta_token;
}

# sub generateXrefJsonFile {
#   my $okta_token = &generateOktaToken();
#   `curl -X 'GET' 'https://stage-literature-rest.alliancegenome.org/bulk_download/references/external_ids/' -H 'accept: application/json' -H 'Authorization: Bearer $cognito_token' -H 'Content-Type: application/json'  > $xref_file_path`;
# }

sub tsToDigits {
  my $timestamp = shift;
  my $tsdigits = '';
  if ($timestamp =~ m/^(\d{4})\-(\d{2})\-(\d{2})/) { $tsdigits = $1 . $2 . $3; }
  return $tsdigits;
}

sub populatePremadeComments {
  $premadeComments{"1"}  = "SVM Positive, Curation Negative";
  $premadeComments{"2"}  = "C. elegans as heterologous expression system";
  $premadeComments{"3"}  = "Curated for GO (by WB)";
  $premadeComments{"4"}  = "Curated for GO (by GOA)";
  $premadeComments{"5"}  = "Curated for GO (by IntAct)";
  $premadeComments{"6"}  = "Curated for BioGRID (by WB)";
  $premadeComments{"7"}  = "Curated for BioGRID (by BG)";
  $premadeComments{"8"}  = "Curated for GO (by WB), Curated for BioGRID (by WB)";
  $premadeComments{"9"}  = "Curated for GO (by WB), Curated for BioGRID (by BG)";
  $premadeComments{"10"} = "Curated for GO (by GOA), Curated for BioGRID (by WB)";
  $premadeComments{"11"} = "Curated for GO (by GOA), Curated for BioGRID (by BG)";
  $premadeComments{"12"} = "Curated for GO (by IntAct), Curated for BioGRID (by WB)";
  $premadeComments{"13"} = "Curated for GO (by IntAct), Curated for BioGRID (by BG)";
  $premadeComments{"14"} = "Curation Negative, no Strain name given in paper";
  $premadeComments{"15"} = "Toxicology";
  $premadeComments{"16"} = "Host-pathogen/virulence";
  $premadeComments{"17"} = "Disease model";
  $premadeComments{"18"} = "Non-genetic disease model";
  $premadeComments{"19"} = "Genetic disease model";
} # sub populatePremadeComments

sub populateDatatypesAndABC {
  $result = $dbh->prepare( "SELECT DISTINCT(cur_datatype) FROM cur_nncdata" );
  $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
  while (my @row = $result->fetchrow) { $datatypesAfpCfp{$row[0]} = $row[0]; }
  $datatypesAfpCfp{'chemicals'}      = 'chemicals';             # added for Karen 2013 10 02
#   $datatypesAfpCfp{'blastomere'}    = 'cellfunc';		# raymond doesn't want this
  $datatypesAfpCfp{'exprmosaic'}     = 'siteaction';
#   $datatypesAfpCfp{'geneticmosaic'} = 'mosaic';		# raymond doesn't want this
#   $datatypesAfpCfp{'laserablation'} = 'ablationdata';		# raymond doesn't want this
  $datatypesAfpCfp{'humandisease'}   = 'humdis';                # added mapping to correct table 2018 05 17
#   $datatypesAfpCfp{'rnaseq'}        = 'rnaseq';               # wen doesn't want this
  $datatypesAfpCfp{'chemphen'}       = 'chemphen';              # for new afp form 2018 10 31
  $datatypesAfpCfp{'envpheno'}       = 'envpheno';              # for new afp form 2018 10 31
  $datatypesAfpCfp{'timeaction'}     = 'timeaction';            # for new afp form 2018 11 13
  $datatypesAfpCfp{'siteaction'}     = 'siteaction';            # for new afp form 2018 11 13
  $datatypesAfpCfp{'otherantibody'}  = 'otherantibody';         # for new afp form 2025 10 31
  $datatypesAfpCfp{'seqfeat'}        = 'seqfeat';               # for new afp form 2025 10 31
  $datatypesAfpCfp{'domanal'}        = 'domanal';               # for new afp form 2025 10 31
  $datatypesAfpCfp{'funccomp'}       = 'funccomp';              # for new afp form 2025 10 31
  $datatypesAfpCfp{'additionalexpr'} = 'additionalexpr';        # for new afp form 2025 10 31
  $datatypesAfpCfp{'othergenefunc'}  = 'othergenefunc';         # for new afp form 2025 10 31
  $datatypesAfpCfp{'marker'}         = 'marker';                # for new afp form 2025 10 31
  $datatypesAfpCfp{'lsrnai'}         = 'lsrnai';                # for new afp form 2025 10 31
  $datatypesAfpCfp{'extvariation'}   = 'extvariation';          # for genetics and g3 linking  2025 10 09
  $datatypesAfpCfp{'newstrains'}     = 'newstrains';            # for genetics and g3 linking  does not have tfp cfp   2025 10 09
#   $datatypesAfpCfp{'disease'}        = 'humdis';                # for old afp/cfp humdis that ranjana wants treated differently  2025 11 11	ranjana no longer wants old afp nor cfp  2025 12 15
  # delete $datatypesAfpCfp{'catalyticact'};     # has svm but no afp / cfp      # afp got added, so cfp table also created.  2018 11 07
  delete $datatypesAfpCfp{'expression_cluster'}; # has svm but no afp / cfp      # should have been removed 2017 07 08, fixed 2017 08 04
  # delete $datatypesAfpCfp{'genesymbol'};       # has svm but no afp / cfp      # added 2021 01 25	# no, it does have afp / cfp
  delete $datatypesAfpCfp{'transporter'};        # has svm but no afp / cfp      # added 2021 01 25
  
  # &manualPopulateTopicToAtp();	# don't use this, Kimberly will manually maintain the file topic_to_atp
  my $topic_to_atp_file = 'topic_to_atp';
  open (IN, "$topic_to_atp_file") or die "Cannot open $topic_to_atp_file: $!";
  while (my $line = <IN>) {
    chomp $line;
    my ($topic, $atp) = split/\t/, $line;
    $datatypes{$topic} = $atp;
  }
  close(IN) or die "Cannot close $topic_to_atp_file : $!";

#   &populateAbcXrefSample();
#   &populateAbcXref();		# if sending AGRKB
  &populatePapValid();
  &populatePapMerge();
} # sub populateDatatypesAndABC

sub manualPopulateTopicToAtp {	# don't use this, Kimberly will manually maintain the file topic_to_atp
  $datatypes{'additionalexpr'}     = 'ATP:0000010';
  $datatypes{'antibody'}           = 'ATP:0000096';
# $datatypes{'blastomere'}         = 'ATP:0000143';	# correct mapping, curator doesn't want transferred
  $datatypes{'catalyticact'}       = 'ATP:0000061';
  $datatypes{'chemicals'}          = 'ATP:0000278';
  $datatypes{'chemphen'}           = 'ATP:0000080';
# $datatypes{'covalent'}           = 'ATP:0000061';	# kimberly says covered by catalyticact
  $datatypes{'domanal'}            = 'ATP:0000019';
  $datatypes{'envpheno'}           = 'ATP:0000080';
  $datatypes{'expression'}         = 'ATP:0000041';
# $datatypes{'expression_cluster'} = 'ATP:0000044';	# correct mapping, curator doesn't want transferred
# $datatypes{'expmosaic'}          = 'ATP:0000034';	# correct mapping, curator doesn't want transferred
  $datatypes{'extvariation'}       = 'ATP:0000285';
  $datatypes{'funccomp'}           = 'ATP:0000071';
  $datatypes{'geneint'}            = 'ATP:0000068';
  $datatypes{'geneprod'}           = 'ATP:0000069';
  $datatypes{'genereg'}            = 'ATP:0000070';
  $datatypes{'genestudied'}        = 'ATP:0000005';
  $datatypes{'genesymbol'}         = 'ATP:0000048'; 
# $datatypes{'geneticablation'}    = 'ATP:0000032';	# correct mapping, curator doesn't want transferred
# $datatypes{'geneticmosaic'}      = 'ATP:0000034';	# correct mapping, curator doesn't want transferred
  $datatypes{'humandisease'}       = 'ATP:0000152';
# $datatypes{'laserablation'}      = 'ATP:0000032';	# correct mapping, curator doesn't want transferred
  $datatypes{'lsrnai'}             = 'ATP:0000082';
  $datatypes{'marker'}             = 'ATP:0000010';	# additionalexpr ?
  $datatypes{'newmutant'}          = 'ATP:0000083';
  $datatypes{'newstrains'}         = 'ATP:0000027';	# not part of strain script
# $datatypes{'optogenet'}          = 'ATP:0000145';	# correct mapping, curator doesn't want transferred
  $datatypes{'otherantibody'}      = 'ATP:0000096';
  $datatypes{'otherexpr'}          = 'ATP:0000041';	# 10 ?
# $datatypes{'otherspecies'}       = 'ATP:0000123';	# part of species script
# $datatypes{'otherstrain'}        = 'ATP:0000027';	# part of strain script
# $datatypes{'othertransgene'}     = 'ATP:0000110';	# part of transgene script
# $datatypes{'othervariation'}     = 'ATP:0000285';	# part of variation script
  $datatypes{'overexpr'}           = 'ATP:0000084';
# $datatypes{'picture'}            = 'no atp, skip';
  $datatypes{'rnai'}               = 'ATP:0000082';
# $datatypes{'rnaseq'}             = 'ATP:0000146';	# correct mapping, curator doesn't want transferred
  $datatypes{'seqchange'}          = 'ATP:0000056';
  $datatypes{'seqfeat'}            = 'ATP:0000055';
  $datatypes{'siteaction'}         = 'ATP:0000033';
# $datatypes{'species'}            = 'ATP:0000123';	# part of species script
# $datatypes{'strain'}             = 'ATP:0000027';	# part of strain script
  $datatypes{'structcorr'}         = 'ATP:0000054';
# $datatypes{'timeaction'}         = 'no atp, skip';
# $datatypes{'transgene'}          = 'ATP:0000110';	# part of transgene script
  $datatypes{'transporter'}        = 'ATP:0000062';
# $datatypes{'variation'}          = 'ATP:0000285';	# part of variation script
} # sub manualPopulateTopicToAtp

sub deriveValidPap {
  my ($joinkey) = @_;
  if ($papValid{$joinkey}) { return $joinkey; }
    elsif ($papMerge{$joinkey}) {
      ($joinkey) = &deriveValidPap($papMerge{$joinkey});
      return $joinkey; }
    else { return 'NOTVALID'; }
} # sub deriveValidPap

sub populatePapValid {
  $result = $dbh->prepare( "SELECT * FROM pap_status WHERE pap_status = 'valid';" );
  $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
  while (my @row = $result->fetchrow) {
    $papValid{$row[0]}++; }
}

sub populatePapMerge {
  $result = $dbh->prepare( "SELECT * FROM pap_identifier WHERE pap_identifier ~ '^[0-9]{8}\$';" );
  $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
  while (my @row = $result->fetchrow) {
    $papMerge{$row[1]} = $row[0]; }
}

# sub populateAbcXref {
#   $result = $dbh->prepare( "SELECT * FROM pap_identifier WHERE pap_identifier ~ 'AGRKB';" );
#   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 	# only molecules with papers are curated
#   while (my @row = $result->fetchrow) { 
#     next unless ($chosenPapers{$row[0]} || $chosenPapers{all});
#     $wbpToAgr{$row[0]} = $row[1]; }
# } # sub populateAbcXref
# 
# sub populateAbcXrefFlatfile {
#   # generated by get_pap_identifier_agrkb.pl  but make sure to get newest xrefs from correct ABC db first, then run it to update file.
#   my $infile = 'files/wb_abc';
#   open (IN, "<$infile") or die "Cannot open $infile : $!";
#   while (my $line = <IN>) {
#     chomp $line;
#     my ($wb, $agr) = split/\t/, $line;
#     $wbpToAgr{$wb} = $agr;
#   }
#   close (IN) or die "Cannot close $infile : $!";
# } # sub populateAbcXrefFlatfile
# 
# sub populateAbcXrefSample {
#   $wbpToAgr{'00004952'} = 'AGRKB:101000000618370';
#   $wbpToAgr{'00005199'} = 'AGRKB:101000000618566';
#   $wbpToAgr{'00026609'} = 'AGRKB:101000000620861';
#   $wbpToAgr{'00030933'} = 'AGRKB:101000000622619';
#   $wbpToAgr{'00035427'} = 'AGRKB:101000000624596';
#   $wbpToAgr{'00046571'} = 'AGRKB:101000000630958';
#   $wbpToAgr{'00057043'} = 'AGRKB:101000000390100';
#   $wbpToAgr{'00064676'} = 'AGRKB:101000000947815';
#   $wbpToAgr{'00037049'} = 'AGRKB:101000000625405';
# }

sub populateOaData {
  my %chosenDatatypes;
  foreach my $datatype (sort keys %datatypesAfpCfp) { $chosenDatatypes{$datatype}++; }

  if ($chosenDatatypes{'chemicals'}) {
      # there are 5 source for curated molecules, and 7 sources for papers related to curated molecules, from Karen 2013 11 02
    $result = $dbh->prepare( "SELECT * FROM mop_name WHERE joinkey IN (SELECT joinkey FROM mop_paper WHERE mop_paper IS NOT NULL AND mop_paper != '')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 	# only molecules with papers are curated
    while (my @row = $result->fetchrow) { $objsCurated{'chemicals'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM app_molecule WHERE joinkey NOT IN (SELECT joinkey FROM app_nodump)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { 
      my (@chemicals) = $row[1] =~ m/(WBMol:\d+)/g;
      foreach my $chemical (@chemicals) { $objsCurated{'chemicals'}{$chemical}++; } }
    $result = $dbh->prepare( "SELECT * FROM grg_moleculeregulator" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { 
      my (@chemicals) = $row[1] =~ m/(WBMol:\d+)/g;
      foreach my $chemical (@chemicals) { $objsCurated{'chemicals'}{$chemical}++; } }
    $result = $dbh->prepare( "SELECT * FROM pro_molecule" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { 
      my (@chemicals) = $row[1] =~ m/(WBMol:\d+)/g;
      foreach my $chemical (@chemicals) { $objsCurated{'chemicals'}{$chemical}++; } }
    $result = $dbh->prepare( "SELECT * FROM rna_molecule WHERE joinkey NOT IN (SELECT joinkey FROM rna_nodump)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { 
      my (@chemicals) = $row[1] =~ m/(WBMol:\d+)/g;
      foreach my $chemical (@chemicals) { $objsCurated{'chemicals'}{$chemical}++; } }

    $result = $dbh->prepare( "SELECT * FROM mop_paper" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'chemicals'}{$paper} = 'curated'; } }
    $result = $dbh->prepare( "SELECT * FROM app_paper WHERE joinkey IN (SELECT joinkey FROM app_molecule WHERE app_molecule IS NOT NULL AND app_molecule != '')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'chemicals'}{$paper} = 'curated'; } }
    $result = $dbh->prepare( "SELECT * FROM grg_paper WHERE joinkey IN (SELECT joinkey FROM grg_moleculeregulator WHERE grg_moleculeregulator IS NOT NULL AND grg_moleculeregulator != '')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'chemicals'}{$paper} = 'curated'; } }
    $result = $dbh->prepare( "SELECT * FROM pro_paper WHERE joinkey IN (SELECT joinkey FROM pro_molecule WHERE pro_molecule IS NOT NULL AND pro_molecule != '')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'chemicals'}{$paper} = 'curated'; } }
    $result = $dbh->prepare( "SELECT * FROM rna_paper WHERE joinkey NOT IN (SELECT joinkey FROM rna_nodump) AND joinkey IN (SELECT joinkey FROM rna_molecule WHERE rna_molecule IS NOT NULL AND rna_molecule != '')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'chemicals'}{$paper} = 'curated'; } }
    $result = $dbh->prepare( "SELECT * FROM int_paper WHERE joinkey IN (SELECT joinkey FROM int_moleculeone WHERE int_moleculeone IS NOT NULL) OR joinkey IN (SELECT joinkey FROM int_moleculetwo WHERE int_moleculetwo IS NOT NULL) OR joinkey IN (SELECT joinkey FROM int_moleculenondir WHERE int_moleculenondir IS NOT NULL)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'chemicals'}{$paper} = 'curated'; } }
  } # if ($chosenDatatypes{'chemicals'})

  if ($chosenDatatypes{'newmutant'}) {
    $result = $dbh->prepare( "SELECT * FROM app_variation WHERE joinkey NOT IN (SELECT joinkey FROM app_nodump)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'newmutant'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM app_paper WHERE joinkey NOT IN (SELECT joinkey FROM app_needsreview) AND joinkey NOT IN (SELECT joinkey FROM app_curator WHERE app_curator = 'WBPerson29819') AND joinkey NOT IN (SELECT joinkey FROM app_nodump)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'newmutant'}{$paper} = 'curated'; } } }
  if ($chosenDatatypes{'overexpr'}) {
    $result = $dbh->prepare( "SELECT * FROM app_transgene WHERE joinkey NOT IN (SELECT joinkey FROM app_nodump)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'overexpr'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM app_paper WHERE joinkey IN (SELECT joinkey FROM app_transgene WHERE app_transgene IS NOT NULL AND app_transgene != '') AND joinkey NOT IN (SELECT joinkey FROM app_nodump)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'overexpr'}{$paper} = 'curated'; } } }

  if ($chosenDatatypes{'antibody'}) {
    $result = $dbh->prepare( "SELECT * FROM abp_name" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'antibody'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM abp_paper" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'antibody'}{$paper} = 'curated'; } } }

  if ($chosenDatatypes{'otherexpr'}) {
    $result = $dbh->prepare( "SELECT * FROM exp_name WHERE joinkey NOT IN (SELECT joinkey FROM exp_nodump)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'otherexpr'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM exp_paper WHERE joinkey NOT IN (SELECT joinkey FROM exp_nodump)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'otherexpr'}{$paper} = 'curated'; } } }

  if ($chosenDatatypes{'humandisease'}) {
    $result = $dbh->prepare( "SELECT * FROM dis_wbgene" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'humandisease'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM dis_paperdisrel" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'humandisease'}{$paper} = 'curated'; } }
    $result = $dbh->prepare( "SELECT * FROM dis_paperexpmod" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'humandisease'}{$paper} = 'curated'; } } }

  if ($chosenDatatypes{'seqfeature'}) {
    $result = $dbh->prepare( "SELECT * FROM sqf_name" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'seqfeature'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM sqf_paper" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'seqfeature'}{$paper} = 'curated'; } } }

  if ($chosenDatatypes{'genereg'}) {
    $result = $dbh->prepare( "SELECT * FROM grg_intid WHERE joinkey NOT IN (SELECT joinkey FROM grg_nodump)" );	# genereg object counts were coming from grg_name instead of grg_intid.  2015 02 04
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'genereg'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM grg_paper WHERE joinkey NOT IN (SELECT joinkey FROM grg_nodump)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'genereg'}{$paper} = 'curated'; } } }

  if ($chosenDatatypes{'geneint'}) {	# corresponds to int_type being genetic, meaning not physical nor predicted 2015 04 02
    my %int;
    $result = $dbh->prepare( "SELECT * FROM int_name;" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $int{'name'}{$row[0]} = $row[1]; }
    $result = $dbh->prepare( "SELECT * FROM int_paper" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $int{'paper'}{$row[0]} = $row[1]; }
    $result = $dbh->prepare( "SELECT * FROM int_type" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $int{'type'}{$row[0]} = $row[1]; }
    $result = $dbh->prepare( "SELECT * FROM int_nodump" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $int{'nodump'}{$row[0]} = $row[1]; }
    my %typeSkip; 
    $typeSkip{"Physical"}++;
    $typeSkip{"ProteinProtein"}++;
    $typeSkip{"ProteinDNA"}++;
    $typeSkip{"ProteinRNA"}++;
    $typeSkip{"Predicted"}++;
    foreach my $joinkey (sort keys %{ $int{'name'} }) {
      next unless $int{'type'}{$joinkey};
      next if ($typeSkip{$int{'type'}{$joinkey}});
      next if ($int{'nodump'}{$joinkey});
      $objsCurated{'geneint'}{$int{'name'}{$joinkey}}++; 
      if ($int{'paper'}{$joinkey}) {
        my (@papers) = $int{'paper'}{$joinkey} =~ m/WBPaper(\d+)/g;
        foreach my $paper (@papers) {
          $oaData{'geneint'}{$paper} = 'curated'; } } } }

  if ($chosenDatatypes{'geneprod'}) {	# corresponds to int_type being physical.  2015 04 02
    $result = $dbh->prepare( "SELECT * FROM int_name WHERE joinkey IN (SELECT joinkey FROM int_type WHERE int_type = 'Physical' OR int_type = 'ProteinProtein' OR int_type = 'ProteinDNA' OR int_type = 'ProteinRNA') AND joinkey NOT IN (SELECT joinkey FROM int_nodump)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'geneprod'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM int_paper WHERE joinkey IN (SELECT joinkey FROM int_type WHERE int_type = 'Physical' OR int_type = 'ProteinProtein' OR int_type = 'ProteinDNA' OR int_type = 'ProteinRNA') AND joinkey NOT IN (SELECT joinkey FROM int_nodump)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'geneprod'}{$paper} = 'curated'; } } }

  if ($chosenDatatypes{'rnai'}) {
    $result = $dbh->prepare( "SELECT * FROM rna_name WHERE joinkey NOT IN (SELECT joinkey FROM rna_nodump)" );
#     $result = $dbh->prepare( "SELECT * FROM rna_name WHERE joinkey NOT IN (SELECT joinkey FROM rna_nodump) AND joinkey NOT IN (SELECT joinkey FROM rna_fromgenereg)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'rnai'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM rna_paper WHERE joinkey NOT IN (SELECT joinkey FROM rna_nodump) AND joinkey NOT IN (SELECT joinkey FROM rna_curator WHERE rna_curator = 'WBPerson29819')" );
#     $result = $dbh->prepare( "SELECT * FROM rna_paper WHERE joinkey NOT IN (SELECT joinkey FROM rna_nodump) AND joinkey NOT IN (SELECT joinkey FROM rna_fromgenereg)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'rnai'}{$paper} = 'curated'; } } }


    # these are not in the OA but they're in postgres, so are here
  if ($chosenDatatypes{'picture'}) {
    $result = $dbh->prepare( "SELECT * FROM pic_name WHERE joinkey NOT IN (SELECT joinkey FROM pic_nodump)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'picture'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM pic_paper WHERE joinkey NOT IN (SELECT joinkey FROM pic_nodump)" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'picture'}{$paper} = 'curated'; } } }

  if ($chosenDatatypes{'blastomere'}) {
    $result = $dbh->prepare( "SELECT * FROM wbb_wbbtf WHERE joinkey IN (SELECT joinkey FROM wbb_assay WHERE wbb_assay = 'Blastomere_isolation')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'blastomere'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM wbb_reference WHERE joinkey IN (SELECT joinkey FROM wbb_assay WHERE wbb_assay = 'Blastomere_isolation')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'blastomere'}{$paper} = 'curated'; } } }

  if ($chosenDatatypes{'exprmosaic'}) {
    $result = $dbh->prepare( "SELECT * FROM wbb_wbbtf WHERE joinkey IN (SELECT joinkey FROM wbb_assay WHERE wbb_assay = 'Expression_mosaic')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'exprmosaic'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM wbb_reference WHERE joinkey IN (SELECT joinkey FROM wbb_assay WHERE wbb_assay = 'Expression_mosaic')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'exprmosaic'}{$paper} = 'curated'; } } }

  if ($chosenDatatypes{'geneticablation'}) {
    $result = $dbh->prepare( "SELECT * FROM wbb_wbbtf WHERE joinkey IN (SELECT joinkey FROM wbb_assay WHERE wbb_assay = 'Genetic_ablation')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'geneticablation'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM wbb_reference WHERE joinkey IN (SELECT joinkey FROM wbb_assay WHERE wbb_assay = 'Genetic_ablation')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'geneticablation'}{$paper} = 'curated'; } } }

  if ($chosenDatatypes{'geneticmosaic'}) {
    $result = $dbh->prepare( "SELECT * FROM wbb_wbbtf WHERE joinkey IN (SELECT joinkey FROM wbb_assay WHERE wbb_assay = 'Genetic_mosaic')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'geneticmosaic'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM wbb_reference WHERE joinkey IN (SELECT joinkey FROM wbb_assay WHERE wbb_assay = 'Genetic_mosaic')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'geneticmosaic'}{$paper} = 'curated'; } } }

  if ($chosenDatatypes{'optogenetic'}) {
    $result = $dbh->prepare( "SELECT * FROM wbb_wbbtf WHERE joinkey IN (SELECT joinkey FROM wbb_assay WHERE wbb_assay = 'Optogenetic')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'optogenetic'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM wbb_reference WHERE joinkey IN (SELECT joinkey FROM wbb_assay WHERE wbb_assay = 'Optogenetic')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'optogenetic'}{$paper} = 'curated'; } } }

  if ($chosenDatatypes{'laserablation'}) {
    $result = $dbh->prepare( "SELECT * FROM wbb_wbbtf WHERE joinkey IN (SELECT joinkey FROM wbb_assay WHERE wbb_assay = 'Laser_ablation')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) { $objsCurated{'laserablation'}{$row[1]}++; }
    $result = $dbh->prepare( "SELECT * FROM wbb_reference WHERE joinkey IN (SELECT joinkey FROM wbb_assay WHERE wbb_assay = 'Laser_ablation')" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    while (my @row = $result->fetchrow) {
      my (@papers) = $row[1] =~ m/WBPaper(\d+)/g;
      foreach my $paper (@papers) {
        $oaData{'laserablation'}{$paper} = 'curated'; } } }
} # sub populateOaData

__END__


# 2025 11 05   Kimbery and I no longer think we need anything below this line.  We looked into it, and aren't really sure what it's for, but keeping it just in case.


# SELECT cur_selcomment, COUNT(cur_selcomment) FROM cur_curdata GROUP BY cur_selcomment ORDER BY COUNT(cur_selcomment) DESC;
#   $premadeComments{"15"} = "Toxicology";
#   $premadeComments{"16"} = "Host-pathogen/virulence";
#   $premadeComments{"17"} = "Disease model";
#   $premadeComments{"18"} = "Non-genetic disease model";
#   $premadeComments{"19"} = "Genetic disease model";






# my @topic_types = qw( nnc svm afp cfp 
# my %exists;
# foreach my $datatype (sort keys %datatypes) {

my %confidence_to_atp;
$confidence_to_atp{'high'} = 'ATP:0000119';
$confidence_to_atp{'medium'} = 'ATP:0000120';
$confidence_to_atp{'low'} = 'ATP:0000121';
$confidence_to_atp{'neg'} = undef;

my %curdata_to_validated;
$curdata_to_validated{'curated'} = TRUE;
$curdata_to_validated{'positive'} = TRUE;
$curdata_to_validated{'negative'} = FALSE;
$curdata_to_validated{'notvalidated'} = undef;

my %geneToTaxon;
my %varToTaxon;

# Kimberly, we have the same source ECO for different flagging sources, and I don't think we can do that, so tacking on _nnc or whatever for now.  created_by is not an option for source in the API, so we'll need to talk to Valerio about how to enter that and whether we need to.  Only antibody has string data.  What's something that's flagged as negative from ACKnowledge/afp/cfp ?  I thought everything with a value was considered positive.  The curation status form looks whether there's a cfp_curator for a paper, and considers that flagged, then if a datatype for that paper has data it's positive, and if it doesn't it's negative, for the purposes for the big table where you can see percentages, but it's not really true negative data, it's extrapolated, and it can be wrong if a paper was flagged before a datatype was added to the flagging form (made up example: if a paper was flagged in 2005 and blastomeres were added to the form in 2015).  Do you want actual positive data only, or extrapolated negatives too.  If there's a value that the forms use that means negative, we can get that.

foreach my $joinkey (@wbpapers) {
  # topics
# UNCOMMENT THIS LATER
#   foreach my $datatype (sort keys %datatypes) {
#     my %object;
#     my $topic = $datatypes{$datatype};
#     my $source = 'ECO:0000000';
#     my $reference_curie = $wbpToAgr{$joinkey};
#     $object{'reference_curie'} = $wbpToAgr{$joinkey};
#     $object{'topic'} = $datatypes{$datatype};
#     if ($datatypesAfpCfp{$datatype}) {
#       $result = $dbh->prepare( "SELECT * FROM cfp_$datatypesAfpCfp{$datatype} WHERE joinkey = '$joinkey'" );
#       $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
#       while (my @row = $result->fetchrow) {
#         if ($row[0]) { 
#           my %source;
#           $source{'source'} = $source . '_cfp';
#           $source{'confidence_level'} = undef;
#           $source{'validation_type'} = 'manual';
#           $source{'validated'} = TRUE;	# not sure we can extrapolate false if cfp_curator but not cfp_$datatype
#           $source{'note'} = $row[1];
#           $source{'mod_abbreviation'} = 'WB';
#           push @{ $object{'sources'} }, \%source;
#           print qq(cfp $datatype $row[0] $row[1]\n);
#         } # if ($row[0])
#       } # while (@row = $result->fetchrow)
#       $result = $dbh->prepare( "SELECT * FROM afp_$datatypesAfpCfp{$datatype} WHERE joinkey = '$joinkey'" );
#       $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
#       while (my @row = $result->fetchrow) {
#         if ($row[0]) { 
#           my %source;
#           $source{'source'} = $source . '_afp';
#           $source{'confidence_level'} = undef;
#           $source{'validation_type'} = 'manual';
#           $source{'validated'} = TRUE;	# not sure we can extrapolate false if afp_curator but not afp_$datatype
#           $source{'note'} = $row[1];
#           $source{'mod_abbreviation'} = 'WB';
#           push @{ $object{'sources'} }, \%source;
#           print qq(afp $datatype $row[0] $row[1]\n);
#         } # if ($row[0])
#       } # while (@row = $result->fetchrow)
#     } # if ($datatypesAfpCfp{$datatype})
#     $result = $dbh->prepare( "SELECT * FROM cur_curdata WHERE cur_datatype = '$datatype' AND cur_paper = '$joinkey'" );
#     $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
#     while (my @row = $result->fetchrow) {
#       if ($row[0]) { 
#         my %source;
#         $source{'source'} = $source . '_cur';
#         $source{'confidence_level'} = undef;
#         $source{'validation_type'} = 'manual';
#         $source{'validated'} = $curdata_to_validated{$row[4]};
#         if ($row[6]) { $source{'note'} = $row[6]; }
#           else { $source{'note'} = undef; }
#         $source{'mod_abbreviation'} = 'WB';
#         push @{ $object{'sources'} }, \%source;
#         print qq(cur $datatype $row[0] $row[4]\n);
#       } # if ($row[0])
#     } # while (@row = $result->fetchrow)
#     $result = $dbh->prepare( "SELECT * FROM cur_svmdata WHERE cur_datatype = '$datatype' AND cur_paper = '$joinkey'" );
#     $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
#     while (my @row = $result->fetchrow) {
#       if ($row[0]) { 
#         my %source;
#         $source{'source'} = $source . '_svm';
#         $source{'confidence_level'} = $confidence_to_atp{lc($row[3])};
# # This might be wrong, check Valerio/Kimberly
# #         $source{'validation_type'} = undef;
# #         $source{'validated'} = undef;
#         $source{'validation_type'} = 'svm';
#         $source{'validated'} = FALSE;
#         $source{'note'} = undef;
#         $source{'mod_abbreviation'} = 'WB';
#         push @{ $object{'sources'} }, \%source;
#         print qq(svm $datatype $row[0] $row[3]\n);
#       } # if ($row[0])
#     } # while (@row = $result->fetchrow)
#     $result = $dbh->prepare( "SELECT * FROM cur_nncdata WHERE cur_datatype = '$datatype' AND cur_paper = '$joinkey'" );
#     $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
#     while (my @row = $result->fetchrow) {
#       if ($row[0]) { 
#         my %source;
#         $source{'source'} = $source . '_nnc';
#         $source{'confidence_level'} = $confidence_to_atp{lc($row[3])};
# # This might be wrong, check Valerio/Kimberly
# #         $source{'validation_type'} = undef;
# #         $source{'validated'} = undef;
#         $source{'validation_type'} = 'nnc';
#         $source{'validated'} = FALSE;
#         $source{'note'} = undef;
#         $source{'mod_abbreviation'} = 'WB';
#         push @{ $object{'sources'} }, \%source;
#         print qq(nnc $datatype $row[0] $row[3]\n);
#       } # if ($row[0])
#     } # while (@row = $result->fetchrow)
#     if ($object{'sources'} && (scalar @{ $object{'sources'} } > 0)) {
#       my $json = encode_json \%object;
#       print qq($json\n); }
#   } # foreach my $datatype (sort keys %datatypes)

# my %entitytypes;
# $entitytypes{'species'}          = 'ATP:0000123';
# $entitytypes{'gene'}             = 'ATP:0000047';
# $entitytypes{'variation'}        = 'ATP:0000030';
# $entitytypes{'transgene'}        = 'ATP:0000099';
# $entitytypes{'chemical'}         = 'ATP:0000094';
# $entitytypes{'antibody'}         = 'ATP:0000096';
  # entities

#     my %object;
#     my $topic = 'ATP:0000142';
#     my $source = 'ECO:0000000';
#     my $reference_curie = $wbpToAgr{$joinkey};
#     $object{'reference_curie'} = $reference_curie;
#     $object{'topic'} = $topic;
#     $object{'entity_source'} = 'alliance';

    # TO FIX different rows in postgres could have the same paper-gene but different pap_evidence, each of which will create a source with the same data, which ABC won't allow
    # duplicate key value violates unique constraint \"source_topic_entity_tag_unique\"\nDETAIL:  Key (topic_entity_tag_id, mod_id, source)=(232, 2, ECO:0000000_pap_species) already exists.

    # TODO  extract tfp_species, map its data to a taxon and if joinkey+taxon match, create a source
#     my %agr_species;
#     $result = $dbh->prepare( "SELECT * FROM pap_species WHERE joinkey = '$joinkey'" );
#     print qq( SELECT * FROM pap_species WHERE joinkey = '$joinkey';\n );
#     $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
#     while (my @row = $result->fetchrow) {
#       if ($row[0]) { 
#         print qq(ROW @row\n);
#         my $entity = 'NCBITaxon:' . $row[1];
#         # my $entity_type = $entitytypes{'species'};
#         # my $species = 'NCBITaxon:' . $row[1];
#         # my $negated = FALSE;
#         my %source = ();
#         $source{'mod_abbreviation'} = 'WB';
#         $source{'confidence_level'} = undef;
#         if ($row[5]) {
#           if ($row[5] =~ m/Curator_confirmed.*(WBPerson\d+)/) {
#             # $source{'created_by'} = $1;
#             # $source{'date_created'} = $row[4];
#             # $source{'eco_source'} = 'ECO:0000302';
#             # $source{'source_detail'} = undef;
#             $source{'source'} = 'curator';
#             $source{'negated'} = FALSE;
#             # push @{ $object{'sources'} }, \%source;
#             push @{ $agr_species{$entity} }, \%source;
#           }
#           elsif ($row[5] =~ m/Inferred_automatically/) {
#             # $source{'created_by'} = $1;	# get from afp_contributor, loop separate source for each two#
#             # $source{'date_created'} = $row[4];
#             # $source{'eco_source'} = 'ECO:0000302';
#             # $source{'source_detail'} = 'ACKnowledge';
#             $source{'source'} = 'author';
#             $source{'negated'} = FALSE;
#             # push @{ $object{'sources'} }, \%source;
#             push @{ $agr_species{$entity} }, \%source;
#           }
#           elsif ($row[5] eq '') {
#             print qq(NO EVI\n);
#             # $source{'created_by'} = ???
#             # $source{'date_created'} = $row[4];
#             # $source{'eco_source'} = 'ECO:0007669';
#             # $source{'source_detail'} = 'string match to title, abstract, and gene-species association';
#             $source{'source'} = 'caltech script';
#             $source{'negated'} = FALSE;
#             # push @{ $object{'sources'} }, \%source;
#             push @{ $agr_species{$entity} }, \%source;
#     } } } }
#     foreach my $entity (sort keys %agr_species) {
#       my %object;
#       my $topic = 'ATP:0000142';
#       my $source = 'ECO:0000000';
#       my $reference_curie = $wbpToAgr{$joinkey};
#       $object{'reference_curie'} = $reference_curie;
#       $object{'topic'} = $topic;
#       $object{'entity_source'} = 'alliance';
#       $object{'entity'} = $entity;
#       $object{'entity_type'} = $entitytypes{'species'};
#       $object{'species'} = $entity;
#       if ($agr_species{$entity} && (scalar @{ $agr_species{$entity} } > 0)) {
#         foreach my $source_href (@{ $agr_species{$entity} }) {
#           push @{ $object{'sources'} }, $source_href; }
#         my $json = encode_json \%object;
#         print qq($json\n);
#         # $object{'sources'} = ();
#         # print qq(PAP_SPECIES\t);
#     } }

#     $result = $dbh->prepare( "SELECT * FROM pap_species WHERE joinkey = '$joinkey'" );
#     print qq( SELECT * FROM pap_species WHERE joinkey = '$joinkey';\n );
#     $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
#     while (my @row = $result->fetchrow) {
#       if ($row[0]) { 
#         print qq(ROW @row\n);
#         $object{'entity'} = 'NCBITaxon:' . $row[1];
#         $object{'entity_type'} = $entitytypes{'species'};
#         $object{'species'} = 'NCBITaxon:' . $row[1];
#         my %source = ();
#         $source{'mod_abbreviation'} = 'WB';
#         $source{'confidence_level'} = undef;
#         if ($row[5]) {
#           if ($row[5] =~ m/Curator_confirmed.*(WBPerson\d+)/) {
#             # $source{'created_by'} = $1;
#             # $source{'date_created'} = $row[4];
#             # $source{'eco_source'} = 'ECO:0000302';
#             # $source{'source_detail'} = undef;
#             $source{'source'} = 'curator';
#             $source{'negated'} = FALSE;
#             push @{ $object{'sources'} }, \%source; }
#           elsif ($row[5] =~ m/Inferred_automatically/) {
#             # $source{'created_by'} = $1;	# get from afp_contributor, loop separate source for each two#
#             # $source{'date_created'} = $row[4];
#             # $source{'eco_source'} = 'ECO:0000302';
#             # $source{'source_detail'} = 'ACKnowledge';
#             $source{'source'} = 'author';
#             $source{'negated'} = FALSE;
#             push @{ $object{'sources'} }, \%source; }
#           elsif ($row[5] eq '') {
#             print qq(NO EVI\n);
#             # $source{'created_by'} = ???
#             # $source{'date_created'} = $row[4];
#             # $source{'eco_source'} = 'ECO:0007669';
#             # $source{'source_detail'} = 'string match to title, abstract, and gene-species association';
#             $source{'source'} = 'caltech script';
#             $source{'negated'} = FALSE;
#             push @{ $object{'sources'} }, \%source; }
#         }
            
        
#         $source{'source'} = $source . '_pap_species';
#         $source{'confidence_level'} = undef;
#         $source{'validation_type'} = undef;
#         $source{'validated'} = FALSE;
#         $source{'note'} = undef;
#         if ($row[5]) {
#           $source{'validation_type'} = 'manual';
#           $source{'validated'} = TRUE; }
#         push @{ $object{'sources'} }, \%source;

#         my $json = encode_json \%object;
#         $object{'sources'} = ();
#         # print qq(PAP_SPECIES\t);
#         print qq($json\n);
#     } }

# PUT THIS BACK
#     $result = $dbh->prepare( "SELECT * FROM pap_gene WHERE joinkey = '$joinkey'" );
#     $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
#     while (my @row = $result->fetchrow) {
#       if ($row[0]) { 
#         my $gene = 'WB:WBGene' . $row[1];
#         my $taxon = '';
#         if ($geneToTaxon{$row[1]}) { $taxon = $geneToTaxon{$row[1]}; }
#           else {
#             my $result2 = $dbh->prepare( "SELECT * FROM gin_species WHERE joinkey = '$row[1]'" );
#             $result2->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
#             my @row2 = $result2->fetchrow();
#             my $species = $row2[1];
#             $geneToTaxon{$row[1]} = 'NCBITaxon:' . $speciesToTaxon{$species};
#             $taxon = 'NCBITaxon:' . $speciesToTaxon{$species}; }
#         $object{'entity'} = $gene;
#         $object{'entity_type'} = $entitytypes{'gene'};
#         $object{'species'} = $taxon;
#         my %source = ();
#         $source{'source'} = $source . '_pap_gene';
#         $source{'confidence_level'} = undef;
#         $source{'validation_type'} = undef;
#         $source{'validated'} = FALSE;
#         $source{'note'} = undef;
#         if ($row[5]) {
#           my $source = 'ECO:0008008';
#           if ( ($row[5] =~ m/Manually_connected/) || ($row[5] =~ m/Published_as/) || ($row[5] =~ m/Person_evidence/) ||
#                ($row[5] =~ m/Curator_confirmed/) || ($row[5] =~ m/Author_evidence/) ) { $source = 'manual'; }
#             elsif ( $row[5] =~ m/Inferred_automatically/) {
#               if ( ($row[5] =~ m/from curator first pass/) || ($row[5] =~ m/from author first pass/) ) { $source = 'manual'; } }
#           if ($source eq 'manual') {
#             $source{'validation_type'} = 'manual';
#             $source{'validated'} = TRUE; }
#           else {
#             $source{'source'} = $source; } }
#         $source{'mod_abbreviation'} = 'WB';
#         push @{ $object{'sources'} }, \%source;
#         my $json = encode_json \%object;
#         $object{'sources'} = ();
#         print qq(PAP_GENE\t);
#         print qq($json\n);
#     } }
# 
#     $result = $dbh->prepare( "SELECT * FROM afp_variation WHERE joinkey = '$joinkey'" );
#     $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
#     while (my @row = $result->fetchrow) {
#       if ($row[0]) { 
#         my (@wbvar) = $row[1] =~ m/(WBVar\d+)/;
#         foreach my $wbvar (@wbvar) {
#           my $taxon = '';
#           if ($varToTaxon{$row[1]}) { $taxon = $varToTaxon{$row[1]}; }
#             else {
#               my $result2 = $dbh->prepare( "SELECT * FROM obo_data_variation WHERE joinkey = '$row[1]'" );
#               $result2->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
#               my @row2 = $result2->fetchrow();
#               my ($species) = $row2[1] =~ m/species: "(.*)"/;
#               $varToTaxon{$row[1]} = 'NCBITaxon:' . $speciesToTaxon{$species};
#               $taxon = 'NCBITaxon:' . $speciesToTaxon{$species}; }
#           $object{'entity'} = 'WB:' . $wbvar;
#           $object{'entity_type'} = $entitytypes{'variation'};
#           $object{'species'} = $taxon;
#     } } }
} # foreach my $joinkey (@wbpapers)


__END__

my $dbh = DBI->connect ( "dbi:Pg:dbname=testdb;host=131.215.52.76", "", "") or die "Cannot connect to database!\n";	# for remote access

my $result = $dbh->prepare( 'SELECT * FROM two_comment WHERE two_comment ~ ?' );
$result->execute('elegans') or die "Cannot prepare statement: $DBI::errstr\n"; 

$result->execute("doesn't") or die "Cannot prepare statement: $DBI::errstr\n"; 
my $var = "doesn't";
$result->execute($var) or die "Cannot prepare statement: $DBI::errstr\n"; 

my $data = 'data';
unless (is_utf8($data)) { from_to($data, "iso-8859-1", "utf8"); }

my $result = $dbh->do( "DELETE FROM friend WHERE firstname = 'bl\"ah'" );
(also do for INSERT and UPDATE if don't have a variable to interpolate with ? )

can cache prepared SELECTs with $dbh->prepare_cached( &c. );

if ($result->rows == 0) { print "No names matched.\n\n"; }	# test if no return

$result->finish;	# allow reinitializing of statement handle (done with query)
$dbh->disconnect;	# disconnect from DB

http://209.85.173.132/search?q=cache:5CFTbTlhBGMJ:www.perl.com/pub/1999/10/DBI.html+dbi+prepare+execute&cd=4&hl=en&ct=clnk&gl=us

interval stuff : 
SELECT * FROM afp_passwd WHERE joinkey NOT IN (SELECT joinkey FROM afp_lasttouched) AND joinkey NOT IN (SELECT joinkey FROM cfp_curator) AND afp_timestamp < CURRENT_TIMESTAMP - interval '21 days' AND afp_timestamp > CURRENT_TIMESTAMP - interval '28 days';

casting stuff to substring on other types :
SELECT * FROM afp_passwd WHERE CAST (afp_timestamp AS TEXT) ~ '2009-05-14';

to concatenate string to query result :
  SELECT 'WBPaper' || joinkey FROM pap_identifier WHERE pap_identifier ~ 'pmid';
to get :
  SELECT DISTINCT(gop_paper_evidence) FROM gop_paper_evidence WHERE gop_paper_evidence NOT IN (SELECT 'WBPaper' || joinkey FROM pap_identifier WHERE pap_identifier ~ 'pmid') AND gop_paper_evidence != '';
