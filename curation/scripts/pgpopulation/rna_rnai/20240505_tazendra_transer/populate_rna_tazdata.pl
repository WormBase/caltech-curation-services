#!/usr/bin/env perl

# take data generated by
# curation/old_scripts_and_forms/postgres/work/pgpopulation/rna_rnai/20240505_tazendra_transfer/generate_data_from_tazendra.pl
# generate new pgids for it, and add to database.  2024 05 05
#
# also a function to delete stuff that was generated before.  and generate WBRNAi IDs like the OA would to replace rna_name
# and rna_name_hst   so there isn't collision with object IDs generated on prod while tazendra was still taking user data.  2024 05 08

use strict;
use diagnostics;
use DBI;
use Encode qw( from_to is_utf8 );



use Dotenv -load => '/usr/lib/.env';

my $dbh = DBI->connect ( "dbi:Pg:dbname=$ENV{PSQL_DATABASE};host=$ENV{PSQL_HOST};port=$ENV{PSQL_PORT}", "$ENV{PSQL_USERNAME}", "$ENV{PSQL_PASSWORD}") or die "Cannot connect to database!\n";
my $result;

my $offset = '66172';	# lowest pgid in generated data, could read file to extract it, but file won't change

my $newpgid_lowest = 1000000000000;
my $newpgid_highest = 0;

$result = $dbh->prepare( "SELECT * FROM rna_curator ORDER BY joinkey::integer DESC LIMIT 1" );
$result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
my @row = $result->fetchrow();
my $lowest = $row[0];
print qq(LOW $lowest\n);

my @pgcommands;
my %pgtables;

# first read data to get postgres tables used and what the range of new pgids is going to be
my $count = 0;
my $infile = 'taz_rna_data.tsv';
open (IN, "<$infile") or die "Cannot open $infile : $!";
while (my $line = <IN>) {
#   $count++; last if ($count > 1);
  chomp $line;
  my ($table, $old_pgid, $data, $ts) = split/\t/, $line;
  $pgtables{$table}++;
  my $diff = $old_pgid - $offset;
  my $new_pgid = $lowest + $diff + 1;
  if ($new_pgid < $newpgid_lowest)  { $newpgid_lowest  = $new_pgid; }
  if ($new_pgid > $newpgid_highest) { $newpgid_highest = $new_pgid; }
}
close (IN) or die "Cannot close $infile : $!";

&toPopulateStuff();
# &toDeleteStuff();


sub toPopulateStuff {
  print qq(New Pgid Lowest $newpgid_lowest\n);
  print qq(New Pgid Highest $newpgid_highest\n);

  my %pgidToWBRnai;
  my ($newRnaiId) = &getHighestRnaiId();

  for my $i ($newpgid_lowest .. $newpgid_highest) {
    $newRnaiId++;
    my $rnaiIdNumber = &pad8Zeros($newRnaiId);
    my $rnaiId = "WBRNAi$rnaiIdNumber";
    $pgidToWBRnai{$i} = $rnaiId;
    print qq($i\t$rnaiId\n);
  }

  open (IN, "<$infile") or die "Cannot open $infile : $!";
  while (my $line = <IN>) {
  #   $count++; last if ($count > 1);
    chomp $line;
    my ($table, $old_pgid, $data, $ts) = split/\t/, $line;
    $pgtables{$table}++;
    my $diff = $old_pgid - $offset;
    my $new_pgid = $lowest + $diff + 1;
    if ($new_pgid < $newpgid_lowest)  { $newpgid_lowest  = $new_pgid; }
    if ($new_pgid > $newpgid_highest) { $newpgid_highest = $new_pgid; }
    if ( ($table eq 'rna_name') || ($table eq 'rna_name_hst') ) {
      $data = $pgidToWBRnai{$new_pgid}; }
    push @pgcommands, qq(INSERT INTO $table VALUES ('$new_pgid', '$data', '$ts'););
  }
  close (IN) or die "Cannot close $infile : $!";

  foreach my $pgcommand (@pgcommands) {
    print qq($pgcommand\n);
# UNCOMMENT TO POPULATE
#     $dbh->do( $pgcommand );
  }
}


sub getHighestRnaiId {          # look at all rna_name, get the highest number and return
  my $highest = 0;
  my $result = $dbh->prepare( "SELECT rna_name FROM rna_name WHERE rna_name ~ '^WBRNAi'" ); $result->execute();
  while (my @row = $result->fetchrow()) { if ($row[0]) { $row[0] =~ s/WBRNAi//; if ($row[0] > $highest) { $highest = $row[0]; } } }
  return $highest; }
sub pad8Zeros {         # take a number and pad to 8 digits
  my $number = shift;
  if ($number =~ m/^0+/) { $number =~ s/^0+//g; }               # strip leading zeros
  if ($number < 10) { $number = '0000000' . $number; }
  elsif ($number < 100) { $number = '000000' . $number; }
  elsif ($number < 1000) { $number = '00000' . $number; }
  elsif ($number < 10000) { $number = '0000' . $number; }
  elsif ($number < 100000) { $number = '000' . $number; }
  elsif ($number < 1000000) { $number = '00' . $number; }
  elsif ($number < 10000000) { $number = '0' . $number; }
  return $number;
} # sub pad8Zeros


sub toDeleteStuff {
  # generate string to delete
  my $oa_pgids = join(",", (66408 .. 66463));	# for OA
  print qq($oa_pgids\n);
  my $var = join("','", (66408 .. 66463));	# for postgres command
  print qq($var\n);

  my $joinkeys = "'66408','66409','66410','66411','66412','66413','66414','66415','66416','66417','66418','66419','66420','66421','66422','66423','66424','66425','66426','66427','66428','66429','66430','66431','66432','66433','66434','66435','66436','66437','66438','66439','66440','66441','66442','66443','66444','66445','66446','66447','66448','66449','66450','66451','66452','66453','66454','66455','66456','66457','66458','66459','66460','66461','66462','66463'";

  my @pgdeletes;
  foreach my $table (sort keys %pgtables) {
    push @pgdeletes, qq(DELETE FROM $table WHERE joinkey IN ($joinkeys));
  } # foreach my $table (sort keys %pgtables)
  foreach my $pgcommand (@pgdeletes) {
#     print qq($pgcommand\n);
# UNCOMMENT TO POPULATE
#     $dbh->do( $pgcommand );
  }
}
