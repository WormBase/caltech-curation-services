#!/usr/bin/perl -w

# some objects were created to generate an object ID and the pgid data was never use, instead the object ID was used a different pgid.
# transfer data to matching pgid, remove data from non-matching pgid.  2020 06 16

use strict;
use diagnostics;
use DBI;
use Encode qw( from_to is_utf8 );

my $dbh = DBI->connect ( "dbi:Pg:dbname=testdb", "", "") or die "Cannot connect to database!\n"; 
my $result;

my @tables = qw( name summary constructionsummary curator person publicname othername merge nodump micropublication paper drivenbygene gene reporter otherreporter purificationtag recombinationsite constructtype selectionmarker feature threeutr fwdprimer revprimer dna proposedfeature genewithfeature clone laboratory assoctransgene coinjectedwith integrationmethod strain remark humandoid diseasepaper transgenome addgene );

# 21957 "WBPaper00028524" WBCnstr00021801

my %pairs;		# match -> hasData

# this file Karen made that doesn't have everything
# my $infile = 'pairs';
# open (IN, "<$infile") or die "Cannot open $infile : $!";
# while (my $line = <IN>) {
#   chomp $line;
# #   my ($pgidMatch, $pgidData) = split/,/, $line;
#   if ($line =~ m/^(\d+) "WBPaper\d+" WBCnstr0+(\d+)$/) {
#     my ($pgidData, $pgidMatch) = ($1, $2);
#     $pairs{$pgidMatch} = $pgidData;
#   }
# }
# close (IN) or die "Cannot close $infile : $!";

# this file is generated by /home/postgres/work/pgpopulation/oa_general/20200526_objectIds_dontMatch_pgids/find_object_ids_not_pgids.pl
my $infile = 'objectId_not_pgid';
open (IN, "<$infile") or die "Cannot open $infile : $!";
while (my $line = <IN>) {
  chomp $line;
  my (@row) = split/\t/, $line;
  my ($pgidData, $pgidMatch) = ($row[1], $row[2]);
  $pairs{$pgidMatch} = $pgidData;
}
close (IN) or die "Cannot close $infile : $!";


my @pgidMatch = sort keys %pairs;
my $pgidMatch = join"','", @pgidMatch;
my $pgidMatchForOa = $pgidMatch;
$pgidMatchForOa =~ s/\'//g;
print qq(pgidMatch : $pgidMatchForOa\n);

# This stuff will get overwritten
# foreach my $table (@tables) {
#   next if ($table eq 'name');
#   next if ($table eq 'curator');
#   $result = $dbh->prepare( "SELECT * FROM cns_$table WHERE joinkey IN ('$pgidMatch')" );
#   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
#   while (my @row = $result->fetchrow) {
#     if ($row[0]) { 
#       print qq($table\t@row\n);
#   } }
# }
# 
# __END__

my @del_pgcommands;
my @ins_pgcommands;
foreach my $pgidMatch (sort keys %pairs) {
  my $pgidData = $pairs{$pgidMatch};
  foreach my $table (@tables) {
    my $result = $dbh->prepare( "SELECT * FROM cns_$table WHERE joinkey = '$pgidData'" );
    $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
    my @row = $result->fetchrow();
    my $data = $row[1];
    if ($data =~ m/\'/) { $data =~ s/\'/''/g; }
    push @del_pgcommands, qq(DELETE FROM cns_$table WHERE joinkey = '$pgidData');
    push @ins_pgcommands, qq(INSERT INTO cns_${table}_hst VALUES ('$pgidData', NULL));
    push @del_pgcommands, qq(DELETE FROM cns_$table WHERE joinkey = '$pgidMatch');
    push @ins_pgcommands, qq(INSERT INTO cns_${table}_hst VALUES ('$pgidMatch', '$data'));
    if ($data) { 
      push @ins_pgcommands, qq(INSERT INTO cns_${table} VALUES ('$pgidMatch', '$data'));
    }
} }

foreach my $pgcommand (@del_pgcommands, @ins_pgcommands) {
  print qq($pgcommand\n);
# UNCOMMENT TO POPULATE
#   $dbh->do($pgcommand);
}
