#!/usr/bin/perl

# OBSOLETE
# No longer updating loci_all nor genes2molecular_names.txt  2006 12 22


# Form to submit Genes for GO curation





use strict;
use CGI;
use Jex;		# cshlNew getHtmlVar 
# use Pg;
# use LWP::UserAgent;	# getting sanger files for querying
# use LWP;
# use lib qw( /home/acedb/ranjana/citace_upload/go_curation/ );
# use go_curation_go;	# the .go output perl module


my %theHash;
my %required;

my $query = new CGI;	# new CGI form
my $max_columns;	# create number of columns to show by default, define in &initializeHash();
$max_columns = 4;

$required{name}++;
$required{email}++;

my @singles = qw( name email genes gene );
my @block = qw( goterm goinference paper_evidence comment );


my $title = 'GO Gene curation';
my ($header, $footer) = &cshlNew($title);
print "Content-type: text/html\n\n";
print "$header\n";              # make beginning of HTML page
print "<CENTER><FONT SIZE=+2>Submission form for GO annotations</FONT></CENTER><P>\n";
&process();
print "$footer";                # make end of HTML page

sub process {
  my ($var, $action) = &getHtmlVar($query, 'action');
  if ($action eq '') { &printHtmlForm(); }		# Display form, first time, no action
  else {						# Form Button
    print "ACTION : $action : ACTION<BR>\n"; 
    if ($action eq 'Submit !') { &submit(); } 	# check locus and curator 
  }
} # sub process

sub submit {
  &getHtmlValuesFromForm();
  &processValues();
}

sub processValues {
  my $req_flag = 0;
  foreach my $field (sort keys %required) {
    unless ($theHash{$field}{html_value}) { $req_flag++; print "<FONT COLOR=red>There is no $field, please enter a $field</FONT><BR>\n"; } }
  if ($req_flag) { &printHtmlForm(); return; }
  if ($theHash{genes}{html_value}) { 
      my $outfile = '/home/acedb/ranjana/GO/go_user_submissions/listofgenes';
      open (OUT, ">>$outfile") or die "Cannot open $outfile : $!";
      my $date = &getSimpleSecDate();
      print OUT "Date\t$date\n";
      print OUT "Name\t$theHash{name}{html_value}\n";
      print OUT "Email\t$theHash{email}{html_value}\n";
      print OUT "Genes\t$theHash{genes}{html_value}\n\n";
      close (OUT) or die "Cannot close $outfile : $!";
      print "Thanks for submitting these genes for GO curation : $theHash{genes}{html_value}<BR>\n"; }
    else {
      my $outfile = '/home/acedb/ranjana/GO/go_user_submissions/userannots';
      open (OUT, ">>$outfile") or die "Cannot open $outfile : $!";
      my $date = &getSimpleSecDate();
      print OUT "Date\t$date\n";
      print OUT "Name\t$theHash{name}{html_value}\n";
      print OUT "Email\t$theHash{email}{html_value}\n";
      print OUT "Gene\t$theHash{gene}{html_value}\n";
      for my $i (1 .. $max_columns) {
        my $line = '';
        foreach my $type (@block) {
          my $field = $type . $i;
          my $val = $theHash{$field}{html_value};
          if ($val) { $line .= "$val ($type)"; }
          $line .= "\t";
        } 
        print OUT "$line\n";
        print "Thanks for submitting this annotation for GO curation : $theHash{gene}{html_value} $line<BR>\n"; }
      close (OUT) or die "Cannot close $outfile : $!"; }
} # sub processValues

sub getHtmlValuesFromForm {	# read PGparameters value from html form, then display to html
  &initializeHash();
  foreach my $field (@singles) {
    my ($var, $val) = &getHtmlVar($query, "html_value_${field}");
# print "F $field V $val<BR>\n";
    if ($val) { $theHash{$field}{html_value} = $val; } }
  foreach my $type (@block) {
    for my $i (1 .. $max_columns) {
      my $field = $type . $i;
      my ($var, $val) = &getHtmlVar($query, "html_value_$field");
# print "F $field V $val<BR>\n";
      if ($val) { $theHash{$field}{html_value} = $val; } } }
}

sub printHtmlForm {	# Show the form 
  &initializeHash();	# Initialize theHash structure for html names and box sizes
  &printHtmlFormStart();
  &printHtmlSectOne();
  &printHtmlDivider();
  &printHtmlSectTwo();
  &printHtmlDivider();
  &printHtmlSectThree();
} # sub printHtmlForm 

sub printHtmlDivider {
  print "<TR><TD><BR><BR></TD></TR>\n";
} # sub printHtmlDivider

sub printHtmlSectOne {
  print "<TR><TD colspan=20>Please enter your name and email address so we may contact you with any problems or questions. (REQUIRED)</TD></TR>\n";
  &printHtmlInput('name');        	
  &printHtmlInput('email');        	
} # sub printHtmlSectOne

sub printHtmlSectTwo {
  print "<TR><TD colspan=20>Provide a list of genes that you would like annotated :</TD></TR>\n";
  &printHtmlTextarea('genes');        	
} # sub printHtmlSectTwo

sub printHtmlSectThree {
  print "<TR><TD colspan=20>OR &nbsp; provide your own annotations (use this form multiple times for multiple genes, or for more than 5 GO terms for a given gene : </TD></TR>\n";
  &printHtmlInput('gene');        	
  &printHtmlTextareaBlock('goterm');
  &printHtmlSelectBlock('goinference');
  &printHtmlTextareaBlock('paper_evidence');
  &printHtmlTextareaBlock('comment');
} # sub printHtmlSectThree

sub printHtmlFormStart {        # beginning of form
  print <<"  EndOfText";
  <FORM METHOD="POST" ACTION="http://tazendra.caltech.edu/~azurebrd/cgi-bin/forms/go_gene.cgi">
  <INPUT TYPE="HIDDEN" NAME="max_columns" VALUE="$max_columns">
  <TABLE>
  <TR>
    <TD> </TD>
    <TD><INPUT TYPE="submit" NAME="action" VALUE="Submit !"></TD>
  </TR>
  EndOfText
} # sub printHtmlFormStart

sub printHtmlInput {            # print html inputs
  my $type = shift;             # get type, use hash for html parts
  print <<"  EndOfText";
  <TR>
    <TD ALIGN="right"><STRONG>$theHash{$type}{html_field_name} : </STRONG></TD>
    <TD><INPUT NAME="html_value_$type" VALUE="$theHash{$type}{html_value}"  
         SIZE=$theHash{$type}{html_size_main}></TD>
  </TR>
  EndOfText
} # sub printHtmlInput

sub printHtmlTextareaBlock {	# print html textarea blocks (sets of three)
				# e.g. : &printHtmlTextareaBlock('bio_goterm');
  my $main_type = shift;	# get type, use hash for html parts
  print <<"  EndOfText";
  <TR>
    <TD ALIGN="right"><STRONG>$theHash{$main_type}{html_field_name} :</STRONG></TD>
  EndOfText
  for my $i (1 .. $max_columns) {
    my $type = $main_type . $i;
    print"    <TD><TEXTAREA NAME=\"html_value_$type\" ROWS=$theHash{$type}{html_size_minor}
                  COLS=$theHash{$type}{html_size_main}>$theHash{$type}{html_value}</TEXTAREA></TD>\n";
  } # for my $i (1 .. $max_columns)
  print <<"  EndOfText";
  </TR>
  EndOfText
} # sub printHtmlTextareaBlock 

sub printHtmlSelectBlock {	# print html select blocks for inference type (set of three)
				# e.g. : &printHtmlSelectBlock('bio_goinference');
  my $main_type = shift;
  print <<"  EndOfText";
  <TR>
    <TD ALIGN="right"><STRONG>$theHash{$main_type}{html_field_name} :</STRONG></TD>
  EndOfText
  for my $i (1 .. $max_columns) {
    my $type = $main_type . $i;
    my @choices = ();
    if ($main_type =~ m/inference/) { @choices = (' ', 'IDA','IEA','IEP','IGI','IMP','IPI','ISS','NAS','ND','IC','TAS', 'RCA'); }
    elsif ($main_type =~ m/dbtype/) { @choices = ('', 'protein', 'gene', 'transcript', 'complex', 'protein_structure'); }
    elsif ($main_type =~ m/curator_evidence/) { @choices = ('', 'Carol Bastiani', 'Josh Jaffery', 'Ranjana Kishore', 'Raymond Lee', 'Erich Schwarz', 'Kimberly Van Auken', 'Juancarlos Testing'); }
    else { @choices = ('not a valid choice type in printHtmlSelectBlock $main_type' ); }
    print "    <TD><SELECT NAME=\"html_value_$type\" SIZE=1>\n";
    print "      <OPTION selected>$theHash{$type}{html_value}</OPTION>\n";
    foreach (@choices) { print "      <OPTION>$_</OPTION>\n"; }
    print "    </SELECT></TD>\n";
  } # for my $i (1 .. $max_columns)
  print <<"  EndOfText";
  </TR>
  EndOfText
} # sub printHtmlSelectBlock

sub printHtmlTextarea {         # print html textareas
  my $type = shift;             # get type, use hash for html parts
  print <<"  EndOfText";
  <TR>
    <TD ALIGN="right"><STRONG>$theHash{$type}{html_field_name} :</STRONG></TD>
    <TD><TEXTAREA NAME="html_value_$type" ROWS=$theHash{$type}{html_size_minor}
                  COLS=$theHash{$type}{html_size_main}>$theHash{$type}{html_value}</TEXTAREA></TD>
  </TR>
  EndOfText
} # sub printHtmlTextarea


sub initializeHash {
  my ($var, $val) = &getHtmlVar($query, 'max_columns');
  if ($val) { $max_columns = $val; }
  else { $max_columns = 5; }

  for my $i (1 .. $max_columns) {		# loop through each column allowed
    my $field = $i;
    $theHash{$field}{html_field_name} = '';
    $theHash{$field}{html_value} = '';
    $theHash{$field}{html_size_main} = '20';            # default width 40
    $theHash{$field}{html_size_minor} = '2';            # default height 2
  }
  $theHash{"name"}{html_field_name} = 'Your Name';
  $theHash{"email"}{html_field_name} = 'Your Email address';
  $theHash{"genes"}{html_field_name} = 'Genes';
  $theHash{"gene"}{html_field_name} = 'Gene';
  $theHash{"goterm"}{html_field_name} = 'GO Term';
  $theHash{"paper_evidence"}{html_field_name} = 'Paper Evidence';
  $theHash{"goinference"}{html_field_name} = 'GO Evidence';
  $theHash{"comment"}{html_field_name} = 'Comment';

} # sub initializeHash

__END__



my $conn = Pg::connectdb("dbname=testdb");	# connect to postgres database
die $conn->errorMessage unless PGRES_CONNECTION_OK eq $conn->status;

my %theHash;		# huge hash for each field with relevant values
my @PGparameters;	# array of names of pg values for html, pg, and theHash

my %goTerm;		# the Go Terms in postgres, key id, value name

my %cgcHash;		# hash of cgcs, values pmids
my %pmHash;		# hash of pmids, values cgcs

my %hashLocus;		# hash of Sanger flatfile data for key locus (sequences synonyms)
my %hashSequence;	# hash of Sanger flatfile data for key sequence (protein)

my %convertToWBPaper;	# key cgc or pmid or whatever, value WBPaper

my $error_in_data = 0;	# flag if any data is wrong


my $curator = '';
my $data_file = '/home/postgres/public_html/cgi-bin/data/go.txt';
my $ace_file = '/home/postgres/public_html/cgi-bin/data/go.ace';			# not used anymore
my $go_file = '/home/postgres/public_html/cgi-bin/data/go.go';				# not used anymore
my $pro_file = '/home/postgres/public_html/cgi-bin/data/provisional_description.ace';	# not used anymore
# my $save_file = "/home/postgres/public_html/cgi-bin/data/go_save_$curator.txt";
			# doesn't double re-interpolate the $curator name once $curator loaded
			# so using this line below

my $max_columns;	# create number of columns to show by default, define in &initializeHash();
my @ontology = qw( bio cell mol );
my @column_types = qw( goterm goid paper_evidence person_evidence curator_evidence goinference dbtype with qualifier goinference_two dbtype_two with_two qualifier_two comment lastupdate );

&printHeader('Go Curation Form');
# print "<CENTER><FONT SIZE=+4 COLOR=red>UNDER CONSTRUCTION, do NOT use</FONT></CENTER><BR>\n";
# print "<FONT COLOR=red SIZE=+4>Under Construction, use main Curator menu</FONT><BR>\n";
&initializeHash();	# Initialize theHash structure for html names and box sizes
&process();		# do everything
&printFooter();

sub process {
  my ($var, $action) = &getHtmlVar($query, 'action');
  if ($action eq '') { &printHtmlForm(); }		# Display form, first time, no action
  else { 						# Form Button
    print "ACTION : $action : ACTION<BR>\n"; 
    if ($action eq 'Preview !') { &preview(); } 	# check locus and curator 
    if ($action eq 'New Entry !') { &write(); } 	# write to postgres (INSERT)
    if ($action eq 'Update !') { &write(); }		# write to postgres (UPDATE)
    if ($action eq 'Query locus !') { &queryLocus(); }		# query postgres.  also queries sanger and overwrites with postgres values.  2004 09 09
    if ($action eq 'Query wbgene !') { &queryWBGene(); }	# query postgres.  also queries sanger and overwrites with postgres values.  2004 09 09
#     if ($action eq 'Query Sanger !') { &querySanger(); }# query sanger.  no longer an option since Query queries sanger and postgres 2004 09 09
    if ($action eq 'Reset !') { &reset(); }		# reinitialize %theHash and display form
#     if ($action eq 'Save !') { &saveState(); }		# save to file	# no longer using this 2006 02 27
#     if ($action eq 'Load !') { &loadState(); }		# load from file	# no longer using this 2006 02 27
    if ($action eq 'Options !') { &options(); }		# options menu (empty)
    if ($action eq 'Add Column !') { &addColumn(); }	# addColumn to max_columns
    if ($action eq 'Dump .go !') { &dump(); }	# dump postgres to file
    print "ACTION : $action : ACTION<BR>\n"; 
  } # else # if ($action eq '') { &printHtmlForm(); }
} # sub process

#################  Action SECTION #################

sub addColumn {						# see how many columns there are, and make there be 1 more 
  my $joinkey = &getHtmlValuesFromForm(); 		# populate %theHash and get joinkey
  $max_columns++;
  &printHtmlForm();					# show the form again, with the same data
}

sub options {
  print "<P><B>What would you like ?  Tell Juancarlos.</B><BR><P>\n";
} # sub options


sub reset {
  &initializeHash();		# Re-initialize %theHash structure for html names and box sizes 
  &printHtmlForm(); 		# Display form (now empty)
} # sub reset

sub querySanger {
  my ($locus_or_gene, $val) = @_;
  my $locus_flag = 0; my $wbgene_flag = 0;
  if ($locus_or_gene eq 'locus') { $locus_flag++; } else { $wbgene_flag++; }
  my $joinkey = $val;
  my $ua = LWP::UserAgent->new(timeout => 30);	# instantiates a new user agent

    # switched back 2004 04 13
  my $url_locus = 'http://tazendra.caltech.edu/~azurebrd/sanger/loci_all.txt';
#   my $url_locus = 'http://www.sanger.ac.uk/Projects/C_elegans/LOCI/loci_all.txt';
#     # TEMP UNTIL SANGER FIXES THIS   2004 04 08
#   my $url_locus = 'http://tazendra.caltech.edu/~postgres/out/loci_all.txt';
  my $request = HTTP::Request->new(GET => $url_locus);	# grabs url
  my $response = $ua->request($request);	# checks url, dies if not valid.
  print "Error while getting ", $response->request->uri," -- ", $response->status_line, "<BR>\nABORTING QUERY SANGER<BR>\n" unless $response-> is_success;
   # don't die, just warn that Sanger query failed	2004 10 27
#   die "Error while getting ", $response->request->uri," -- ", $response->status_line, "\nAborting" unless $response-> is_success;
  
  my $joinkey_in_form = &getHtmlValuesFromForm(); 		# populate %theHash and get joinkey from form, which is useless since won't joinkey if querying by wbgene
  my @lines = split /\n/, $response->content;	# splits by line
  foreach (@lines) {
#     next unless ($_ =~ m/CGC approved$/);	# ignore those not CGC approved
    next unless ($_ =~ m/approved$/);		# ignore those not CGC approved  2004 08 09, doesn't say CGC anymore
    my @fields = split/,/, $_;			# split by commas
    my $locus = shift @fields;			# get the locus
    if ($locus_flag) {
      unless ($locus eq $joinkey) { next; } }	# only get the value if the locus matches the line of Sanger's loci_all.txt
    my $wbgene = shift @fields;			# get the wbgene (get it out of the way)
    if ($wbgene_flag) {
      unless ($wbgene eq $joinkey) { next; } }	# only get the value if the wbgene matches the line of Sanger's loci_all.txt
    my $junkone = shift @fields;		# 2004 08 09, has an extra 1 in there
    my $allsequence = shift @fields;		# get the sequences, space separated
    my @proteins = $allsequence =~ m/\(.*?\)/g; # grab proteins
    foreach (@proteins) { s/\(WP://g; s/\)//g; }        # filter out non-protein stuff
    $theHash{protein}{html_value} = join ", ", @proteins;
    $allsequence =~ s/\(.*?\)//g;		# filter out stuff in parenthesis
# print "ALL SEQ $allsequence ALL SEQ<BR>\n";
    my @sequences = split/\s+/, $allsequence;	# get sequences into array
    $theHash{sequence}{html_value} = join ", ", @sequences;
    shift @fields; shift @fields; 		# get rid of 2 informationless fields
    pop @fields;				# fields now has synonyms, having gotten rid of all else
    my $synonyms = join ", ", @fields;
    $synonyms =~ s/\s+$//g; $synonyms =~ s/^\s+//g; $synonyms =~ s/\s+/, /g;
    $theHash{synonym}{html_value} = "$synonyms";# put value in %theHash
#     foreach (@sequences) { push @{ $hashLocus{$locus}{sequences}}, $_; }
#     foreach (@fields) { push @{ $hashLocus{$locus}{synonyms} }, $_; }
#     $hashLocus{$locus}{wbgene} = $wbgene;
    $theHash{wbgene}{html_value} = $wbgene;
    $theHash{locus}{html_value} = $locus;	# must assign locus now  2005 10 14
#     $_ =~ s/CGC approved//g;			# gets rid of CGC approved
#     $_ =~ s/\,/ /g;				# replaces commas with spaces
#     my @Genes = split /\s+/, $_;		# splits on one or more space
#     for (@Genes){ next if (length($_) <= 2); $valid_locus{$_}++ }	# gets rid of dubious genes
#     if ($wbgene eq $joinkey) { last; }	# stop looping if already found the value	# don't stop looking because it could stop at a synonym  2006 12 27
#     if ($locus eq $joinkey) { last; }		# stop looping if already found the value
  } # foreach (@lines)

# NO LONGER CARE ABOUT THIS FILE, get from loci_all.txt 2004 10 27
#   my $url_protein = 'ftp://ftp.sanger.ac.uk/pub/databases/wormpep/wormpep.accession';
#   my $request = HTTP::Request->new(GET => $url_protein);	# grabs url
#   my $response = $ua->request($request);	# checks url, dies if not valid.
#   die "Error while getting ", $response->request->uri," -- ", $response->status_line, "\nAborting" unless $response-> is_success;
#   my @lines = split /\n/, $response->content;	# splits by line
#   foreach my $line (@lines) {
#     next unless ($line =~ m/\t/);
#     my @stuff = split/\t/, $line;
#     my $protein = shift @stuff;
#     foreach (@stuff) { $hashSequence{$_} = $protein; }
#   } # foreach my $line (@lines)

#   my $joinkey = &getHtmlValuesFromForm(); 		# populate %theHash and get joinkey
#   print "JOINKEY $joinkey<BR>\n";
# no longer want this since it would overwrite previous locus value
#   $theHash{locus}{html_value} = $joinkey; 		# put value in %theHash
# GET FROM loci_all.txt 
  if ($hashLocus{$joinkey}{sequences}) { 
    my @prots;						# array of proteins
    foreach my $seq (@{ $hashLocus{$joinkey}{sequences}}) { 
      print "SEQ $seq<BR>\n"; 
      if ($hashSequence{$seq}) { 
        print "PROT $hashSequence{$seq}<BR>\n"; 
        push @prots, $hashSequence{$seq}; } }
    $theHash{sequence}{html_value} = join ", ", @{ $hashLocus{$joinkey}{sequences} };
    $theHash{protein}{html_value} = join ", ", @prots;
  }
  if ($hashLocus{$joinkey}{wbgene}) { $theHash{wbgene}{html_value} = $hashLocus{$joinkey}{wbgene}; }
  if ($hashLocus{$joinkey}{synonyms}) { 
    my $synonyms = join ", ", @{ $hashLocus{$joinkey}{synonyms} };
    $synonyms =~ s/\s+$//g; $synonyms =~ s/^\s+//g;
    $synonyms =~ s/\s+/, /g;
#     print "SYN $synonyms<BR>\n";
    $theHash{synonym}{html_value} = "$synonyms";	# put value in %theHash
  } # if ($hashLocus{$joinkey}{synonyms})
  (my $var, $val) = &getHtmlVar($query, 'html_value_main_curator');
  if ($val) { $theHash{curator}{html_value} = $val; }
#   &printHtmlForm();
  return $theHash{wbgene}{html_value};
} # sub querySanger

# This worked when the joinkeys where loci instead of wbgenes, now they're reversed  2005 10 14
# sub queryWBGene {	# query by wbgene
#   my $html_type = 'html_value_main_wbgene';
#   my ($var, $val) = &getHtmlVar($query, $html_type);
#   my $result = $conn->exec( "SELECT * FROM got_wbgene WHERE got_wbgene = '$val' ORDER BY got_timestamp DESC;" );
#   my @row = $result->fetchrow;
#   my $joinkey = $row[0];
#   $theHash{locus}{html_value} = $joinkey;
#   &query($joinkey);
# }
# 
# sub queryLocus {	# query by locus
#   my $joinkey = &getHtmlValuesFromForm(); 		# populate %theHash and get joinkey
#   &query($joinkey);
# } # sub queryLocus

sub queryWBGene {	# query by wbgene
  my $joinkey = &getHtmlValuesFromForm(); 		# populate %theHash and get joinkey
  &query('wbgene', $joinkey);
}

sub queryLocus {	# query by locus
  my $html_type = 'html_value_main_locus';
  my ($var, $val) = &getHtmlVar($query, $html_type);
  my $result = $conn->exec( "SELECT * FROM got_locus WHERE got_locus = '$val' ORDER BY got_timestamp DESC;" );
  my @row = $result->fetchrow;
  if ($row[0]) {
    my $joinkey = $row[0];
    $theHash{wbgene}{html_value} = $joinkey;
    &query('wbgene', $joinkey); }
  else { &query('locus', $val); }
} # sub queryLocus

sub query {		# check postgres for locus, then get values from postgres 
			# and put in %theHash{$type}{html_value} for display
			# check sanger first, then override with postgres values unless postgres has no value  2004 09 09
  my ($locus_or_gene, $val) = @_;
  my ($joinkey) = &querySanger($locus_or_gene, $val);	# query sanger after getting joinkey, or i think &getHtmlValuesFromForm could overwrite values  2004 09 28
  my $found = &findIfPgEntry("$joinkey");		# if wbgene, check if already in Pg
  unless ($found) { 					# if not found
    if ($joinkey eq 'NULL') {				# if wbgene is NULL (wbgene not entered)
      print "<FONT COLOR='blue'><B>ERROR : No wbgene chosen, go back and select one</B></FONT><BR>\n"; 
    } else {						# if wbgene not in postgres
      print "<FONT COLOR='blue'><B>No previous entry for $joinkey in Postgres</B></FONT><BR>\n";
      &printHtmlForm();
    } # if ($joinkey eq 'NULL')
  } else {						# if wbgene found
    foreach my $type (@PGparameters) {
      unless ($theHash{$type}{html_value}) {		# if there's no sanger value, get value from postgres  2004 09 09
        my $result = $conn->exec( "SELECT * FROM got_$type WHERE joinkey = '$joinkey' ORDER BY got_timestamp DESC;" );
#       while (my @row = $result->fetchrow) { 
        my @row = $result->fetchrow;
        my $val = &filterToPrintHtml("$row[1]");	# turn value to Html
        if ($val) { if ($val =~ m/\S/) { $theHash{$type}{html_value} = $val; } }	# put value in %theHash if there's a value in postgres, overwriting sanger value
#       } # while (my @row = $result->fetchrow) 
      } # unless ($theHash{$type}{html_value})
    } # foreach my $type (@PGparameters)
    foreach my $ontology (@ontology) {		# loop through each of three ontology types
      foreach my $column_type (@column_types) {
        my $type = $ontology . '_' . $column_type;
        my $result = $conn->exec( "SELECT * FROM got_$type WHERE joinkey = '$joinkey' ORDER BY got_timestamp ;" );
#         print "SELECT * FROM got_$type WHERE joinkey = '$joinkey' ORDER BY got_timestamp DESC;<BR>\n";
        while (my @row = $result->fetchrow) {
          my $val = &filterToPrintHtml("$row[2]");	# turn value to Html
          my $temp_type = $type . $row[1];
          $theHash{$temp_type}{html_value} = $val;	# put value in %theHash
          if ($row[1] > $max_columns) { $max_columns = $row[1]; }	# reassign column number if querying lots of data
#           if ($row[1] == 1) { last; }
        }
    } }
    &printHtmlForm();
  } # else # unless ($found) 
} # sub query

sub createOldAce {
  my $joinkey = shift;
  foreach my $type (@PGparameters) {
    my $result = $conn->exec( "SELECT * FROM got_$type WHERE joinkey = '$joinkey' ORDER BY got_timestamp DESC;" );
    my @row = $result->fetchrow;
    my $val = &filterToPrintHtml("$row[1]");		# turn value to Html
    my $temp_type = $type;
    $theHash{$temp_type}{value} = $val; }		# put value in %theHash 
  my @allparameters = ();
  foreach my $ontology (@ontology) {			# loop through each of three ontology types
    foreach my $column_type (@column_types) {
        my $field = $ontology . '_' . $column_type;
        push @allparameters, $field } }
  foreach my $type (@allparameters) {			# temporarily populate the hash with old values
    my $result = $conn->exec( "SELECT * FROM got_$type WHERE joinkey = '$joinkey' ORDER BY got_timestamp DESC;" );
    while (my @row = $result->fetchrow) { 
      my $val = &filterToPrintHtml("$row[2]");		# turn value to Html
      my $temp_type = $type . $row[1];
      $theHash{$temp_type}{value} = $val;		# put value in %theHash
      if ($row[1] == 1) { last; }			# stop if get to first column, don't want to get all data, just latest
    } # while (my @row = $result->fetchrow) 
  } # foreach my $type (@PGparameters)
  my $oldAce = &makeAce();				# create ace entry with old values
  $joinkey = &getHtmlValuesFromForm('noprint'); 	# repopulate %theHash with good values, don't print to CGI again
  return $oldAce;
} # sub createOldAce

sub write {		# write to postgres (INSERT or UPDATE as required) and flatfile
  &readConvertions();
  &populateXref();
  open (OUT, ">>$data_file") or die "Cannot append to $data_file : $!";
  my $joinkey = &getHtmlValuesFromForm(); 		# populate %theHash and get joinkey
  my $found = &findIfPgEntry("$joinkey");		# if wbgene, check if already in Pg
  my $oldAce = '';
  if ($found) { $oldAce = &createOldAce($joinkey); }
  foreach my $type (sort keys %theHash) {
    my ($table, $order) = $type =~ m/^(.*?)(\d+)/;
    unless ($table) { 					# if not a multi-order type table
      unless ($theHash{$type}{value}) { next; } 	# skip if no data
      $table = $type; }					# assign table if some kind of value there
    $table = 'got_' . $table;
    unless ($theHash{$type}{value} eq '') {
      if ($theHash{$type}{value} eq 'NULL') {		# enter NULLs in postgres
        if ($order) {
          my $result2 = $conn->exec( "SELECT * FROM $table WHERE joinkey = '$joinkey' AND got_order = '$order' ORDER BY got_timestamp DESC;" );
          my @row2 = $result2->fetchrow;
          if ($row2[0]) { 				# data existed in that box
            if ($row2[2]) {	 			# was not null, now null, change
#               print "my \$result = \$conn->exec( \"INSERT INTO $table VALUES ('$joinkey', '$order', NULL);\" );<BR>\n"; 
              my $result = $conn->exec( "INSERT INTO $table VALUES ('$joinkey', '$order', NULL);" ); } }
        } else {
          my $result2 = $conn->exec( "SELECT * FROM $table WHERE joinkey = '$joinkey' ORDER BY got_timestamp DESC;" );
          my @row2 = $result2->fetchrow;
          if ($row2[0]) { 				# data existed in that box
            if ($row2[1]) {	 			# was not null, now null, change
#               print "my \$result = \$conn->exec( \"INSERT INTO $table VALUES ('$joinkey', NULL);\" );<BR>\n";
              my $result = $conn->exec( "INSERT INTO $table VALUES ('$joinkey', NULL);" ); } } }
      } else { # if ($theHash{$type}{value} eq 'NULL')	# enter values in postgres
        my $value = &filterForPostgres($theHash{$type}{value});
        if ($order) {
          my $result2 = $conn->exec( "SELECT * FROM $table WHERE joinkey = '$joinkey' AND got_order = '$order' ORDER BY got_timestamp DESC;" );
          my @row2 = $result2->fetchrow;
          if ($row2[0]) { 				# data existed in that box
              if ($row2[2]) { if ($row2[2] ne $value) { 	# is different, so change
#                 print "my \$result = \$conn->exec( \"INSERT INTO $table VALUES ('$joinkey', '$order', '$value');\" );<BR>\n";
                my $result = $conn->exec( "INSERT INTO $table VALUES ('$joinkey', '$order', '$value');" ); } } }
            else {					# no data previously in box, create
              print "my \$result = \$conn->exec( \"INSERT INTO $table VALUES ('$joinkey', '$order', '$value');\" );<BR>\n"; 
              my $result = $conn->exec( "INSERT INTO $table VALUES ('$joinkey', '$order', '$value');" ); }
        } else {
          my $result2 = $conn->exec( "SELECT * FROM $table WHERE joinkey = '$joinkey' ORDER BY got_timestamp DESC;" );
          my @row2 = $result2->fetchrow;
          if ($row2[0]) { 				# data existed in that box
              if ($row2[1]) { if ($row2[1] ne $value) { 	# is different, so change
                print "my \$result = \$conn->exec( \"INSERT INTO $table VALUES ('$joinkey', '$value');\" );<BR>\n";
                my $result = $conn->exec( "INSERT INTO $table VALUES ('$joinkey', '$value');" ); } } }
            else {					# no data previously in box, create
              print "my \$result = \$conn->exec( \"INSERT INTO $table VALUES ('$joinkey', '$value');\" );<BR>\n";
              my $result = $conn->exec( "INSERT INTO $table VALUES ('$joinkey', '$value');" ); }
        }
      } # else # if ($theHash{$type}{value} eq 'NULL')
      print OUT "$type\t$theHash{$type}{value}\n";
    } # unless ($theHash{$type}{value} eq '')
  } # foreach $_  (sort keys %theHash)

  my $date = &getDate();
  print "$date<BR><BR>\n\n";
#   print OUT "$date\n\n";
  close (OUT) or die "Cannot close $data_file : $!";

#   &outputPro();		# don't want this in this form (Ranjana) 2004 02 04
#   &outputAce($oldAce);	# don't need this anymore (Ranjana)  2006 02 28
#   &outputGo();
  print "<A HREF=http://tazendra.caltech.edu/~postgres/cgi-bin/go_curation.cgi>Go Back to the Beginning</A><BR>\n"; 

  my ($go_preview) = &get_go($joinkey);			# use go_curation_go perl module to preview the go output
  $go_preview =~ s/\n/<\/TD><\/TR>\n<TR><TD>/g;
  $go_preview =~ s/\t/<\/TD><TD>\n/g;
  print "<P><TABLE border=1><TR><TD COLSPAN=15>.go preview<\/TD><\/TR>\n<TR><TD>$go_preview<\/TD><\/TR><P>\n";
} # sub write

sub preview {		# preview page.  pass form with hidden values for all values of html.
  print "<FORM METHOD=\"POST\" ACTION=\"http://tazendra.caltech.edu/~postgres/cgi-bin/go_curation.cgi\">\n";
  print "<INPUT TYPE=\"HIDDEN\" NAME=\"max_columns\" VALUE=\"$max_columns\">\n";
  my $joinkey = &getHtmlValuesFromForm(); 		# populate %theHash and get joinkey

# I think &makeAce is not in sync with the current dumper, so I don't think it's
# dumping properly, so I'm commenting out the .ace section of the preview below.  2006 02 25
#   my $oldAce = '';
#   $oldAce = &createOldAce($joinkey); 
#   my $newAce = &makeAce();
#   $oldAce =~ s/\n/<BR>\n/g;
#   $newAce =~ s/\n/<BR>\n/g;
#   print "<P>OLD ACE $oldAce<BR>\n";
#   print "NEW ACE $newAce<BR>\n";

  &getCurator();					# get the curator from %theHash
  if ($joinkey eq 'NULL') { 				# if no wbgene, warn
    print "<FONT COLOR='blue'><B>ERROR : No wbgene chosen, go back and select one</B></FONT><BR>\n"; 
  } elsif ($curator eq 'NULL') {			# if no curator, warn
    print "<FONT COLOR='blue'><B>ERROR : No curator chosen, go back and select one</B></FONT><BR>\n"; 
  } elsif ( $error_in_data ) { 1; 			# error in data (currently curators in columns missing)
  } else {						# if wbgene, show ``New Entry !'' button
    my $found = &findIfPgEntry("$joinkey");		# if wbgene, check if already in Pg
    if ($found) {					# if already in pg, show ``Update !'' button
      print "<INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Update !\">\n";
    } else {						# if new, show ``New Entry !'' button
      print "<INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"New Entry !\">\n";
    } # else # if ($found)
  } # if ($joinkey eq 'NULL') 
  print "</FORM>";

} # sub preview

sub getHtmlValuesFromForm {	# read PGparameters value from html form, then display to html
  my $print_flag = shift;
  &readConvertions();
  &getPgGoTerms();					# from postgres tables updated twice a month
  my @allparameters = @PGparameters;
  foreach my $ontology (@ontology) {			# loop through each of three ontology types
    foreach my $column_type (@column_types) {
      for my $i (1 .. $max_columns) {			# loop through each column allowed
        my $field = $ontology . '_' . $column_type . $i;
        push @allparameters, $field } } }
  foreach my $type (@allparameters) {			# for all values for PG
    my $html_type = 'html_value_main_' . $type;
    my ($var, $val) = &getHtmlVar($query, $html_type);
    if ($val) { 					# if there is a value
      $theHash{$type}{value} = $val;			# put it in theHash for postgres (?)
      $theHash{$type}{html_value} = $val;		# put it in theHash for webpage
      $val = &filterToPrintHtml($val);			# filter Html to print it
      unless ($print_flag) {                            # print stuff unless repopulating hash after reading postgres for oldAce
        print "$type : $val";				# print it
        if ($type =~ m/paper_evidence/) {
          my @papers; my @wbpapers;			# split into separate paper links
          if ($val =~ m/, /) { @papers = split/, /, $val; } else { push @papers, $val; }
          foreach my $paper (@papers) {			# get convertion from Eimear's file  2004 09 27
            if ($paper =~ m/PMID:/) { $paper =~ s/PMID:/pmid/g; }
            if ($paper !~ m/WBPaper/) {
                if ($convertToWBPaper{$paper}) { 
                    $val = $convertToWBPaper{$paper};
                    push @wbpapers, $val; } 
                  else { $val = $paper; push @wbpapers, $val; } }
              else { $val = $paper; push @wbpapers, $val; }
            print " -- $paper is <A HREF=\"http://www.wormbase.org/db/misc/paper?name=$val;class=Paper\">$val</A>"; } 
          $val = join", ", @wbpapers;
        } # if ($type =~ m/paper_evidence/)		# link paper to WormBase
        print "<BR>\n"; }                               # print stuff unless repopulating hash after reading postgres for oldAce
#       unless ($print_flag) {				# print stuff unless repopulating hash after reading postgres for oldAce
#         print "$type : $val";	 			# print it
#         if ($type =~ m/paper_evidence/) { print "&nbsp;&nbsp;<A HREF=\"http://www.wormbase.org/db/misc/paper?name=%5B$val%5D;class=Paper\">Check WormBase</A>"; }	# link paper to WormBase
#         print "<BR>\n"; }				# print stuff unless repopulating hash after reading postgres for oldAce
      if ($type =~ m/goid/) {				# if it's a go id, check postgres 
        my @goTerms = $val =~ m/(\d+)/g;		# get the numbers
        foreach my $goTerm (@goTerms) {			# for each of those, find the matches and output
          $goTerm =~ s/^0+//g;				# take off leading zeroes
          if ($goTerm < 10) { $goTerm = '000000' . $goTerm; }	# and add appropriate number of zeroes
          elsif ($goTerm < 100) { $goTerm = '00000' . $goTerm; }
          elsif ($goTerm < 1000) { $goTerm = '0000' . $goTerm; }
          elsif ($goTerm < 10000) { $goTerm = '000' . $goTerm; }
          elsif ($goTerm < 100000) { $goTerm = '00' . $goTerm; }
          elsif ($goTerm < 1000000) { $goTerm = '0' . $goTerm; }
          $goTerm = 'GO:' . $goTerm;			# and add the GO: tag
          unless ($print_flag) {			# print stuff unless repopulating hash after reading postgres for oldAce
            if ($goTerm{$goTerm}) { print "$type : You've entered <FONT COLOR='green'>$goTerm</FONT> which corresponds to <FONT COLOR='green'>$goTerm{$goTerm}</FONT><BR>\n"; }		# print what's been chosen and what it is
              else { print "$type : You've entered <FONT COLOR='red'>$goTerm</FONT> which doesn't match anything in Postgres<BR>\n"; } }
        } # foreach my $goTerm (@goTerms)
      } # if ($type =~ m/goid/) 
      print "<INPUT TYPE=\"HIDDEN\" NAME=\"$html_type\" VALUE=\"$val\">\n";
    } else {						# if there is no value
      $theHash{$type}{value} = 'NULL';			# put NULL in theHash
      $theHash{$type}{html_value} = '';			# put blank in theHash for webpage
      print "<INPUT TYPE=\"HIDDEN\" NAME=\"$html_type\" VALUE=\"\">\n";
    } # else # if ($val) 
  } # foreach my $type (@allparameters) 

  foreach my $ontology (@ontology) {			# loop through each of three ontology types
    for my $i (1 .. $max_columns) {			# loop through each column allowed
      my $type = $ontology . '_' . 'goid' . $i;
      my $goid_value = $theHash{$type}{value};		# get goid value for that column
      if ($goid_value ne 'NULL') { 			# if it has data (a goid)
        $type = $ontology . '_' . 'curator_evidence' . $i;
        my $curator_evidence = $theHash{$type}{value};	# get the curator evidence for that column
        if ($curator_evidence eq 'NULL') { 		# if there isn't curator evidence
          $error_in_data++;				# flag it as bad data
          print "<FONT COLOR=red>ERROR : No curator evidence for GO ID $goid_value</FONT><BR>\n"; }	# show error message
  } } }

#   return $theHash{locus}{value};			# return the joinkey
  return $theHash{wbgene}{value};			# return the joinkey changed to wbgene for Kimberly 2005 10 14
} # sub getHtmlValuesFromForm

sub getPgGoTerms {
  my $result = $conn->exec( "SELECT * FROM got_goterm;" );
  while (my @row = $result->fetchrow) { $goTerm{$row[0]} = $row[1]; }
} # sub getPgGoTerms

sub getCurator {					# get the curator and convert for save file
  $curator = $theHash{curator}{value};			# get the curator
  if ($curator =~ m/Juancarlos/) { $curator = 'azurebrd'; }
  elsif ($curator =~ m/Carol/) { $curator = 'carol'; }
  elsif ($curator =~ m/Ranjana/) { $curator = 'ranjana'; }
  elsif ($curator =~ m/Kimberly/) { $curator = 'kimberly'; }
  elsif ($curator =~ m/Erich/) { $curator = 'erich'; } 
  elsif ($curator =~ m/Josh/) { $curator = 'josh'; } 
  else { 1; }
} # sub getCurator

sub findIfPgEntry {	# check postgres for wbgene entry already in
  my $joinkey = shift;
#   my $result = $conn->exec( "SELECT * FROM got_locus WHERE joinkey = '$joinkey';" );
  my $result = $conn->exec( "SELECT * FROM got_wbgene WHERE joinkey = '$joinkey';" );
  my @row; my $found;
  while (@row = $result->fetchrow) { $found = $row[1]; if ($found eq '') { $found = ' '; } }
    # if there's null or blank data, change it to a space so it will update, not insert
  return $found;
} # sub findIfPgEntry

sub filterForPostgres {	# filter values for postgres
  my $value = shift;
  $value =~ s/\'/\\\'/g;
  return $value;
} # sub filterForPostgres

# in Jex.pm
# sub filterToPrintHtml {	# filter values for printing html
#   my $val = shift;
#   $val =~ s/\&/&amp;/g;				# filter out ampersands first
#   $val =~ s/\"/&quot;/g;			# filter out double quotes
#   $val =~ s/\</&lt;/g;				# filter out open angle brackets
#   $val =~ s/\>/&gt;/g;				# filter out close angle brackets
#   return $val;
# } # sub filterToPrintHtml

#################  Action SECTION #################

#################  Formatting SECTION #################

sub dump {			# dump .ace file for citace upload
#   print "This takes a long time, please wait around 3 minutes for the link to show below.<BR>\n";
  `/home/postgres/work/get_stuff/for_ranjana/go_curation_dumper/go_curation_go_dumper.pl`;
#   `/home/postgres/work/citace_upload/concise/get_concise_to_ace.pl > /home/postgres/public_html/cgi-bin/data/concise_dump.ace`;
  print "<A HREF=http://tazendra.caltech.edu/~postgres/cgi-bin/data/go_curation.go.latest>Latest .go Dump</A><BR>\n";
} # sub dump

sub outputAce {			# don't need this anymore (Ranjana)  2006 02 28
  my ($oldAce) = @_;
  unless ($theHash{curator}{value}) { print "<FONT COLOR=red>ERROR No Curator Chosen.</FONT><BR>\n"; return; }
  else { 
    if ($theHash{curator}{value} =~ m/Ranjana/) { $ace_file = '/home/postgres/public_html/cgi-bin/data/go_ranjana.ace'; }
    elsif ($theHash{curator}{value} =~ m/Carol/) { $ace_file = '/home/postgres/public_html/cgi-bin/data/go_carol.ace'; }
    elsif ($theHash{curator}{value} =~ m/Kimberly/) { $ace_file = '/home/postgres/public_html/cgi-bin/data/go_kimberly.ace'; }
    elsif ($theHash{curator}{value} =~ m/Erich/) {$ace_file = '/home/postgres/public_html/cgi-bin/data/go_erich.ace'; }
    elsif ($theHash{curator}{value} =~ m/Juancarlos/) {$ace_file = '/home/postgres/public_html/cgi-bin/data/go_juancarlos.ace'; }
    else { print "<FONT COLOR=red>ERROR Not a valid Curator Chosen.</FONT><BR>\n"; return; }
  }

  my $ace_entry;
  my $newAce = &makeAce();
  unless ($oldAce) { $ace_entry = $newAce; }
    else { $ace_entry = &findDiff($oldAce, $newAce); }

  open (ACE, ">>$ace_file") or die "Cannot append to $ace_file : $!";
  print ACE $ace_entry;
  close (ACE) or die "Cannot close $ace_file : $!";

#   print "OLDACE $oldAce OLDACE<BR>\n";
#   print "NEWACE $newAce NEWACE<BR>\n";
#   print "ACEENT $ace_entry ACEENT<BR>\n";

  $ace_file =~ s/^.*public_html//g;
  print "See all ace.ace <A HREF=\"http://tazendra.caltech.edu/~postgres$ace_file\">data</A>.<BR>";
} # sub outputAce

sub findDiff {
  my $ace_entry;
  my %old_hash; my %new_hash;
  my $type = '';		# can only be CDS or Locus
  my ($oldAce, $newAce) = @_;
  my (@oldEntries) = split/\n\n/, $oldAce;
  foreach my $oldEnt (@oldEntries) { 
    if ($oldEnt =~ m/Locus : \"([^\"]+)\"/) { $old_hash{$1} = $oldEnt; $type = 'Locus'; }
    if ($oldEnt =~ m/Gene : \"([^\"]+)\"/) { $old_hash{$1} = $oldEnt; $type = 'Gene'; }
    if ($oldEnt =~ m/CDS : \"([^\"]+)\"/) { $old_hash{$1} = $oldEnt; $type = 'CDS'; } }
  my (@newEntries) = split/\n\n/, $newAce;
  foreach my $newEnt (@newEntries) { 
    if ($newEnt =~ m/Locus : \"([^\"]+)\"/) { $new_hash{$1} = $newEnt; }
    if ($newEnt =~ m/Gene : \"([^\"]+)\"/) { $new_hash{$1} = $newEnt; }
    if ($newEnt =~ m/CDS : \"([^\"]+)\"/) { $new_hash{$1} = $newEnt; } }

  foreach my $new_entry (sort {$a <=> $b} keys %new_hash) {
    unless ($old_hash{$new_entry}) { $ace_entry .= "$new_hash{$new_entry}"; next; }
#     unless ($new_hash{$new_entry} eq $old_hash{$new_entry}) {  
#       my %cit_lines; my %pg_lines;
#       my $lines_to_print = '';
#       my @cit_lines = split/\n/, $old_hash{$new_entry};
#       my @pg_lines = split/\n/, $new_hash{$new_entry};
#       foreach (@cit_lines) { $cit_lines{$_}++; }
#       foreach (@pg_lines) { $pg_lines{$_}++; }
#       foreach my $pg_line (sort keys %pg_lines) { if ($cit_lines{$pg_line}) { delete $pg_lines{$pg_line}; delete $cit_lines{$pg_line}; } }
#       foreach my $cit_line (sort keys %cit_lines) { $lines_to_print .= "-D $cit_line\n"; }
#       foreach my $pg_line (sort keys %pg_lines) { $lines_to_print .= "$pg_line\n"; }
#       if ($lines_to_print) { $ace_entry .= "$type : \"$new_entry\"\n$lines_to_print\n"; }
#     }
    unless ($new_hash{$new_entry} eq $old_hash{$new_entry}) {  $ace_entry = &checkLines($ace_entry, $type, $new_entry, \%old_hash, \%new_hash); }
  } # foreach my $new_entry (sort keys %new_hash)
  return $ace_entry;
} # sub findDiff

sub checkLines {
  my ($ace_entry, $type, $num, $old_hash_ref, $new_hash_ref) = @_;
  my %cit_lines; my %pg_lines;
  my $lines_to_print = '';
  my @cit_lines = split/\n/, $$old_hash_ref{$num};	# dereference hash ref
  my @pg_lines = split/\n/, $$new_hash_ref{$num};	# dereference hash ref
  foreach (@cit_lines) { $cit_lines{$_}++; }
  foreach (@pg_lines) { $pg_lines{$_}++; }
  foreach my $pg_line (sort keys %pg_lines) { if ($cit_lines{$pg_line}) { delete $pg_lines{$pg_line}; delete $cit_lines{$pg_line}; } }
#   foreach my $cit_line (sort keys %cit_lines) { $lines_to_print .= "-D $cit_line\n"; }
#   foreach my $pg_line (sort keys %pg_lines) { $lines_to_print .= "$pg_line\n"; }
#   if ($lines_to_print) { $ace_entry .= "$type : \"$num\"\n$lines_to_print\n"; }
    # Changed to create .ace entry for each change instead of multiple -D and entries in single .ace entry for Ranjana / Raymond  2004 09 28
  foreach my $cit_line (sort keys %cit_lines) { $ace_entry .= "$type : \"$num\"\n-D $cit_line\n\n"; }
  foreach my $pg_line (sort keys %pg_lines) { $ace_entry .= "$type : \"$num\"\n$pg_line\n\n"; }
  return $ace_entry;
} # sub checkLines

sub makeAce {
  unless ($theHash{sequence}{value}) {             # no sequences, say so
    print "<FONT COLOR='red'>WARNING : no sequence for $theHash{locus}{value}</FONT><BR>\n";
  } else { # unless ($theHash{sequence})    # if sequence, then
    my $ace_entry = '';                                 # initialize entry
    for my $ontology (@ontology) {                      # for each of the three ontologies
      for my $i (1 .. $max_columns) {                              # for each of the three possible entries
        my $goid_tag = $ontology . '_goid' . $i;
        if ($theHash{$goid_tag}{value} ne 'NULL') {
          my $goid = $theHash{$goid_tag}{value};
          $goid =~ s/^\s+//g; $goid =~ s/\s+$//g;
# print "GOID $goid GOID<BR>\n";

          my @evidence_tags = qw( _goinference _goinference_two );      # the inference types
          foreach my $ev_tag (@evidence_tags) {                 # for each of the inference types
            my $evidence_tag = $ontology . $ev_tag . $i;        # get evidence tag
            if ( ($theHash{$evidence_tag}{value} ne 'NULL')  && ($theHash{$evidence_tag}{value} ne '') ) {
              my $inference = $theHash{$evidence_tag}{value};   # the inference type
              $inference =~ s/ --.*$//g;
# print "INF $inference INF<BR>\n";
              my $tag = $ontology . '_paper_evidence' . $i;
              my $db_reference = '';				# paper id number
              if ( ($theHash{$tag}{value} ne 'NULL') && ($theHash{$tag}{value} ne '') ) {
# print "TAG $tag VALUE -=$theHash{$tag}{value}=-<BR>\n"; 
                if ($theHash{$tag}{value} !~ m/, /) {		# and it's just one paper, print it
                  $db_reference = $theHash{$tag}{value};
# these numbers no longer imply pmid with wbpaper entries
#                   my ($number) = $db_reference =~ m/(\d+)/;
#                   if ($number > 10000) {
#                     my $key = 'pmid' . $number;
#                     $db_reference = $pmHash{$key};
#                   }
#                   $ace_entry .= "GO_term\t\"$goid\"\t\"$inference\"\tPaper_evidence\t\"[$db_reference]\"\n";
                  if ($db_reference =~ m/WBPaper/) {
# print "1GO_term\t\"$goid\"\t\"$inference\"\tPaper_evidence\t\"$db_reference\"<BR>\n"; 
                    $ace_entry .= "GO_term\t\"$goid\"\t\"$inference\"\tPaper_evidence\t\"$db_reference\"\n"; }
                  elsif ($convertToWBPaper{$db_reference}) {
# print "2GO_term\t\"$goid\"\t\"$inference\"\tPaper_evidence\t\"$convertToWBPaper{$db_reference}\"<BR>\n"; 
                    $ace_entry .= "GO_term\t\"$goid\"\t\"$inference\"\tPaper_evidence\t\"$convertToWBPaper{$db_reference}\"\n"; }
                  else { print STDERR "NO Convertion for $db_reference\n"; }
                } else { 					# if it's multiple papers
                  my @papers = split /, /, $theHash{$tag}{value};
                  foreach my $paper (@papers) {			# print separate papers
                      $db_reference = $paper;
                      my ($number) = $db_reference =~ m/(\d+)/;
                      if ($number > 10000) {
                        my $key = 'pmid' . $number;
			if ($pmHash{$key}) { $db_reference = $pmHash{$key}; }	# if there's a cgc, write cgc else leave the same
                      }
	              $db_reference =~ s/\[//g;		# take out brackets so that they are not entered twice
	              $db_reference =~ s/\]//g;		# take out brackets so that they are not entered twice
#                       $ace_entry .= "GO_term\t\"$goid\"\t\"$inference\"\tPaper_evidence\t\"[$db_reference]\"\n";
                      if ($db_reference =~ m/WBPaper/) {
# print "3GO_term\t\"$goid\"\t\"$inference\"\tPaper_evidence\t\"$db_reference\"<BR>\n"; 
                        $ace_entry .= "GO_term\t\"$goid\"\t\"$inference\"\tPaper_evidence\t\"$db_reference\"\n"; }
                      elsif ($convertToWBPaper{$db_reference}) {
# print "4GO_term\t\"$goid\"\t\"$inference\"\tPaper_evidence\t\"$convertToWBPaper{$db_reference}\"<BR>\n"; 
                        $ace_entry .= "GO_term\t\"$goid\"\t\"$inference\"\tPaper_evidence\t\"$convertToWBPaper{$db_reference}\"\n"; }
                      else { print STDERR "NO Convertion for $db_reference\n"; }
                  } # foreach my $paper (@papers)
                } # else # if ($theHash{$tag}{value} !~ m/ ,/)
              } # if ($theHash{$tag}{value})

# FIX THIS NEED TO ADD CURATOR EVIDENCE
    
              $tag = $ontology . '_person_evidence' . $i;
              if ( ($theHash{$tag}{value} ne 'NULL') && ($theHash{$tag}{value} ne '') ) {
# print "TAG2 VALUE -=$theHash{$tag}{value}=-<BR>\n"; 
                if ($theHash{$tag}{value} =~ m/ishore/) {
                  $ace_entry .= "GO_term\t\"$goid\"\t\"$inference\"\tPerson_evidence\t\"WBPerson324\"\n";
                } elsif ($theHash{$tag}{value} =~ m/chwarz/) {
                  $ace_entry .= "GO_term\t\"$goid\"\t\"$inference\"\tPerson_evidence\t\"WBPerson567\"\n";
                } else {
                  $ace_entry .= "GO_term\t\"$goid\"\t\"$inference\"\tPerson_evidence\t\"$theHash{$tag}{value}\"\n";
                }
              } # if ($theHash{$tag}{value})
    
# deleted 2004 11 18 since not in form
#               $tag = $ontology . '_similarity' . $i;
#               if ( ($theHash{$tag}{value} ne 'NULL') && ($theHash{$tag}{value} ne '') ) {
# # print "TAG3 VALUE -=$theHash{$tag}{value}=-<BR>\n"; 
#                 $ace_entry .= "GO_term\t\"$goid\"\t\"$inference\"\tProtein_id_evidence\t\"$theHash{$tag}{value}\"\n";
#               } # if ($theHash{$tag}{value})

            } # if ($theHash{$evidence_tag}{value})
          } # foreach my $ev_tag (@evidence_tags) 
        } # if ($theHash{$goid_tag}{value} ne 'NULL')
      } # for my $i (1 .. $max_columns)
    } # for my $ontology (@ontology)
    $ace_entry .= "\n";                                 # add separator
# print "ACE ENT $ace_entry<BR><BR>\n";

    if ($theHash{wbgene}{value} =~ m/WBGene\d{8}/) {		# if wbgene entry, use the WBGene
      $ace_entry = "Gene : \"$theHash{wbgene}{value}\"\n$ace_entry"; }
    elsif ($theHash{sequence}{value} eq 'no') {		# if no entry, use the Gene (locus)
#       print ACE "Locus : \"$theHash{locus}{value}\"\n";
      $ace_entry = "Locus : \"$theHash{locus}{value}\"\n$ace_entry";
#       print ACE $ace_entry;
    } else { # if ($theHash{sequence}{value})		# if there's a sequence
      if ($theHash{sequence}{value} !~ m/[ ,]/) {	# and it's just one sequence, print it
#         print ACE "CDS : \"$theHash{sequence}{value}\"\n";	# changed Sequence to CDS
        $ace_entry = "CDS : \"$theHash{sequence}{value}\"\n$ace_entry";		# changed Sequence to CDS
#         print ACE $ace_entry;
      } else { # if ($theHash{sequence}{value} !~ m/[ ,]/)	# if it's many sequences, print for each
        my @sequences = split /, /, $theHash{sequence}{value};
        my $temp_entry = '';
        foreach my $seq (@sequences) {                  # print separate sequences
          $temp_entry .= "CDS : \"$seq\"\n$ace_entry";	# changed Sequence to CDS
#           print ACE "CDS : \"$seq\"\n";
#           print ACE $ace_entry;
        } # foreach my $seq (@sequences)
        $ace_entry = $temp_entry;
      } # else # if ($theHash{sequence}{value} !~ m/[ ,]/)
    } # else # if ($theHash{sequence}{value})
    return $ace_entry;
  } # else # unless ($theHash{sequence}{value})
} # sub makeAce


sub populateXref {              # if not found, get ref_xref data to try to find alternate
  my $result = $conn->exec( "SELECT * FROM ref_xref;" );
  while (my @row = $result->fetchrow) { # loop through all rows returned
    $cgcHash{$row[0]} = $row[1];        # hash of cgcs, values pmids
    $pmHash{$row[1]} = $row[0];         # hash of pmids, values cgcs
  } # while (my @row = $result->fetchrow)
} # sub populateXref

sub readConvertions {
  my $u = "http://tazendra.caltech.edu/~acedb/paper2wbpaper.txt";
  my $ua = LWP::UserAgent->new(timeout => 30); #instantiates a new user agent
  my $request = HTTP::Request->new(GET => $u); #grabs url
  my $response = $ua->request($request);       #checks url, dies if not valid.
  die "Error while getting ", $response->request->uri," -- ", $response->status_line, "\nAborting" unless $response-> is_success;
  my @tmp = split /\n/, $response->content;    #splits by line
  foreach (@tmp) {
    if ($_ =~m/^(.*?)\t(.*?)$/) {
      $convertToWBPaper{$1} = $2; } }
} # sub readConvertions


#################  Formatting SECTION #################

#################  HTML SECTION #################

sub printHtmlForm {	# Show the form 
  &printHtmlFormStart();
  &printHtmlSection('GO_annotation');
#   &printHtmlSelectCurators('curator');		# print html select blocks for curators # moved curators to columns 2006 02 25
  &printHtmlInputQuery('wbgene');        	# input with Query button
  &printHtmlInputQuery('locus');        	# input with Query button
  &printHtmlInput('sequence');        	
  &printHtmlInput('synonym');        
#   &printHtmlInput('wbgene');        
#   &printHtmlTextarea('sequence');
  &printHtmlTextarea('protein');
#   &printHtmlSelectType('dbtype');        	# not main in new form 2004 08 11
  &printHtmlSection('Biological Process');
  &printHtmlTextareaBlock('bio_goterm');
  &printHtmlTextareaBlock('bio_goid');
  &printHtmlTextareaBlock('bio_paper_evidence');
  &printHtmlTextareaBlock('bio_person_evidence');
  &printHtmlSelectBlock('bio_curator_evidence');
  &printHtmlSelectBlock('bio_goinference');
  &printHtmlSelectBlock('bio_dbtype');
  &printHtmlTextareaBlock('bio_with');
  &printHtmlSelectQualifierBlock('bio_qualifier');
  &printHtmlSelectBlock('bio_goinference_two');
  &printHtmlSelectBlock('bio_dbtype_two');
  &printHtmlTextareaBlock('bio_with_two');
  &printHtmlSelectQualifierBlock('bio_qualifier_two');
  &printHtmlTextareaBlock('bio_comment');
  &printHtmlTextareaBlock('bio_lastupdate');
  &printHtmlSection('Cellular Component');
  &printHtmlTextareaBlock('cell_goterm');
  &printHtmlTextareaBlock('cell_goid');
  &printHtmlTextareaBlock('cell_paper_evidence');
  &printHtmlTextareaBlock('cell_person_evidence');
  &printHtmlSelectBlock('cell_curator_evidence');
  &printHtmlSelectBlock('cell_goinference');
  &printHtmlSelectBlock('cell_dbtype');
  &printHtmlTextareaBlock('cell_with');
  &printHtmlSelectQualifierBlock('cell_qualifier');
  &printHtmlSelectBlock('cell_goinference_two');
  &printHtmlSelectBlock('cell_dbtype_two');
  &printHtmlTextareaBlock('cell_with_two');
  &printHtmlSelectQualifierBlock('cell_qualifier_two');
  &printHtmlTextareaBlock('cell_comment');
  &printHtmlTextareaBlock('cell_lastupdate');
  &printHtmlSection('Molecular Function');
  &printHtmlTextareaBlock('mol_goterm');
  &printHtmlTextareaBlock('mol_goid');
  &printHtmlTextareaBlock('mol_paper_evidence');
  &printHtmlTextareaBlock('mol_person_evidence');
  &printHtmlSelectBlock('mol_curator_evidence');
  &printHtmlSelectBlock('mol_goinference');
  &printHtmlSelectBlock('mol_dbtype');
  &printHtmlTextareaBlock('mol_with');
  &printHtmlSelectQualifierBlock('mol_qualifier');
  &printHtmlSelectBlock('mol_goinference_two');
  &printHtmlSelectBlock('mol_dbtype_two');
  &printHtmlTextareaBlock('mol_with_two');
  &printHtmlSelectQualifierBlock('mol_qualifier_two');
  &printHtmlTextareaBlock('mol_comment');
  &printHtmlTextareaBlock('mol_lastupdate');
  &printHtmlFormEnd();
} # sub printHtmlForm

sub printHtmlSection {          # print html sections
  my $text = shift;             # get name of section
  print "\n  "; for (0..12) { print '<TR></TR>'; } print "\n\n";                # divider
  print "  <TR><TD><STRONG><FONT SIZE=+1>$text : </FONT></STRONG></TD></TR>\n"; # section
} # sub printHtmlSection

sub printHtmlInputQuery {       # print html inputs with queries (just pubID)
  my $type = shift;             # get type, use hash for html parts
  print <<"  EndOfText";
  <TR>
    <TD ALIGN="right"><STRONG>$theHash{$type}{html_field_name} : </STRONG></TD>
    <TD><INPUT NAME="html_value_main_$type" VALUE="$theHash{$type}{html_value}"  
         SIZE=$theHash{$type}{html_size_main}></TD>
    <TD ALIGN="left"><!--<INPUT TYPE="submit" NAME="action" VALUE="Query Sanger !"><BR>-->
                     <INPUT TYPE="submit" NAME="action" VALUE="Query $type !"></TD>
  </TR> 
  EndOfText
} # sub printHtmlInputQuery

sub printHtmlInput {            # print html inputs
  my $type = shift;             # get type, use hash for html parts
  print <<"  EndOfText";
  <TR>
    <TD ALIGN="right"><STRONG>$theHash{$type}{html_field_name} : </STRONG></TD>
    <TD><INPUT NAME="html_value_main_$type" VALUE="$theHash{$type}{html_value}"  
         SIZE=$theHash{$type}{html_size_main}></TD>
  </TR>
  EndOfText
} # sub printHtmlInput

sub printHtmlTextarea {         # print html textareas
  my $type = shift;             # get type, use hash for html parts
  print <<"  EndOfText";
  <TR>
    <TD ALIGN="right"><STRONG>$theHash{$type}{html_field_name} :</STRONG></TD>
    <TD><TEXTAREA NAME="html_value_main_$type" ROWS=$theHash{$type}{html_size_minor}
                  COLS=$theHash{$type}{html_size_main}>$theHash{$type}{html_value}</TEXTAREA></TD>
  </TR>
  EndOfText
} # sub printHtmlTextarea

sub printHtmlTextareaBlock {	# print html textarea blocks (sets of three)
				# e.g. : &printHtmlTextareaBlock('bio_goterm');
  my $main_type = shift;	# get type, use hash for html parts
  print <<"  EndOfText";
  <TR>
    <TD ALIGN="right"><STRONG>$theHash{$main_type}{html_field_name} :</STRONG></TD>
  EndOfText
  for my $i (1 .. $max_columns) {
    my $type = $main_type . $i;
    print"    <TD><TEXTAREA NAME=\"html_value_main_$type\" ROWS=$theHash{$type}{html_size_minor}
                  COLS=$theHash{$type}{html_size_main}>$theHash{$type}{html_value}</TEXTAREA></TD>\n";
  } # for my $i (1 .. $max_columns)
  print <<"  EndOfText";
  </TR>
  EndOfText
} # sub printHtmlTextareaBlock 

sub printHtmlSelectCurators {	# print html select blocks for curators	# no longer using this 2006 02 25
  my $type = shift;
  my @curators = ('Carol Bastiani', 'Josh Jaffery', 'Ranjana Kishore', 'Erich Schwarz', 'Kimberly Van Auken', 'Juancarlos Testing');
  print <<"  EndOfText";
  <TR>
    <TD ALIGN="right"><STRONG>$theHash{$type}{html_field_name} :</STRONG></TD>
  EndOfText
  print "    <TD><SELECT NAME=\"html_value_main_$type\" SIZE=1>\n";
  print "      <OPTION selected>$theHash{$type}{html_value}</OPTION>\n";
    # if loaded or queried, show option, otherwise default to '' option
  foreach (@curators) { print "      <OPTION>$_</OPTION>\n"; }
  print "    </SELECT></TD>\n  </TR>\n";
} # sub printHtmlSelectCurators

sub printHtmlSelectType {	# print html select blocks for curators
  my $type = shift;
  my @types = ('', 'protein', 'gene', 'transcript', 'complex', 'protein_structure');
  my ($var, $action) = &getHtmlVar($query, 'action');
    # first time or query sanger, no action, protein
  if ( ($action eq '') || ($action eq 'Query Sanger !') ) { $theHash{$type}{html_value} = 'protein'; }	
  print <<"  EndOfText";
  <TR>
    <TD ALIGN="right"><STRONG>$theHash{$type}{html_field_name} :</STRONG></TD>
  EndOfText
  print "    <TD><SELECT NAME=\"html_value_main_$type\" SIZE=1>\n";
  print "      <OPTION selected>$theHash{$type}{html_value}</OPTION>\n";
    # if loaded or queried, show option, otherwise default to '' option
  foreach (@types) { print "      <OPTION>$_</OPTION>\n"; }
  print "    </SELECT></TD>\n  </TR>\n";
} # sub printHtmlSelectType

sub printHtmlSelectBlock {	# print html select blocks for inference type (set of three)
				# e.g. : &printHtmlSelectBlock('bio_goinference');
  my $main_type = shift;
  print <<"  EndOfText";
  <TR>
    <TD ALIGN="right"><STRONG>$theHash{$main_type}{html_field_name} :</STRONG></TD>
  EndOfText
  for my $i (1 .. $max_columns) {
    my $type = $main_type . $i;
#     my @inferences = (' ', 'IDA -- Inferred from Direct Assay','IEA -- Inferred from Electronic
# Annotation','IEP -- Inferred from Expression Pattern','IGI -- Inferred from Genetic
# Interaction','IMP -- Inferred from Mutant Phenotype','IPI -- Inferred from Physical
# Interaction','ISS -- Inferred from Sequence or structural Similarity','NAS -- Non-traceable Author
# Statement','ND -- No Biological Data Available','IC -- Inferred by Curator','TAS -- Traceable Author
# Statement');
    my @choices = ();
    if ($main_type =~ m/inference/) { @choices = (' ', 'IDA','IEA','IEP','IGI','IMP','IPI','ISS','NAS','ND','IC','TAS', 'RCA'); }
    elsif ($main_type =~ m/dbtype/) { @choices = ('', 'protein', 'gene', 'transcript', 'complex', 'protein_structure'); }
    elsif ($main_type =~ m/curator_evidence/) { @choices = ('', 'Carol Bastiani', 'Josh Jaffery', 'Ranjana Kishore', 'Raymond Lee', 'Erich Schwarz', 'Kimberly Van Auken', 'Juancarlos Testing'); }
    else { @choices = ('not a valid choice type in printHtmlSelectBlock $main_type' ); }
#     my @inferences = (' ', 'IDA','IEA','IEP','IGI','IMP','IPI','ISS','NAS','ND','IC','TAS');
    print "    <TD><SELECT NAME=\"html_value_main_$type\" SIZE=1>\n";
    print "      <OPTION selected>$theHash{$type}{html_value}</OPTION>\n";
      # if loaded or queried, show option, otherwise default to '' option
    foreach (@choices) { print "      <OPTION>$_</OPTION>\n"; }
    print "    </SELECT></TD>\n";
  } # for my $i (1 .. $max_columns)
  print <<"  EndOfText";
  </TR>
  EndOfText
} # sub printHtmlSelectBlock

sub printHtmlSelectQualifierBlock {	# print html select blocks for inference type (set of three)
					# e.g. : &printHtmlQualifierBlock('bio_goinference');
  my $main_type = shift;
  print <<"  EndOfText";
  <TR>
    <TD ALIGN="right"><STRONG>$theHash{$main_type}{html_field_name} :</STRONG></TD>
  EndOfText
  for my $i (1 .. $max_columns) {
    my $type = $main_type . $i;
    my @qualifiers = (' ', 'NOT', 'contributes_to', 'colocalizes_with');	# added colocalizes_with for kimberly 2004 08 24
    print "    <TD><SELECT NAME=\"html_value_main_$type\" SIZE=1>\n";
    print "      <OPTION selected>$theHash{$type}{html_value}</OPTION>\n";
      # if loaded or queried, show option, otherwise default to '' option
    foreach (@qualifiers) { print "      <OPTION>$_</OPTION>\n"; }
    print "    </SELECT></TD>\n";
  } # for my $i (1 .. $max_columns)
  print <<"  EndOfText";
  </TR>
  EndOfText
} # sub printHtmlQualifierBlock

sub printHtmlFormStart {        # beginning of form
  print <<"  EndOfText";
  <A NAME="form"><H1>Add your entries : </H1></A>
  <FORM METHOD="POST" ACTION="http://tazendra.caltech.edu/~postgres/cgi-bin/go_curation.cgi">
  <INPUT TYPE="HIDDEN" NAME="max_columns" VALUE="$max_columns">
  <TABLE>
  <TR>
    <TD> </TD>
    <TD><INPUT TYPE="submit" NAME="action" VALUE="Preview !">
        <!--<INPUT TYPE="submit" NAME="action" VALUE="Options !">--><BR>
        <INPUT TYPE="submit" NAME="action" VALUE="Add Column !"><BR>
<!--        <INPUT TYPE="submit" NAME="action" VALUE="Dump .go !"><BR> shouldn't have been using this for a while  2006 08 01-->
<!--        <INPUT TYPE="submit" NAME="action" VALUE="Save !">
        <INPUT TYPE="submit" NAME="action" VALUE="Load !"><BR> no longer using this 2006 02 27-->
        <INPUT TYPE="submit" NAME="action" VALUE="Reset !"></TD>
  </TR>
  <TR>
    <TD> </TD>
    <TD><A HREF=http://tazendra.caltech.edu/~postgres/cgi-bin/data/go_curation.go.latest>Latest .go Dump</A></TD></TR>
  EndOfText
} # sub printHtmlFormStart

sub printHtmlFormEnd {          # ending of form
  print <<"  EndOfText";
  <TR><TD COLSPAN=2> </TD></TR>
  <TR>
    <TD> </TD>
    <TD><INPUT TYPE="submit" NAME="action" VALUE="Preview !">
        <!--<INPUT TYPE="submit" NAME="action" VALUE="Options !">--><BR>
        <INPUT TYPE="submit" NAME="action" VALUE="Add Column !"><BR>
<!--        <INPUT TYPE="submit" NAME="action" VALUE="Dump .go !"><BR> shouldn't have been using this for a while  2006 08 01-->
<!--        <INPUT TYPE="submit" NAME="action" VALUE="Save !">
        <INPUT TYPE="submit" NAME="action" VALUE="Load !"><BR> no longer using this 2006 02 27-->
        <INPUT TYPE="submit" NAME="action" VALUE="Reset !"></TD>
  </TR>
  <TR>
    <TD> </TD>
    <TD><A HREF=http://tazendra.caltech.edu/~postgres/cgi-bin/data/go_curation.go.latest>Latest .go Dump</A></TD></TR>
  </TABLE>
  </FORM>
  EndOfText
} # sub printHtmlFormEnd

#################  HTML SECTION #################

#################  HASH SECTION #################

sub initializeHash {
  # initialize the html field name, mailing codes, html mailing addresses, and mailing subjects.
  # in case of new fields, add to @PGparameters array and create html_field_name entry in %theHash
  # and other %theHash fields as necessary.  if new email address, add to %emails.

  my ($var, $val) = &getHtmlVar($query, 'max_columns');
  if ($val) { $max_columns = $val; }
  else { $max_columns = 3; }

#   @PGparameters = qw(curator locus sequence synonym protein wbgene);
  @PGparameters = qw(locus sequence synonym protein wbgene);
  foreach my $ontology (@ontology) {		# loop through each of three ontology types
    for my $i (1 .. $max_columns) {		# loop through each column allowed
      my $field = $ontology . '_' . $i;
      $theHash{$field}{html_field_name} = '';
      $theHash{$field}{html_value} = '';
      $theHash{$field}{html_size_main} = '20';            # default width 40
      $theHash{$field}{html_size_minor} = '2';            # default height 2
    }
    $theHash{"${ontology}_goterm"}{html_field_name} = 'GO Term';
    $theHash{"${ontology}_goid"}{html_field_name} = 'GO ID';
    $theHash{"${ontology}_paper_evidence"}{html_field_name} = 'Paper Evidence<BR>(check it exists in <A HREF="http://www.wormbase.org/db/misc/paper?name=;class=Paper">WormBase</A>)';
    $theHash{"${ontology}_person_evidence"}{html_field_name} = 'Person Evidence';
    $theHash{"${ontology}_curator_evidence"}{html_field_name} = 'Curator Evidence';
    $theHash{"${ontology}_goinference"}{html_field_name} = 'GO Evidence 1';
    $theHash{"${ontology}_dbtype"}{html_field_name} = 'DB_Object_Type 1';
    $theHash{"${ontology}_with"}{html_field_name} = 'with 1';
    $theHash{"${ontology}_qualifier"}{html_field_name} = 'Qualifier 1';
    $theHash{"${ontology}_goinference_two"}{html_field_name} = 'GO Evidence 2';
    $theHash{"${ontology}_dbtype_two"}{html_field_name} = 'DB_Object_Type 2';
    $theHash{"${ontology}_with_two"}{html_field_name} = 'with 2';
    $theHash{"${ontology}_qualifier_two"}{html_field_name} = 'Qualifier 2';
#     $theHash{"${ontology}_similarity"}{html_field_name} = 'Protein ID Evidence';
    $theHash{"${ontology}_comment"}{html_field_name} = 'Comment';
    $theHash{"${ontology}_lastupdate"}{html_field_name} = 'Timestamp Column Last Updated<BR>e.g. ``2006-11-01 16:05:42\'\'';
  } # foreach my $ontology (@ontology)


  foreach my $field (@PGparameters) {
    $theHash{$field}{html_field_name} = '';
    $theHash{$field}{html_value} = '';
    $theHash{$field}{html_size_main} = '20';            # default width 40
    $theHash{$field}{html_size_minor} = '2';            # default height 2
  } # foreach my $field (@PGparameters)

  $theHash{curator}{html_field_name} = 'Curator';
  $theHash{locus}{html_field_name} = 'Locus';
  $theHash{sequence}{html_field_name} = 'Sequence';
  $theHash{synonym}{html_field_name} = 'Synonym';
  $theHash{wbgene}{html_field_name} = 'WBGene';
  $theHash{protein}{html_field_name} = 'Gene Product (Protein)';
#   $theHash{dbtype}{html_field_name} = 'DB_Object_Type';

} # sub initializeHash

#################  HASH SECTION #################


