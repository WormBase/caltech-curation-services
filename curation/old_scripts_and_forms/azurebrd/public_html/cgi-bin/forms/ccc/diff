35,36c35
< # TODO :
< # get ptgo curator IDs to set to notSent and work out that notSent code
---
> # use Net::Domain to get the hostname to determine whether to use ptgo server as 'test' or 'production'.  2013 11 25
39,40d37
< # NEED : gene-synonym to ID mapping file + pipeline
< 
63,64d59
< 
< 
89c84
< # show GO term (list of gene_comp_go mappings)
---
> # show GO term (list from component_go_index mappings)
102a98
> # almost done.  2013 11 14
105,153d100
< # Read sentences from flatfile.  By default look at last sentence (joinkey)
< # entered in ggi_gene_gene_interaction, and read the next sentence.  Either :
< # click on no genes and (No_interaction / Possible_genetic / Possible_non-genetic)
< # or click on two genes and click on any other option.  Go back and reselect
< # options to enter more than 3 connections / sentence. 
< # New option to dump out last 10 sentences with connections.
< # New option to search by sentence number.  2006 03 14
< #
< # Adapting for ccc go curation from gene_gene_inteaction.cgi  2007 03 15
< #
< # Created &addToGo($gene, $paps, $goterm); to add positive data to the GO
< # curation got_ tables.  If an entry already exists, enter data, otherwise make
< # a link to the go curation form to create the entry (for synonym data and so
< # forth).  2007 04 27
< #
< # Added option of different source files, recreated the ccc_gene_comp_go table
< # to allow a ccc_source_file column.  Made a symlink to the directory with the
< # source files to make an html link to them in the form.  Will set up a script
< # to redo this every week.  2007 07 18
< #
< # Set src_file_name on options as default value in case it's been changed.
< # 2007 08 01
< # 
< # Fixed showing sentence, which wasn't working from an extra column in the file
< # data.  
< # Sorting by paper -> sentence -> score, instead of paper -> score -> sentence
< # Added a checkbox for ``add to go form data'', and only do &addToGo($gene, $paps,
< # $goterm); if the checkbox is checked on.  (for those sentences and not all the
< # other ones).
< # For Kimberly.  2008 03 07
< #
< # Added search of paper in source files for Kimberly.  2008 04 10
< #
< # Broke up sentences to have their own radio buttons for ``goterm''
< # curate_radio, instead of separate buttons for those choices, since each
< # sentence needed its own.  2008 04 14
< #
< # Changed to work with phenote tables.  2008 07 30
< #
< # Read data from /home2/postgres/work/pgpopulation/ccc_gocuration/sentences/
< # since the files were taking up too much space. 
< # Read in bad proteins and bad components, excluded from already being annotated.
< # 2009 05 25
< #
< # Was adding $src_file_name instead of $ccc_src_file to ccc_gene_comp_go
< # ccc_source_file column.
< # Was adding marked up link to wormbase dev into ccc_gene_comp_go
< # ccc_paper_sentence column.  2010 02 14
< 
156,168d102
< # yuling file :
< # SSC:29	PMID:23594951:introduction:67	CDC-42|LGL-1|PAR-1|PAR-2|PAR-3|PAR-6|PKC-3	Boundary|Cytosol|Plasma membrane|cortex|membrane	All rights reserved Molecular Cell Biology 0 1 1 <localization_cell_components_2011-02-11>Boundary</localization_cell_components_2011-02-11> 0 aPARs : <protein_celegans>PAR-3</protein_celegans> 
< # 
< # 
< # take col3 to get list of genes for col1 of form :
< #   gpi file :
< # WBGene00000390	cdc-42	R07G3.1|WP:CE02020	gene	taxon:6239	WB:WBGene00000390	CCD:CCD70511|UniProtKB:Q05062
< #   get :
< # CCD:CCD70511|UniProtKB:Q05062
< #   map this into column 1 of form (yuling, col1, col8 uniprot part)
< # CDC-42:WBGene00000390:UniProtKB:Q05062
< # 
< # take col4 as list of component terms, and map them to existing annotations to goterms, from pg ccc_component_go_index 
179a114,115
> use Net::Domain qw(hostname hostfqdn hostdomain);	# only using hostname
> 
206a143,145
> my $server_hostname = hostname(); my $ptgoServer = 'test';
> if ($server_hostname eq 'tazendra') { $ptgoServer = 'production'; }
> 
223d161
< # &mockup();
236,240d173
< #   elsif ($action eq "textpressoInfo") { &textpressoInfoPage(); }	# used to show title/abstract in iframe, now loading from each mod flatfile populated during gpi sentence conversion
< #   elsif ($action eq "Submit !") { &newEntry(); }
< #   elsif ($action eq "Source File !") { &changeSourceFile(); }
< #   elsif ($action eq "Dump 10 !") { &dump10(); } 
< #   elsif ($action eq "Search Pap Source !") { &findPapSourceFile(); } 
359c292
<             push @ptgoFields, "userid=test:$ptgoUser"; 
---
>             push @ptgoFields, "userid=$ptgoServer:$ptgoUser"; 
462d394
< #   print qq( SELECT * FROM ccc_geneprodindex WHERE ccc_mod = '$mod' AND ccc_file IN ('$pgquery_sourcefiles') $geneprodPostgresPart ORDER BY ccc_timestamp DESC; <br/>);
465d396
< #     print qq( ROW @row ROW<br/> );
472,476d402
< #   if ($component) {
< #     $lc_component = lc($component);
< #     $componentPostgresPart = qq( AND LOWER(ccc_componentindex) ~ '$lc_component' ); }
< #   $result = $dbh->prepare( "SELECT * FROM ccc_componentindex WHERE ccc_mod = '$mod' AND ccc_file IN ('$pgquery_sourcefiles') $componentPostgresPart ORDER BY ccc_timestamp DESC;" );
< #   print qq( SELECT * FROM ccc_componentindex WHERE ccc_mod = '$mod' AND ccc_file IN ('$pgquery_sourcefiles') $componentPostgresPart ORDER BY ccc_timestamp DESC; <br/>);
481d406
< #     print qq( ROW @row ROW<br/> );
520,539d444
< #    if ($annotcurator) {
< #      $searchParametersAmount++;
< #      $result = $dbh->prepare( "SELECT * FROM ccc_sentenceannotation WHERE ccc_mod = '$mod' AND ccc_file IN ('$pgquery_sourcefiles') AND ccc_curator = '$curator' ORDER BY ccc_timestamp DESC;" );
< #  #     print qq(SELECT * FROM ccc_sentenceannotation WHERE ccc_mod = '$mod' AND ccc_file IN ('$pgquery_sourcefiles') AND ccc_curator = '$curator' ORDER BY ccc_timestamp DESC;<br/>\n);
< #      $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
< #      while (my @row = $result->fetchrow()) { 
< #        my ($mod, $filename, $paper, $section, $sentnum, $geneprod, $component, $goterm, $evidencecode, $with, $alreadycurated, $comment, $valid, $ptgoid, $curator, $timestamp) = @row;
< #        print qq( ROW @row ROW<br/> );
< #        $searchResults{$filename}{$paper}{$section}{$sentnum}{annotcurator}++; } }
<  
< #   if ($annotdate) {
< #     $searchParametersAmount++;
< #     $result = $dbh->prepare( "SELECT * FROM ccc_sentenceannotation WHERE ccc_mod = '$mod' AND ccc_file IN ('$pgquery_sourcefiles') AND ccc_timestamp::text ~ '$annotdate' ORDER BY ccc_timestamp DESC;" );
< # #     print qq( SELECT * FROM ccc_sentenceannotation WHERE ccc_mod = '$mod' AND ccc_file IN ('$pgquery_sourcefiles') AND ccc_timestamp::text ~ '$annotdate' ORDER BY ccc_timestamp DESC;<br/>\n );
< #     $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
< #     while (my @row = $result->fetchrow()) { 
< #       my ($mod, $filename, $paper, $section, $sentnum, $geneprod, $component, $goterm, $evidencecode, $with, $alreadycurated, $comment, $valid, $ptgoid, $curator, $timestamp) = @row;
< # #       print qq( ROW @row ROW<br/> );
< #       $searchResults{$filename}{$paper}{$section}{$sentnum}{annotdate}++; } }
< 
571,572d475
< #           my $SPMcount = scalar @searchParametersMatches;
< #           print qq(SPMcount $SPMcount SPMcount<br>);
575d477
< # print "GOOD $paper $section SN $sentnum FN $filename SP $searchParameter E<br>";
577,580d478
< #               $good{$filename}{$paper}{$section}{$sentnum}{$searchParameter}++;
< #               foreach my $data (sort keys %{ $searchResults{$filename}{$paper}{$section}{$sentnum}{$searchParameter} }) {
< #                 $good{$filename}{$paper}{$section}{$sentnum}{$searchParameter}{$data}++;
< #               } # foreach my $data (sort keys %{ $searchResults{$filename}{$paper}{$section}{$sentnum}{$searchParameter} })
589d486
< # my %pgCurated;		# data queried from postgres
591d487
< #   print qq( "SELECT * FROM ccc_sentenceclassification WHERE ccc_paper IN ('$in_papers');" <br/>\n);
598d493
< #     print qq(ROW @row ROW<br/>\n);
603d497
< #     my ($mod, $file, $paper, $section, $sentnum, $geneprod, $component, $goterm, $evidencecode, $with, $alreadycurated, $comment, $valid, $ptgoid, $rowcurator, $timestamp) = @row;
606d499
< #     print qq(ROW @row ROW<br/>\n);
636d528
< #   &populateTextpressoAccession();		# http://textpresso-dev.caltech.edu/ccc_results/accession
648d539
< #     my $modid = $papid; if ( $accession_map{$papid} ) { $modid = $accession_map{$papid}; }
660d550
< #     my ($title, $abstract) = &getTextpressoTitleAbstract($modid, $mod);	# to load dynamically and print to screen, whcih is slow to get each URL from textpresso and makes the whole thing slow
663d552
< #     $toPrint .= qq(<tr><td><iframe height="200" width="1300" src="ccc.cgi?action=textpressoInfo&modid=$modid&mod=$mod"></iframe></td></tr>);		# use an iframe to load this information later, won't fit as well but will load much faster
665d553
< #               $good{$paper}{$section}{$sentnum}{$filename}{$searchParameter}++;
667d554
< # print "S $section<br>";
669d555
< # print "SN $sentnum<br>";
671d556
< # print "ST $papid $section $sentnum $filename E<br>";
696d580
< # my %paperInfo;		# paper information from textpresso from pmid to modid/title/abstract
698d581
< #   my $infile = 'source/' . $mod . '/pmid_data.' . $mod;
727d609
< #       if ($goterm =~ m/(GO:\d+) (.+)/) { $goid = $1; $goterm = $2; }
743d624
< #   print qq(<table border="1" style="border-color: blue">);
764,766d644
< #   print qq(<option value="all" selected="selected">search all</option>);
< #   print qq(<option value="exclude_curated">exclude curated</option>);
< #   print qq(<option value="exclude_noncurated">exclude noncurated</option>);
768,769d645
< #   print qq(<tr><td>new only</td>);
< #   print qq(<td><input type="checkbox" name="newOnly" checked="checked"></td>);
775d650
< # my $src_directory = '/home/azurebrd/public_html/cgi-bin/forms/ccc/source/';
856d730
< #       my ($geneprod, $component, $goterm, $evidencecode, $with, $alreadycurated, $valid, $rowcurator, $timestamp) = @$annotationRef;
862,863d735
< #       $toPrint .= qq(<tr><td colspan="100">$geneprod -- $component -- $goterm -- $evidencecode -- $with -- AC $alreadycurated -- VALID $valid -- RC $rowcurator -- TS $timestamp</td></tr>);
< #       $toPrint .= "<tr><td>CURATED $papid $section $sentnum $filename -- $pgCuratedAmount -- $geneprod, $component, $goterm, $evidencecode, $with, $alreadycurated, $valid, $rowcurator, $timestamp</td></tr>";
900,902d771
< #   if ($sentence =~ m/<CCC_TAIR>/
< #     CCC_TAIR = red/brown + underlined
< #     localization_cell_components_082208 = red/brown + underlined
917d785
< #   $toPrint .= qq(<span style="text-decoration:underline">Underline indicates that one or more terms is represented in multiple Textpresso categories.</span><br/>); 
1005,1008d872
< #   my @pairs = ("transition zone -- nonmotile primary cilium", "surface -- cell surface", "mitochondria -- mitochondrion");
< #   my ($dataHashRef, $papid, $section, $sentnum, $filename) = @_;
< #   my %data = %$dataHashRef;
< #   my @components = @{ $data{$papid}{$section}{$sentnum}{$filename}{components} };
1013d876
< #   while (my @row = $result->fetchrow) { my $lcname = lc($row[1]); $goTermGoId{$lcname} = $row[0]; }	# .87 sec with lc
1016,1017d878
< #         if ($goterm =~ m/GO:\d+/) { push @pairs, "$component -- $goterm"; } 	# this was to always this play component-goterm mappings, even if the goids were invalid
< #         if ($goterm =~ m/GO:\d+ /) { $goterm =~ s/GO:\d+ //; }	# I think this is redundant, J 2013 06 11
1030,1033d890
< #   my @components = ("transition zone", "surface", "mitochondria");
< #   my ($dataHashRef, $papid, $section, $sentnum, $filename) = @_;
< #   my %data = %$dataHashRef;
< #   my @components = @{ $data{$papid}{$section}{$sentnum}{$filename}{components} };
1041d897
< #   $toPrint .= qq(go term <input size="20" name="goterm_$snumRnum"><br/>);
1062,1066d917
< #   my $toPrint;
< #   if ($snumRnum % 2 == 0) {
< #       $toPrint .= qq(<td style="background-color: red">DELETED<br/><input type="checkbox" name="undelete">undelete</td>); }
< #     else {
< #       $toPrint .= qq(<td>VALID<br/><input type="checkbox" name="delete">delete</td>); }
1140,1767d990
< 
< sub changeSourceFile {
<   my ($var, $oop) = &getHtmlVar($query, 'source_file');
<   if ($oop) { $src_file_name = $oop; $src_file = $src_directory . $src_file_name; }
< } # sub changeSourceFile
< 
< sub findPapSourceFile { 
<   my ($var, $paper) = &getHtmlVar($query, 'pap_sfile_search');
< #   my (@src_files) = </home/postgres/work/pgpopulation/ccc_gocuration/recent_sentences_file.*>;
<   my (@src_files) = </home2/postgres/work/pgpopulation/ccc_gocuration/sentences/recent_sentences_file.*>;
<   my @good_files;
<   foreach my $src_file (reverse @src_files) { 
<     $/ = undef;
<     open (IN, "<$src_file") or die "Cannot open $src_file : $!";
<     my $all_file = <IN>;
<     close (IN) or die "Cannot close $src_file : $!";
<     if ($all_file =~ m/$paper/) { 
<       $src_file =~ s/\/home2\/postgres\/work\/pgpopulation\/ccc_gocuration\/sentence\///g; 
<       print "Match for $paper in sourcefile <A HREF=http://tazendra.caltech.edu/~postgres/cgi-bin/data/ccc_gocuration/$src_file>$src_file</A><BR>\n"; } }
< } # sub findPapSourceFile
< 
< sub dump10 {
<   my $sentence = 0;
<   $result = $dbh->prepare( "SELECT joinkey FROM ccc_gene_comp_go WHERE ccc_source_file = '$src_file_name' ORDER BY joinkey DESC;" );
<   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
<   my @row = $result->fetchrow; if ($row[0]) { $sentence = $row[0]; } $sentence -= 10;
<   open (IN, "<$src_file") or die "Cannot open $src_file : $!";
<   for ( 1 .. $sentence ) { <IN>; }
<   for my $sent ( ($sentence + 1) .. ($sentence + 10) ) {
<     my $sentence = <IN>; 
<     print "SENT $sentence\n";
< #     print "SELECT * FROM ccc_gene_comp_go WHERE joinkey = '$sent';<BR>\n";
<   $result = $dbh->prepare( "SELECT * FROM ccc_gene_comp_go WHERE ccc_source_file = '$src_file_name' AND joinkey = '$sent';" );
<   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
<     while (my @row = $result->fetchrow) { print "$row[2]\t$row[3]\t$row[4]<BR>\n"; }
<     print "<P>\n"; }
< } # sub dump10
< 
< # to use useragent
< # use LWP::UserAgent;
< # my $ua = LWP::UserAgent->new(timeout => 30);  # instantiates a new user agent
< # $ua->agent( 'Mozilla/5.0 (X11; U; Linux x86_64; en-US; rv:1.9.2.18) Gecko/20110615 Ubuntu/10.04 (lucid) Firefox/3.6.18');
< #             my $request = HTTP::Request->new(GET => $url); 	# LWP::UserAgent   getting a 500 error
< #             my $response = $ua->request($request);        # checks url, dies if not valid.
< #             unless ($response-> is_success) {
< #               print "Error while getting ", $response->request->uri," -- ", $response->status_line, "\nABORTING QUERY PTGO\n";
< #               die "program dying now\n";
< #             }
< #             my $ptgoPage =  $response-> content;
< 
< # The first two are for WB and the last one is for DDB (dictyBase).  We won't yet be sending any annotations to P2GO for TAIR, but I believe their userid = TAIR.
< # 
< # http://www.ebi.ac.uk/internal-tools/protein2go/InsertAnnotation?userid=WB&AC=Q7JPE2&EVIDENCE=IDA&GOID=GO%3A0003674&QUALIFIER&REF_DBC=PMID&REF_ID=23283987&WITH_STR&ANN_EXT&EXTRA_TAXID
< # 
< # userid = WB
< # AC = Q7JPE2
< # EVIDENCE = IDA
< # GOID  = GO%3A0003674
< # REF_DBC = PMID
< # REF_ID = 23283987
< # 
< # http://www.ebi.ac.uk/internal-tools/protein2go/InsertAnnotation?userid=WB&AC=Q7JPE2&EVIDENCE=IPI&GOID=GO%3A0003674&QUALIFIER&REF_DBC=PMID&REF_ID=23283987&WITH_STR=Q27874&ANN_EXT&EXTRA_TAXID
< # 
< # userid = WB
< # AC = Q7JPE2
< # EVIDENCE = IPI
< # GOID  = GO%3A0003674
< # REF_DBC = PMID
< # REF_ID = 23283987
< # WITH_STR = Q27874
< # 
< # http://www.ebi.ac.uk/internal-tools/protein2go/InsertAnnotation?userid=DDB&AC=Q55G87&EVIDENCE=IPI&GOID=GO%3A0005955&QUALIFIER&REF_DBC=PMID&REF_ID=11352578&WITH_STR=Q7YSW8&ANN_EXT&EXTRA_TAXID
< # 
< # userid = DDB
< # AC = Q55G87
< # EVIDENCE = IPI
< # GOID  = GO%3A0005955
< # REF_DBC = PMID
< # REF_ID = 11352578
< # WITH_STR = Q7YSW8
< 
< # TO DYNAMICALLY GET TEXTPRESSO DATA use subs below ;  now populating to pmid_data.<mod> file when processing sentences to gpi files.
< sub textpressoInfoPage {		# display title and abstract info from textpresso in an iframe
< #   print "TITLE ABSTRACT GO HERE";
<   print qq(Content-type: text/html\n\n);
<   print qq(<HTML><HEAD></HEAD><BODY bgcolor=#ffcccc text=#000000 link=cccccc alink=eeeeee vlink=bbbbbb>);
<   my ($var, $modid) = &getHtmlVar($query, 'modid');
<   ($var, my $mod) = &getHtmlVar($query, 'mod');
< #   my ($title, $abstract) = &getTextpressoTitleAbstract($modid, $mod);
<   print qq(Title : $title<br/>);
<   print qq(Abstract : $abstract<br/>);
<   &printFooter();
< #   print qq(<table border="5" style="border-color: blue">);
< #   print qq(<tr><td>Title : $title</td></tr>);
< #   print qq(<tr><td>Abstract : $abstract</td></tr>);
< #   print qq(</table>);
< #    $toPrint .= qq(<tr><td><iframe src="ccc.cgi?action=textpressoInfo&modid=$modid&mod=$mod"></td></tr>);
< } # sub textpressoInfoPage
< 
< sub getTextpressoTitleAbstract {	# for a given mod ID and selected form mod, get paper title and abstract by URL
< #   $curators{robert}   = 'dicty';
< #   $curators{tanya}    = 'tair';
< #   $curators{kimberly} = 'worm';
<   my ($modid, $formMod) = @_;
<   my ($title, $abstract) = ('', '');
<   my $modsDontMatch = 0;
<   my ($urlMod, $num) = split/:/, $modid;
<   if ($urlMod eq 'PMID') { $urlMod = 'dicty25'; unless ($formMod eq 'dicty') { $modsDontMatch++; } }
<     elsif ($urlMod eq 'TAIR') { $urlMod = 'arabidopsis'; unless ($formMod eq 'tair') { $modsDontMatch++; } }
<     elsif ($urlMod eq 'celegans') { unless ($formMod eq 'worm') { $modsDontMatch++; } }
<   unless ($modsDontMatch) { 
<     my $url = 'http://textpresso-dev.caltech.edu/' . $urlMod . '/tdb/' . $urlMod . '/txt/bib-all/' . $num;
< #     print "URL $url URL\n";
<     my ($tdata) = get $url;
<     my (@lines) = split/\n/, $tdata;
<     my @abstract; my @title;
<     foreach my $line (@lines) {
<       if ($line =~ m/^abstract_#(.*)$/) { my ($sentence) = &convertTextpressoSentence($1); push @abstract, $sentence; }
<         elsif ($line =~ m/^title_#(.*)$/) { my ($sentence) = &convertTextpressoSentence($1); push @title, $sentence; } }
<     $abstract = join" ", @abstract;
<     $title = join" ", @title; }
<   unless ($title) {    $title    = 'cannot find title from textpresso'; }
<   unless ($abstract) { $abstract = 'cannot find abstract from textpresso'; }
< # http://textpresso-dev.caltech.edu/celegans/tdb/celegans/txt/bib-all/WBPaper00037556
< # http://textpresso-dev.caltech.edu/dicty25/tdb/dicty25/txt/bib-all/19692569
< # http://textpresso-dev.caltech.edu/arabidopsis/tdb/arabidopsis/txt/bib-all/11042
<   return ($title, $abstract);
< } # sub getTextpressoTitleAbstract
< 
< sub convertTextpressoSentence {		# convert underscore coded textpresso sentence to human readable sentence
<   my ($origSentence) = @_; my @sentence;
<   my (@words) = split/\s+/, $origSentence;
<   foreach my $word (@words) {
<     if ($textpresso_chars{$word}) { $word = $textpresso_chars{$word}; }
<     push @sentence, $word; }
<   my $sentence = join" ", @sentence;
<   return $sentence;
< } # sub convertTextpressoSentence
< 
< sub populateTextpressoAccession {
< #   my $url = 'http://textpresso-dev.caltech.edu/ccc_results/accession';	# to get accession dynamically
< #   my ($accession_data) = get $url;
< #   my (@lines) = split/\n/, $accession_data;
< #   foreach my $line (@lines) 
<   my $infile = 'accession';						# use flatfile from a cronjob
<   open (IN, "<$infile") or warn "Cannot open $infile : $!";
<   while (my $line = <IN>) {
<     chomp $line;
<     my ($pmid, $modid) = split/\s+/, $line;
<     $accession_map{$pmid} = $modid;
<   } # while (my $line = <IN>)
<   close (IN) or warn "Cannot close $infile : $!";
< #   print "AC $accession_data AC";
< } # sub populateTextpressoAccession
< 
< sub popTextpressoChars {			# to convert textpresso underscore codes to punctuation
< # my %textpresso_chars;	# textpresso characters that got converted to underscored codes
<   $textpresso_chars{"_DQ_"}   =  '"' ;
<   $textpresso_chars{"_SQ_"}   =  "'" ;
<   $textpresso_chars{"_LT_"}   =  '<' ;
<   $textpresso_chars{"_GT_"}   =  '>' ;
<   $textpresso_chars{"_EQ_"}   =  '=' ;
<   $textpresso_chars{"_AND_"}  =  '&' ;
<   $textpresso_chars{"_AT_"}   =  '@' ;
<   $textpresso_chars{"_SLH_"}  =  '/' ;
<   $textpresso_chars{"_DLR_"}  =  '$' ;
<   $textpresso_chars{"_PCT_"}  =  '%' ;
<   $textpresso_chars{"_CRT_"}  =  '^' ;
<   $textpresso_chars{"_STR_"}  =  '*' ;
<   $textpresso_chars{"_PLS_"}  =  '+' ;
<   $textpresso_chars{"_VRT_"}  =  '|' ;
<   $textpresso_chars{"_BSL_"}  =  '\\' ;
<   $textpresso_chars{"_HSH_"}  =  '#' ;
<   $textpresso_chars{"_PRD_"}  =  '.' ;
<   $textpresso_chars{"_QMK_"}  =  '?' ;
<   $textpresso_chars{"_EMK_"}  =  '!' ;
<   $textpresso_chars{"_CMM_"}  =  ',' ;
<   $textpresso_chars{"_SCL_"}  =  ';' ;
<   $textpresso_chars{"_CLN_"}  =  ':' ;
<   $textpresso_chars{"_OSB_"}  =  '[' ;
<   $textpresso_chars{"_CSB_"}  =  ']' ;
<   $textpresso_chars{"_ORB_"}  =  '(' ;
<   $textpresso_chars{"_CRB_"}  =  ')' ;
<   $textpresso_chars{"_OCB_"}  =  '{' ;
<   $textpresso_chars{"_CCB_"}  =  '}' ;
< } # sub popTextpressoChars
< 
< sub mockup {
<   my @sentences = ('Reporter gene expression was detected for both HAG2 / MYB76 and HAG3 / MYB29 in seedlings , in the case of HAG2 / MYB76 mainly in the transition zone between roots and the foliar part and in stems ( Fig . 8a , b ) , whereas expression of HAG3 / MYB29 was observed in stems and also in the midvein of leaves ( Fig . 9a , b ) .', 'The <genes_arabidopsis>TGD4</genes_arabidopsis> <localization_experimental_082208>protein</localization_experimental_082208> was <localization_verbs_082208>enriched</localization_verbs_082208> in isolated <CCC_TAIR>chloroplasts</CCC_TAIR> in wild-type plants ( <tables_and_figures>Figure</tables_and_figures> 4b ) in parallel with the <CCC_TAIR>chloroplast</CCC_TAIR> outer <CCC_TAIR>envelope</CCC_TAIR> <localization_experimental_082208>marker</localization_experimental_082208> TOC75 ( Tranel et al . , 1995 ) .');
< 
<   print qq(<table border="1" style="border-color: blue">);
<   print qq(<tr><td>Title : HAG2 / MYB76 and HAG3 / MYB29 exert a specific and coordinated control on the regulation of aliphatic glucosinolate biosynthesis in Arabidopsis thaliana .</td</tr>);
<   print qq(<tr><td>Abstract : In a previous transactivation screen , two Arabidopsis thaliana R2R3-MYB transcription factors , HAG2 / MYB76 and HAG3 / MYB29 , along with the already characterized HAG1 / MYB28 , were identified as putative regulators of aliphatic glucosinolate biosynthesis . Molecular and biochemical characterization of HAG2 / MYB76 and HAG3 / MYB29 functions was performed using transformants with increased or repressed transcript levels . Real-time PCR assays , cotransformation assays and measurements of glucosinolate contents were used to assess the impact of both MYB factors on the steady-state level of glucosinolate biosynthetic genes and accumulation of aliphatic glucosinolates . Both HAG2 / MYB76 and HAG3 / MYB29 were shown to be positive regulators of aliphatic glucosinolate biosynthesis . Expression of promoter-beta-glucuronidase ( GUS ) fusions indicated GUS activities in both vegetative and generative organs , with distinct characteristics for each MYB factor . HAG1 / MYB28 , HAG2 / MYB76 and HAG3 / MYB29 reciprocally transactivated each other in the control of aliphatic glucosinolate biosynthesis and downregulated the expression of genes involved in the control of indolic glucosinolate biosynthesis , pointing to a reciprocal negative regulation of these two pathways . All three HAG transcription factors exert a coordinated control on aliphatic glucosinolate biosynthesis .</td></tr>);
<   foreach my $sentence (@sentences) { &showSentCuration($sentence); }
<   print qq(</table>);
< } # sub mockup
< 
< 
< 
< 
< 
< 
< sub process {
<   my ($var, $action) = &getHtmlVar($query, 'action');
<   if ($action) {
<     if ($action eq "Submit !") { &newEntry(); }
<     elsif ($action eq "Source File !") { &changeSourceFile(); }
< #     elsif ($action eq "Already !") { &newEntry('already curated'); }
< #     elsif ($action eq "Not GO !") { &newEntry('not go curatable'); }
< #     elsif ($action eq "Scrambled Sentence !") { &newEntry('scrambled sentence'); }
< #     elsif ($action eq "False Positive !") { &newEntry('false positive'); }
<     elsif ($action eq "Dump 10 !") { &dump10(); } 
<     elsif ($action eq "Search Pap Source !") { &findPapSourceFile(); } 
<   }
<   return if ($action eq "Search Pap Source !"); 
< 
<   &changeSourceFile();		# always check the sourcefile since it defaults to original list
< 
<   my $sentence = 0;
< 
<   my $result = $dbh->prepare( "SELECT joinkey FROM ccc_gene_comp_go WHERE ccc_source_file = '$src_file_name' ORDER BY joinkey DESC;" );
<   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
<   print "SELECT joinkey FROM ccc_gene_comp_go WHERE ccc_source_file = '$src_file_name' ORDER BY joinkey DESC;\n";
<   my @row = $result->fetchrow;
<   if ($row[0]) { $sentence = $row[0]; }
< #   $sentence = 2617;
< 
<   if ($action) { if ($action eq "Search !") { (my $var, $sentence) = &getHtmlVar($query, "sent_search"); $sentence--; } }
< 
<   my $sentence_count;
<   open (IN, "<$src_file") or die "Cannot open $src_file : $!";
<   for ( 1 .. $sentence ) { <IN>; $sentence_count++; }
<   my $sent_line = <IN>;
<   my ($paper) = $sent_line =~ m/(WBPaper\d+)/;
<   my @lines; my $abs = ''; my $title = '';
<   push @lines, $sent_line;
<   while (my $sent_line = <IN>) {
<     if ($sent_line =~ m/\d+\tS \d+ P $paper S/) { push @lines, $sent_line; $sentence_count++; }
<     elsif ($sent_line =~ m/ABSTRACT/) { if ($sent_line =~ m/ABSTRACT\t$paper\t(.*?)$/) { $abs = $1; } }
<     elsif ($sent_line =~ m/TITLE/) { if ($sent_line =~ m/TITLE\t$paper\t(.*?)$/) { $title = $1; } }
<     else { $sentence_count++; }
<   } # while (my $sent_line = <IN>)
<   close (IN) or die "Cannot close $src_file : $!";
<   print "<FORM METHOD=POST ACTION=http://tazendra.caltech.edu/~postgres/cgi-bin/ccc_go_curation.cgi>\n";
<   print "Make connections : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Submit !\">\n"; 
< #   print "Make connections : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Submit !\">\n"; 
< #   print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Already Curated : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Already !\">\n"; 
< #   print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Not GO curatable : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Not GO !\"><BR>\n"; 
< #   print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;False Positive : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"False Positive !\">\n"; 
< #   print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scrambled Sentence : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Scrambled Sentence !\"><BR>\n"; 
<   print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dump last 10 sentences : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Dump 10 !\">\n"; 
<   print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Search for sentence : <INPUT NAME=\"sent_search\"><INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Search !\"><BR>\n"; 
<   print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Search for paper in source files : <INPUT NAME=\"pap_sfile_search\"><INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Search Pap Source !\"><BR>\n"; 
<   my $text = "Title : $title<BR>Abstract : $abs<BR>\n";
<   $text =~ s/<protein_celegans>(.*?)<\/protein_celegans>/<FONT COLOR='blue'>$1<\/FONT>/g;
<   $text =~ s/<genes_arabidopsis>(.*?)<\/genes_arabidopsis>/<FONT COLOR='blue'>$1<\/FONT>/g;
<   $text =~ s/<localization_cell_components_082208>(.*?)<\/localization_cell_components_082208>/<FONT COLOR='brown'>$1<\/FONT>/g;
<   $text =~ s/<localization_verbs_082208>(.*?)<\/localization_verbs_082208>/<FONT COLOR='green'>$1<\/FONT>/g;
<   $text =~ s/<localization_other_082208>(.*?)<\/localization_other_082208>/<FONT COLOR='orange'>$1<\/FONT>/g;
<   print $text;
<   print "<TABLE>\n";
< 
<   my $box = 0;
<   foreach my $line (@lines) {
<     $line = $src_file_name . "\t" . $line;
<     $box++;
<     &newReadSentence($line, $box); } 
<   print "<INPUT TYPE=HIDDEN NAME=box_count VALUE=\"$box\">\n";
<   print "</TABLE>\n";
<   print "Make connections : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Submit !\"><BR>\n"; 
<   print "Enter comments for this sentence here : <TEXTAREA NAME=comment ROWS=4 COLS=80></TEXTAREA><BR>\n";
<   print "There are $sentence_count sentences in the sourcefile <A HREF=http://tazendra.caltech.edu/~postgres/cgi-bin/data/ccc_gocuration/sentences/$src_file_name>$src_file</A><BR>\n";
< #   my (@src_files) = </home/postgres/work/pgpopulation/ccc_gocuration/recent_sentences_file.*>;
<   my (@src_files) = </home2/postgres/work/pgpopulation/ccc_gocuration/sentences/recent_sentences_file.*>;
< #   my (@tair_src_files) = </home2/postgres/work/pgpopulation/ccc_gocuration/sentences/2008_*>;
<   foreach (reverse @src_files) { $_ =~ s/\/home2\/postgres\/work\/pgpopulation\/ccc_gocuration\/sentences\///g; }
< #   foreach (reverse @tair_src_files) { $_ =~ s/\/home2\/postgres\/work\/pgpopulation\/ccc_gocuration\/sentences\///g; }
<   print "Select a source_file : <SELECT NAME=\"source_file\" SIZE=1>\n";
<   if ($src_file_name) { print "<OPTION>$src_file_name</OPTION>\n"; }
<   foreach (reverse @src_files) { print "      <OPTION>$_</OPTION>\n"; }
< #   foreach (reverse @tair_src_files) { print "      <OPTION>$_</OPTION>\n"; }
<   print "      <OPTION>good_senteces_file.20070316.1802</OPTION>\n";
<   print "    </SELECT>\n ";
<   print "<INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Source File !\"><BR>\n"; 
<   print "</FORM>\n";
< 
< 
< 
< #   open (IN, "<$src_file") or die "Cannot open $src_file : $!";
< #   my $sentence_count;
< #   for ( 1 .. $sentence ) { <IN>; $sentence_count++; }
< #   print "<FORM METHOD=POST ACTION=http://tazendra.caltech.edu/~postgres/cgi-bin/ccc_go_curation.cgi>\n";
< #   print "Make connections : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Submit !\">\n"; 
< #   print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Already Curated : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Already !\">\n"; 
< #   print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Not GO curatable : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Not GO !\"><BR>\n"; 
< #   print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;False Positive : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"False Positive !\">\n"; 
< #   print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scrambled Sentence : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Scrambled Sentence !\"><BR>\n"; 
< #   print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dump last 10 sentences : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Dump 10 !\">\n"; 
< #   print "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Search for sentence : <INPUT NAME=\"sent_search\"><INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Search !\"><BR>\n"; 
< #   print "<TABLE>\n";
< #   my $line = <IN>;
< #   for my $box (1 .. 3) {
< #     &readSentence($sentence, $line, $box); } $sentence_count++; 
< #   while (<IN>) { $sentence_count++; }
< #   print "</TABLE>\n";
< #   print "Make connections : <INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Submit !\"><BR>\n"; 
< #   print "Enter comments for this sentence here : <TEXTAREA NAME=comment ROWS=4 COLS=80></TEXTAREA><BR>\n";
< #   print "There are $sentence_count sentences in the sourcefile <A HREF=http://tazendra.caltech.edu/~postgres/cgi-bin/data/ccc_gocuration/$src_file_name>$src_file</A><BR>\n";
< #   my (@src_files) = </home/postgres/work/pgpopulation/ccc_gocuration/recent_sentences_file.*>;
< #   foreach (reverse @src_files) { $_ =~ s/\/home\/postgres\/work\/pgpopulation\/ccc_gocuration\///g; }
< #   print "Select a source_file : <SELECT NAME=\"source_file\" SIZE=1>\n";
< #   if ($src_file_name) { print "<OPTION>$src_file_name</OPTION>\n"; }
< #   foreach (@src_files) { print "      <OPTION>$_</OPTION>\n"; }
< #   print "      <OPTION>good_senteces_file.20070316.1802</OPTION>\n";
< #   print "    </SELECT>\n ";
< #   print "<INPUT TYPE=\"submit\" NAME=\"action\" VALUE=\"Source File !\"><BR>\n"; 
< #   print "</FORM>\n";
< #   close (IN) or die "Cannot close $src_file : $!";
< } # sub process
< 
< 
< sub newEntry {	# old version
<   my $goterm = shift;
<   print "You've entered stuff : <BR>\n";
<   my $badData = 0; my @pgcommands;
<   my ($var, my $paps) = &getHtmlVar($query, "paps");
<   ($var, my $ccc) = &getHtmlVar($query, "ccc");
<   ($var, my $ccc_src_file) = &getHtmlVar($query, "ccc_src_file");
<   if ( ($goterm eq 'already curated') || ($goterm eq 'not go curatable') || ($goterm eq 'scrambled sentence') || ($goterm eq 'false positive') ) {
<       push @pgcommands, "INSERT INTO ccc_gene_comp_go VALUES ('$ccc', '$ccc_src_file', '$paps', NULL, NULL, '$goterm', CURRENT_TIMESTAMP);"; }
<     else {
<       for my $count ( 1 .. 3 ) {
<         ($var, my $gene) = &getHtmlVar($query, "gene_$count");
<         ($var, my $component) = &getHtmlVar($query, "component_$count");
<         unless ( ($goterm eq 'already curated') || ($goterm eq 'not go curatable') || ($goterm eq 'scrambled sentence') || ($goterm eq 'false positive') ) {
<           ($var, $goterm) = &getHtmlVar($query, "goterm_$count");
<           ($var, my $new_goterm) = &getHtmlVar($query, "new_goterm_$count");
<           if ($new_goterm) { $goterm = $new_goterm; &addTerm($component, $new_goterm); } }
<     
< #         print "Gene $gene Component $component GO_term $goterm Paper-Sentence $paps SentenceID $ccc<BR>\n";
<         if ($goterm) {
<           unless ( ($goterm eq 'already curated') || ($goterm eq 'not go curatable') || ($goterm eq 'scrambled sentence') || ($goterm eq 'false positive') ) {
<             unless ($gene) { print "<FONT COLOR=red>ERROR $goterm has no gene</FONT><BR>\n"; $badData++; } 
<             unless ($component) { print "<FONT COLOR=red>ERROR $goterm has no component</FONT><BR>\n"; $badData++; } 
<             unless ($badData) { 
<               &addToGo($gene, $paps, $goterm);
<               push @pgcommands, "INSERT INTO ccc_gene_comp_go VALUES ('$ccc', '$src_file_name', '$paps', '$gene', '$component', '$goterm', CURRENT_TIMESTAMP);"; } }
<         }
<       } } # for my $count ( 1 .. 3 ) # else
<   ($var, my $comment) = &getHtmlVar($query, "comment");
<   if ($comment) { push @pgcommands, "INSERT INTO ccc_comment VALUES ('$ccc', '$comment', CURRENT_TIMESTAMP);"; }
<     
<   if ($badData) { print "<FONT COLOR=red>Click BACK, fix the bad data, and resubmit</FONT><P><P>\n"; return; }
<     else {
<       foreach my $pgcommand (@pgcommands) {
<         my $result = $conn->exec( "$pgcommand" );
<         print "<FONT COLOR='green'>$pgcommand</FONT><BR>\n"; } }
<   print "<P>\n";
< } # sub newEntry
< 
< 
< sub newEntry {	# obsolete 2013 11 14
< #   my $goterm = shift;
<   print "You've entered stuff : <BR>\n";
<   my $badData = 0; my @pgcommands;
<   my ($var, my $paps) = &getHtmlVar($query, "paps");
<   ($var, my $box_count) = &getHtmlVar($query, "box_count");
< 
<   for my $box ( 1 .. $box_count ) {
<     ($var, my $sentid) = &getHtmlVar($query, "sentid_$box");
< # print "BOX $box S $sentid E<BR>\n";
< 
<     ($var, my $comment) = &getHtmlVar($query, "comment");
<     if ($comment) { push @pgcommands, "INSERT INTO ccc_comment VALUES ('$sentid', '$comment', CURRENT_TIMESTAMP);"; }
< 
<     ($var, my $ccc_src_file) = &getHtmlVar($query, "ccc_src_file");
<     ($var, my $goterm) = &getHtmlVar($query, "curate_radio_$box");
< #     if ( ($goterm eq 'already curated') || ($goterm eq 'not go curatable') || ($goterm eq 'scrambled sentence') || ($goterm eq 'false positive') ) # require already curated to have protein and component  for Kimberly  2009 05 21
<     if ( ($goterm eq 'not go curatable') || ($goterm eq 'scrambled sentence') || ($goterm eq 'false positive') ) {
<       push @pgcommands, "INSERT INTO ccc_gene_comp_go VALUES ('$sentid', '$ccc_src_file', '$paps', NULL, NULL, '$goterm', CURRENT_TIMESTAMP);"; }
<     else {
<         ($var, my $gene) = &getHtmlVar($query, "gene_$box");
<         ($var, my $component) = &getHtmlVar($query, "component_$box");
<         unless ( ($goterm eq 'already goterm') || ($goterm eq 'not go curatable') || ($goterm eq 'scrambled sentence') || ($goterm eq 'false positive') ) {
<           ($var, $goterm) = &getHtmlVar($query, "goterm_$box");
<           ($var, my $new_goterm) = &getHtmlVar($query, "new_goterm_$box");
<           if ($new_goterm) { $goterm = $new_goterm; &addTerm($component, $new_goterm); } }
<     
<         print "Gene $gene Component $component GO_term $goterm Paper-Sentence $paps SentenceID $sentid<BR>\n";
<         if ($goterm) {
< #           unless ( ($goterm eq 'already curated') || ($goterm eq 'not go curatable') || ($goterm eq 'scrambled sentence') || ($goterm eq 'false positive') ) # require already curated to have protein and component  for Kimberly  2009 05 21
<           unless ( ($goterm eq 'not go curatable') || ($goterm eq 'scrambled sentence') || ($goterm eq 'false positive') ) {	# already curated to have protein and component  for Kimberly  2009 05 21
<             unless ($gene) { print "<FONT COLOR=red>ERROR $goterm has no gene</FONT><BR>\n"; $badData++; } 
<             unless ($component) { print "<FONT COLOR=red>ERROR $goterm has no component</FONT><BR>\n"; $badData++; } 
<             unless ($badData) { 
<               ($var, my $add_to_go) = &getHtmlVar($query, "add_to_go_$box");
< #               if ($add_to_go eq 'checked') { &addToGoCGI($gene, $paps, $goterm); }
<               if ($add_to_go eq 'checked') { &addToGoPhenote($gene, $paps, $goterm); }
<               push @pgcommands, "INSERT INTO ccc_gene_comp_go VALUES ('$sentid', '$ccc_src_file', '$paps', '$gene', '$component', '$goterm', CURRENT_TIMESTAMP);"; } }
<         }
<       } } # for my $box ( 1 .. $box_count )
<     
<   if ($badData) { print "<FONT COLOR=red>Click BACK, fix the bad data, and resubmit</FONT><P><P>\n"; return; }
<     else {
<       foreach my $pgcommand (@pgcommands) {
<         $result = $dbh->prepare( "$pgcommand" );
<         $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
<         print "<FONT COLOR='green'>$pgcommand</FONT><BR>\n"; } }
<   print "<P>\n";
< } # sub newEntry
< 
< sub addTerm {
<   my ($component, $goterm) = @_;
<   unless ($comp_index{$component}{$goterm}) {
<     print "<FONT COLOR='blue'>Adding</FONT> new <FONT COLOR='orange'>$goterm</FONT> - <FONT COLOR='brown'>$component</FONT> relationship to index<BR>\n";
<     $result = $dbh->do( "INSERT INTO ccc_component_go_index VALUES ('$component', '$goterm');" ); }
< } # sub addTerm
< 
< sub addToGoCGI {
<   my ($gene, $paps, $goterm) = @_;
< #   my ($pap) = $paps =~ m/P (WBPaper\d+) S/;
<   my ($pap) = $paps =~ m/name=(WBPaper\d+);class=Paper/;
<   my $time = &getPgDate();
<   $gene = lc($gene);		# now using proteins, so need to lc to get locus 2007 08 07
<   $result = $dbh->prepare( "SELECT * FROM got_locus WHERE got_locus = '$gene'; ");
<   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
<   my @row = $result->fetchrow;
<   if ($row[0]) {		# entry exists, append to it
<       my $joinkey = $row[0];
<       my %filter_hash;
<       $result = $dbh->prepare( "SELECT * FROM got_cell_goid WHERE joinkey = '$joinkey' ORDER BY got_timestamp;" );
<       $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
<       while (my @row = $result->fetchrow) {
<         if ($row[2]) { $filter_hash{$row[1]} = $row[2]; }
<           else { delete $filter_hash{$row[1]}; } }
<       my @vals = sort {$a<=>$b} keys %filter_hash;
<       my $high_count = pop @vals;
<       my $order = $high_count + 1;
<       $result = $dbh->prepare( "SELECT * FROM got_goterm WHERE got_goterm = '$goterm';" );
<       $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
<       @row = $result->fetchrow;
<       unless ($row[0]) { print "<FONT COLOR=red>ERROR $goterm is not a valid GO term</FONT>."; die "$goterm is not a valid GO term : $!"; }
<       my $goid = $row[0];
<       my @pgcommands = ();
<       my $pgcommand = "INSERT INTO got_cell_goterm VALUES ('$joinkey', '$order', '$goterm')";
<       push @pgcommands, $pgcommand;
<       $pgcommand = "INSERT INTO got_cell_goid VALUES ('$joinkey', '$order', '$goid')";
<       push @pgcommands, $pgcommand;
<       $pgcommand = "INSERT INTO got_cell_paper_evidence VALUES ('$joinkey', '$order', '$pap')";
<       push @pgcommands, $pgcommand;
<       $pgcommand = "INSERT INTO got_cell_curator_evidence VALUES ('$joinkey', '$order', 'Kimberly Van Auken')";
<       push @pgcommands, $pgcommand;
<       $pgcommand = "INSERT INTO got_cell_goinference VALUES ('$joinkey', '$order', 'IDA')";
<       push @pgcommands, $pgcommand;
<       $pgcommand = "INSERT INTO got_cell_dbtype VALUES ('$joinkey', '$order', 'protein')";
<       push @pgcommands, $pgcommand;
<       $pgcommand = "INSERT INTO got_cell_lastupdate VALUES ('$joinkey', '$order', '$time')";
<       push @pgcommands, $pgcommand;
<       foreach my $pgcommand (@pgcommands) {
<         $result = $dbh->prepare( $pgcommand );
<         $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
<         print "<FONT COLOR=green>$pgcommand</FONT><BR>\n"; } }
<     else { print "<FONT SIZE=+2 COLOR=red>$gene has not been curated for GO curation</FONT>, please <A HREF=\"http://tazendra.caltech.edu/~postgres/cgi-bin/go_curation.cgi?action=Query+locus+%21&html_value_main_locus=$gene\" TARGET=new>curate for go</A>.<BR>\n"; }
< } # sub addToGoCGI
< 
< sub addToGoPhenote {
<   my ($locus, $paps, $goterm) = @_;
< #   my ($pap) = $paps =~ m/P (WBPaper\d+) S/;
< #   my ($pap) = $paps =~ m/name=(WBPaper\d+);class=Paper/;
<   my ($pap) = $paps =~ m/(WBPaper\d+)/;
<   my $time = &getPgDate();
<   $locus = lc($locus);		# now using proteins, so need to lc to get locus 2007 08 07
<   my $wbgene = '';
<   $result = $dbh->prepare( "SELECT * FROM gin_locus WHERE gin_locus = '$locus';" );
<   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
<   my @row = $result->fetchrow; if ($row[0]) { $wbgene = $row[0]; }
<   unless ($wbgene) { 
<     $result = $dbh->prepare( "SELECT * FROM gin_synonyms WHERE gin_synonyms = '$locus';" );
<     $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
<     my @row = $result->fetchrow; if ($row[0]) { $wbgene = $row[0]; } }
<   unless ($wbgene) { print "<FONT COLOR=red>ERROR $locus has no WBGene match.  No data entered into go phenote tables.</FONT><BR>\n"; return; }
< 
<   my $joinkey = 0;
<   $result = $dbh->prepare( "SELECT * FROM gop_wbgene ;" );
<   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
<   while (my @row = $result->fetchrow) { if ($row[0] > $joinkey) { $joinkey = $row[0]; } }
<   $joinkey++;
< #   $result = $dbh->prepare( "SELECT * FROM got_goterm WHERE got_goterm = '$goterm';" );
<   $result = $dbh->prepare( "SELECT * FROM obo_name_goid WHERE obo_name_goid = '$goterm';" );	# look at new obo tables for valid terms 2011 06 14
<   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; 
<   @row = $result->fetchrow;
<   unless ($row[0]) { print "<FONT COLOR=red>ERROR $goterm is not a valid GO term</FONT>."; die "$goterm is not a valid GO term : $!"; }
<   my $goid = $row[0];
<   my @pgcommands = ();
<   my $pgcommand = "INSERT INTO gop_goid VALUES ('$joinkey', '$goid')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_paper VALUES ('$joinkey', '$pap')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_wbgene VALUES ('$joinkey', 'WBGene$wbgene')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_goontology VALUES ('$joinkey', 'cell')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_curator VALUES ('$joinkey', 'WBPerson1843')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_goinference VALUES ('$joinkey', 'IDA')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_dbtype VALUES ('$joinkey', 'protein')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_lastupdate VALUES ('$joinkey', '$time')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_goid_hst VALUES ('$joinkey', '$goid')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_paper_hst VALUES ('$joinkey', '$pap')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_wbgene_hst VALUES ('$joinkey', 'WBGene$wbgene')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_goontology_hst VALUES ('$joinkey', 'cell')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_curator_hst VALUES ('$joinkey', 'WBPerson1843')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_goinference_hst VALUES ('$joinkey', 'IDA')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_dbtype_hst VALUES ('$joinkey', 'protein')";
<   push @pgcommands, $pgcommand;
<   $pgcommand = "INSERT INTO gop_lastupdate_hst VALUES ('$joinkey', '$time')";
<   push @pgcommands, $pgcommand;
<   foreach my $pgcommand (@pgcommands) {
<     print "<FONT COLOR=green>$pgcommand</FONT><BR>\n";
<     $result = $dbh->prepare( $pgcommand );
<     $result->execute() or die "Cannot prepare statement: $DBI::errstr\n"; }
< } # sub addToGoPhenote
< 
< sub newReadSentence {
<   my ($line, $box) = @_;
<   my ($junk, $src_file, $sentid, $paps, $genes, $components, $text, $badProt, $badComp) = split/\t/, $line;
< 
< #   my ($src_file, $line_count, $genes, $components, $text) = split/\t/, $line;
< #   my ($paps) = $line_count =~ m/(WBPaper\d+)/;
< # print "S $src_file LINE $sentid PAPS $paps GENES $genes COMPONENTS $components TEXT $text E<BR>\n";
<   my (@genes) = split/, /, $genes;
<   my (@components) = split/, /, $components;
<   my %goTerms;
<   foreach my $comp (@components) {
<     if ($comp_index{$comp}) { foreach my $goterm (keys %{ $comp_index{$comp}}) { $goTerms{$goterm}++; } } }
< 
<   $text =~ s/<protein_celegans>(.*?)<\/protein_celegans>/<FONT COLOR='blue'>$1<\/FONT>/g;
<   $text =~ s/<genes_arabidopsis>(.*?)<\/genes_arabidopsis>/<FONT COLOR='blue'>$1<\/FONT>/g;
<   $text =~ s/<localization_cell_components_082208>(.*?)<\/localization_cell_components_082208>/<FONT COLOR='brown'>$1<\/FONT>/g;
<   $text =~ s/<localization_verbs_082208>(.*?)<\/localization_verbs_082208>/<FONT COLOR='green'>$1<\/FONT>/g;
<   $text =~ s/<localization_other_082208>(.*?)<\/localization_other_082208>/<FONT COLOR='orange'>$1<\/FONT>/g;
<   $text =~ s/<localization_experimental_082208>(.*?)<\/localization_experimental_082208>/<FONT COLOR='orange'>$1<\/FONT>/g;
< 
<   print "<TR>\n";
<   print "<TD><SELECT NAME=\"gene_$box\" SIZE=12>\n";
<   print "      <OPTION> </OPTION>\n";
<   foreach (@genes) { print "      <OPTION>$_</OPTION>\n"; }
<   print "    </SELECT></TD>\n ";
< 
<   print "<TD><SELECT NAME=\"component_$box\" SIZE=12>\n";
<   print "      <OPTION > </OPTION>\n";
<   foreach (@components) { print "      <OPTION>$_</OPTION>\n"; }
<   print "    </SELECT></TD>\n ";
< 
<   print "<TD><INPUT NAME=\"new_goterm_$box\" SIZE=30><BR><SELECT NAME=\"goterm_$box\" SIZE=10>\n";
<   foreach (sort keys %goTerms) { print "      <OPTION>$_</OPTION>\n"; }
<   print "    </SELECT></TD>\n ";
< 
< 
<   my $paps_link = $paps;
<   if ($paps_link =~ m/WBPaper\d{8}/) { $paps_link =~ s/(WBPaper\d{8})/<A HREF=http:\/\/dev.wormbase.org\/db\/misc\/paper?name=$1;class=Paper TARGET=new>$1<\/A>/g; }			# link paper to dev.wormbase  2007 08 14
<   print "<TD>curate<INPUT TYPE=radio NAME=\"curate_radio_$box\" VALUE=\"curate\">&nbsp;&nbsp;";
<   print "already curated<INPUT TYPE=radio NAME=\"curate_radio_$box\" VALUE=\"already curated\">&nbsp;&nbsp;";
<   print "scrambled sentence<INPUT TYPE=radio NAME=\"curate_radio_$box\" VALUE=\"scrambled sentence\">&nbsp;&nbsp;<BR>";
<   print "false positive<INPUT TYPE=radio NAME=\"curate_radio_$box\" VALUE=\"false positive\">&nbsp;&nbsp;";
<   print "not go curatable<INPUT TYPE=radio NAME=\"curate_radio_$box\" VALUE=\"not go curatable\">&nbsp;&nbsp;<BR>";
<   print "Add To Go : <INPUT NAME=\"add_to_go_$box\" TYPE=CHECKBOX VALUE=\"checked\"><BR>\n";
<   print "SentenceID $sentid -- $paps_link<BR>$text<br /><span style=\"color:red\">already done : $badProt $badComp</span></TD>\n";
<   print "<INPUT TYPE=HIDDEN NAME=\"sentid_$box\" VALUE=\"$sentid\">\n";
<   print "<INPUT TYPE=HIDDEN NAME=paps VALUE=\"$paps\">\n";
<   print "<INPUT TYPE=HIDDEN NAME=ccc_src_file VALUE=\"$src_file\">\n";
<   print "</TR>\n";
< } # sub newReadSentence
< 
< sub readSentence {
<   my ($sentence, $line, $count) = @_;
<   $sentence++;
< #   print "SENT $sentence SENT<BR>\n";
< #   my ($src_file, $line_count, $paps, $genes, $components, $text) = split/\t/, $line;
<   my ($src_file, $line_count, $genes, $components, $text) = split/\t/, $line;
<   my ($paps) = $line_count =~ m/(WBPaper\d+)/;
< print "S $src_file LINE $line_count PAPS $paps GENES $genes COMPONENTS $components TEXT $text E<BR>\n";
< #   unless ($line_count == $sentence) { print "<FONT COLOR='red'>ERROR between sentence count in line read $sentence and sentence ID $line_count.</FONT><BR>\n"; }
<   my (@genes) = split/, /, $genes;
<   my (@components) = split/, /, $components;
<   my %goTerms;
<   foreach my $comp (@components) {
<     if ($comp_index{$comp}) { foreach my $goterm (keys %{ $comp_index{$comp}}) { $goTerms{$goterm}++; } } }
< 
<   $text =~ s/<protein_celegans>(.*?)<\/protein_celegans>/<FONT COLOR='blue'>$1<\/FONT>/g;
<   $text =~ s/<genes_arabidopsis>(.*?)<\/genes_arabidopsis>/<FONT COLOR='blue'>$1<\/FONT>/g;
<   $text =~ s/<localization_cell_components_012607>(.*?)<\/localization_cell_components_012607>/<FONT COLOR='brown'>$1<\/FONT>/g;
<   $text =~ s/<localization_verbs_012607>(.*?)<\/localization_verbs_012607>/<FONT COLOR='green'>$1<\/FONT>/g;
<   $text =~ s/<localization_other_012607>(.*?)<\/localization_other_012607>/<FONT COLOR='orange'>$1<\/FONT>/g;
<   $text =~ s/<localization_experimental_082208>(.*?)<\/localization_experimental_082208>/<FONT COLOR='orange'>$1<\/FONT>/g;
< 
<   print "<TR>\n";
<   print "<TD><SELECT NAME=\"gene_$count\" SIZE=12>\n";
<   print "      <OPTION> </OPTION>\n";
<   foreach (@genes) { print "      <OPTION>$_</OPTION>\n"; }
<   print "    </SELECT></TD>\n ";
< 
<   print "<TD><SELECT NAME=\"component_$count\" SIZE=12>\n";
<   print "      <OPTION > </OPTION>\n";
<   foreach (@components) { print "      <OPTION>$_</OPTION>\n"; }
<   print "    </SELECT></TD>\n ";
< 
<   print "<TD><INPUT NAME=\"new_goterm_$count\" SIZE=30><BR><SELECT NAME=\"goterm_$count\" SIZE=10>\n";
<   foreach (sort keys %goTerms) { print "      <OPTION>$_</OPTION>\n"; }
<   print "    </SELECT></TD>\n ";
< 
<   if ($paps =~ m/WBPaper\d{8}/) { $paps =~ s/(WBPaper\d{8})/<A HREF=http:\/\/dev.wormbase.org\/db\/misc\/paper?name=$1;class=Paper TARGET=new>$1<\/A>/g; }			# link paper to dev.wormbase  2007 08 14
<   print "<TD>SentenceID $sentence -- $paps<BR><BR>$text</TD>\n";
<   print "<INPUT TYPE=HIDDEN NAME=ccc VALUE=\"$sentence\">\n";
<   print "<INPUT TYPE=HIDDEN NAME=paps VALUE=\"$paps\">\n";
<   print "<INPUT TYPE=HIDDEN NAME=ccc_src_file VALUE=\"$src_file\">\n";
<   print "</TR>\n";
< } # sub readSentence
< 
