#!/usr/bin/perl 

# process from amigo solr to generate json or graphs or text results. 

# test inferred dag view  2013 07 16

# ebi has a better graph in "Term Hierarchy"
# http://www.ebi.ac.uk/ontology-lookup/browse.do?ontName=GO&termId=GO%3A0033554&termName=cellular%20response%20to%20stress
# http://www.ebi.ac.uk/ontology-lookup/browse.do?ontName=GO&termId=GO:0034051&termName=cellular%20response%20to%20stress
#
# wormbase display 
# https://www.wormbase.org/species/all/go_term/GO:0033554#2--10
#
# berkeleybop display 
# http://amigo2.berkeleybop.org/cgi-bin/amigo2/amigo/term/GO:0033554
#
# berkeleybop json
# http://golr.berkeleybop.org/select?qt=standard&fl=*&version=2.2&wt=json&indent=on&rows=1&q=id:%22GO:0033554%22&fq=document_category:%22ontology_class%22
# do not trust regulates_transitivity_graph_json edges in term 80135, 9987 is_a doesn't make sense.  regulates_transitivity_graph_json has just the ancestors.
# topology_graph_json has ancestors and children, and edges have relationship between direct nodes.
#
# berkeleybop json for direct genes
# http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=*%2Cscore&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=annotation_class_list:%22GO:0006950%22	# with fl wildcard that returns a lot of data
# http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=id%2Cscore&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=annotation_class_list:%22GO:0006950%22
# http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=annotation_class_list:%22GO:0006950%22	# with wbgenes listed
# http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&q=document_category:bioentity&fq=source:%22WB%22&fq=%7B!cache=false%7Dannotation_class_list:%22GO:0006950%22	# with wbgenes listed, more specific q, cache off
#
# berkeleybop json for genes by inference (direct + indirect)
# http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=*%2Cscore&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=regulates_closure:%22GO:0006950%22	# with fl wildcard that returns a lot of data
# http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=%2Cscore&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=regulates_closure:%22GO:0006950%22
# http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=regulates_closure:%22GO:0006950%22	# with wbgenes listed
# http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&q=document_category:bioentity&fq=source:%22WB%22&fq=%7B!cache=false%7Dregulates_closure:%22GO:0006950%22	# with wbgenes listed, more specific q, cache off
#
# expandable ul display
# http://sequenceontology.org/browser/current_svn/term/SO:0000625  
#
# graphviz documentation
# http://search.cpan.org/~rsavage/GraphViz-2.14/lib/GraphViz.pm
#
# solr reference guide
# https://cwiki.apache.org/confluence/display/solr/Apache+Solr+Reference+Guide
#
# using GraphViz to generate an SVG with clickable links to other nodes in the graph.
# using JSON to parse the json from berkeleybop
# using LWP::Simple to get json from berkeleybop
# given a goid, generate an svg graph with clickable nodes and make a separate table of children if there's too many.  for Raymond.  2013 07 17
#
# make an inferred tree view using  regulates_transitivity_graph_json  edges from the json. # this is later found to be wrong on 2013 07 25
# Raymond suggests that the depth of indentation corresponds to the longest path from main node to root.
# couldn't find a longest path method in Graph.pm .  2013 07 18
#
# changed directory and repo to "wobr" (worm ontology browser) for Raymond.  2013 07 22
#
# add number of direct genes and inferred genes to each item in inferred tree view.  link those to another page that lists each gene.  
# pre-loading all the genes to display was taking too long because of getting all lists of genes for all go terms from berkeleybop.  2013 07 23
#
# concentrate image, change fontsize, remove label from edges, add a legend for edges.  
# given each of the main term's parents, list siblings from that parent in an expandable table.  2013 07 24
#
# added graphViz legend as separate image (I don't like it)
# regulates_transitivity_graph_json  from json does not give proper dominant inferred transitivity, deriving it from each final path using
#   inferred transitivity of pairs  http://www.geneontology.org/GO.ontology-ext.relations.shtml 
#   and dominant transitivity of multiple path from  ChewableGraph.pm	2013 07 26
#
# Raymond found single URLs for JSON to get gene counts for direct/inferred for a given goid and all its children, and using a single URL for direct and a single for inferred is waaaay faster ; these URLs may not give correct children counts though.  Raymond and Chris feel we don't need the count for ancestors.
# direct url
# 'http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&q=document_category:bioentity&facet=true&facet.field=annotation_class_list&facet.limit=-1&facet.mincount=1&facet.prefix=GO&facet.sort=count&fq=source:%22WB%22&fq=annotation_class_list:%22' . $goid . '%22';
# inferred url
# 'http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&q=document_category:bioentity&facet=true&facet.field=regulates_closure&facet.limit=-1&facet.mincount=1&facet.prefix=GO&facet.sort=count&fq=source:%22WB%22&fq=regulates_closure:%22' . $goid . '%22'; 
# Combined  &showInferredGenes();  and  &showDirectGenes();  into the single  &showGenes();  2013 07 30
#
# do not display direct gene products in inferred tree view.  for Raymond.
# when showing page with list of genes for a goterm, always show both direct and inferred with direct on top (for Ranjana)
# tried to clean up working of sibblings link, but raymond and chris can't decide on what it should show or how.  2013 08 01
#
# Changed url for solr queries to Raymond's virtual machine.  2013 08 06
#
# Changed display so siblings table to have an extra column for indentation, and for the links to expand and contract change the
# innerHTML of the span to a plus or minus, accordingly.  2013 08 07
#
# Added  &treeExpand();  and  &queryChildren();  to get an expandable tree display of GO terms, working off of solr only, no postgres.  2013 09 02
#
# Generalized this and javascript to work for any ontology term, working off of termIDs instead of termNumbers.
# Added root terms for expandable tree for worm anatomy, disease ontology, worm development, elegans phenotype ontology.  2013 10 28
#
# %ancestors (nodes) for %inferredTree now comes from transitivity json instead of topology. (but the edges are still from topology)
# Added more %colorMap values for new types.  2013 10 31
#
# changed $solr_url to be a $base_solr_url and created &getSolrUrl to generate the $solr_url based on the identifier prefix
# to direct to the proper solr subdirectory.  2013 11 09
#
# removed &facet.prefix=GO  since for most solr queries, it's not GO.  2013 11 12
#
# there are predicate relationships from the topoHash are non transitive and should be ignored for determining indendation depth 
# (pretend the edge doesn't exist), track them in hash  %ignoreNonTransitivePredicate  2013 11 13
#
# was still linking to  showInferredGenes  instead of just  showGenes .  2013 11 18
#
# http://wormbase.caltech.edu:8080/wormbase/manual/soba-for-gene-set/sobaanatomy  anatomy soba manual.  2015 09 24
# action => SObA4GeneSetAnatomy 
# sample set 'Bogus_set'
# gene,reads
# WBGene00010209          no expr data
# WBGene00010212
# WBGene00010295
# WBGene00015814
# WBGene11111111          not good gene id
# ZK512.6                          = WBGene00001135
#
# &annotSummaryJson ready for live use by wormbase.org  2015 12 04
#
# &annotSummaryJsonp has the "padding" for jsonp of the same content as &annotSummaryJson  to get around cross server and work 
# without fake phenotype_graph_json widget  2016 01 07

use CGI;
use strict;
use LWP::Simple;
use LWP::UserAgent;
use JSON;
use GraphViz;
use GraphViz2;

use Log::Handler;

use Storable qw(dclone);			# copy hash of hashes

use Time::HiRes qw( time );
my $startTime = time; my $prevTime = time;
$startTime =~ s/(\....).*$/$1/;
$prevTime  =~ s/(\....).*$/$1/;

use DBI;
my $dbh = DBI->connect ( "dbi:Pg:dbname=testdb;host=131.215.52.76", "", "") or die "Cannot connect to database!\n";     # for remote access
# my $dbh = DBI->connect ( "dbi:Pg:dbname=wobrdb", "", "") or die "Cannot connect to database!\n";
my $result;

my ($logger) = Log::Handler->new;
#         $logger -> add
#                 (
#                  screen =>
#                  {
#                          maxlevel       => 'debug',
#                          message_layout => '%m',
#                          minlevel       => 'error',
#                  }
#                 );

# my $gviz = GraphViz->new(width=>10, height=>8);
# my $gviz = GraphViz->new();
my $gviz = GraphViz->new(concentrate => 'concentrate');
my $gviz_legend = GraphViz->new(concentrate => 'concentrate', rankdir  => 'BT');
my $json = JSON->new->allow_nonref;
my $query = new CGI;
# my $base_solr_url = 'http://131.215.12.220:8080/solr/';		# raymond URL 2013 08 06
# my $base_solr_url = 'http://131.215.12.215:8080/solr/';		# temp while solr at .204 is down, later on back to :8082
my $base_solr_url = 'http://wobr.caltech.edu:8082/solr/';		# raymond dev URL 2015 07 24
# my $solr_url = 'http://golr.berkeleybop.org/';


my %paths;	# finalpath => array of all (array of nodes of paths that end)
		# childToParent -> child node -> parent node => relationship
		# # parentToChild -> parent node -> child node => relationship

  my %nodesAll;								# for an annotated phenotype ID, all nodes in its topological map that have transitivity
  my %edgesAll;								# for an annotated phenotype ID, all edges in its topological map that have transitivity
  my %ancestorNodes;

&process();

sub process {
  my $action;                   # what user clicked
  unless ($action = $query->param('action')) { $action = 'none'; }

#   &printHtmlHeader(); 
#   print "If you're using this, talk to Juancarlos<br/>";
  if ($action eq 'Tree') { &dag(); }
    elsif ($action eq 'showGenes')                  { &showGenes();             }
    elsif ($action eq 'queryChildren')              { &queryChildren();         }
    elsif ($action eq 'annotSummaryGraph')          { &annotSummaryGraph();     }
    elsif ($action eq 'annotSummaryCytoscape')      { &annotSummaryCytoscape(); }
    elsif ($action eq 'annotSummaryJson')           { &annotSummaryJson();      }	# temporarily keep this for the live www.wormbase going through the fake phenotype_graph_json widget
    elsif ($action eq 'annotSummaryJsonp')          { &annotSummaryJsonp();     }	# new jsonp widget to get directly from .wormbase without fake widget
    elsif ($action eq 'anatomySobaInput')           { &anatomySobaInput();      }
    elsif ($action eq 'HGE Analyze List')           { &anatomySoba('textarea'); }
    elsif ($action eq 'HGE Analyze File')           { &anatomySoba('file');     }
    elsif ($action eq 'getWithPost')                { &getWithPost();           }	# test getting data with post, can delete later

#     elsif ($action eq 'showInferredGenes') { &showInferredGenes(); }	# combined into the single &showGenes();
#     elsif ($action eq 'showDirectGenes') {   &showDirectGenes();   }	# combined into the single &showGenes();
    else { &dag(); }				# no action, show dag by default
} # sub process

sub getSolrUrl {
  my ($focusTermId) = @_;
  my ($identifierType) = $focusTermId =~ m/^(\w+):/;
  my %idToSubdirectory;
  $idToSubdirectory{"WBbt"}        = "anatomy";
  $idToSubdirectory{"DOID"}        = "disease";
  $idToSubdirectory{"GO"}          = "go";
  $idToSubdirectory{"WBls"}        = "lifestage";
  $idToSubdirectory{"WBPhenotype"} = "phenotype";
  my $solr_url = $base_solr_url . $idToSubdirectory{$identifierType} . '/';
} # sub getSolrUrl

sub getTopoHash {
  my ($focusTermId) = @_;
  my ($solr_url) = &getSolrUrl($focusTermId);
  my $url = $solr_url . "select?qt=standard&fl=*&version=2.2&wt=json&indent=on&rows=1&q=id:%22" . $focusTermId . "%22&fq=document_category:%22ontology_class%22";
  
  my $page_data = get $url;
  
  my $perl_scalar = $json->decode( $page_data );
  my %jsonHash = %$perl_scalar;

  my $topoHashref = $json->decode( $jsonHash{"response"}{"docs"}[0]{"topology_graph_json"} );
#   return ($topoHashref);
  my $transHashref = $json->decode( $jsonHash{"response"}{"docs"}[0]{"regulates_transitivity_graph_json"} );	# need this for inferred Tree View
  return ($topoHashref, $transHashref);
} # sub getTopoHash

sub getTopoChildrenParents {
  my ($focusTermId, $topoHref) = @_;
  my %topo = %$topoHref;
  my %children; 			# children of the wanted focusTermId, value is relationship type (predicate) ; are the corresponding nodes on an edge where the object is the focusTermId
  my %parents;				# direct parents of the wanted focusTermId, value is relationship type (predicate) ; are the corresponding nodes on an edge where the subject is the focusTermId
  my %child;				# for any term, each subkey is a child
  my (@edges) = @{ $topo{"edges"} };
  for my $index (0 .. @edges) {
    my ($sub, $obj, $pred) = ('', '', '');
    if ($edges[$index]{'sub'}) { $sub = $edges[$index]{'sub'}; }
    if ($edges[$index]{'obj'}) { $obj = $edges[$index]{'obj'}; }
    if ($edges[$index]{'pred'}) { $pred = $edges[$index]{'pred'}; }
    if ($obj eq $focusTermId) { $children{$sub} = $pred; }		# track children here
    if ($sub eq $focusTermId) { $parents{$obj}  = $pred; }		# track parents here
  }
  return (\%children, \%parents);
} # sub getTopoChildrenParents

sub queryChildren {                             # generate the html for the unordered list of a go number, produce list items and unordered lists to expand each child of the go number
  print qq(Content-type: text/plain\n\n\n);
#   my ($var, $goNumber) = &getHtmlVar($query, 'goNumber');
#   my $goid = 'GO:' . $goNumber;                 # get the goid from the go number
  my ($var, $termId) = &getHtmlVar($query, 'termId');
  my %hash;                                     # for a child :  relationship is the termId's relationship to the original termId ; name is the termId's name ; hasChildren is the count of children if the child is itself a parent of other termId

# solr way of getting data
  my ($topoHashref, $transHashref) = &getTopoHash($termId);
  my %topo = %$topoHashref;
  my ($childrenHashref, $parentsHashref) = &getTopoChildrenParents($termId, $topoHashref);
  my %children = %$childrenHashref;
  my (@nodes) = @{ $topo{"nodes"} };		# use nodes to add sibling termId labels to %label
  for my $index (0 .. @nodes) {
    my ($id, $lbl) = ('', '');
    if ($nodes[$index]{'id'}) { $id = $nodes[$index]{'id'}; }
    if ($nodes[$index]{'lbl'}) { $lbl = $nodes[$index]{'lbl'}; }
    next unless ($children{$id});		# only get names of ids that are children of main term
#     $label{$id} = $lbl;
    $hash{$id}{name} = $lbl; }
  foreach my $child (sort keys %children) {	# for each child get their name from %children and whether they have children from solr
    $hash{$child}{relationship} = $children{$child};
    my ($topoChildHashref, $transChildHashref) = &getTopoHash($child);
    my %topoChild = %$topoChildHashref;
    my ($childChildrenHashref, $childParentsHashref) = &getTopoChildrenParents($child, $topoChildHashref);
    my %grandchildren = %$childChildrenHashref;
    if (scalar keys %grandchildren > 0) { $hash{$child}{hasChildren}++; }
  } # foreach my $child (sort keys %children)

# psql way of getting data
#   $result = $dbh->prepare( "SELECT goid_child, relationship FROM obo_goid_edges WHERE goid_parent = '$goid'" );         # get the goid's children and relationship
#   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
#   while (my @row = $result->fetchrow) {
#     my ($child, $relationship) = @row;
#     $hash{$child}{relationship} = $relationship;
#   }
#   my $goids = join"','", keys %hash;            # get the goids of all children
#   $result = $dbh->prepare( "SELECT * FROM obo_goid_name WHERE goid_goid IN ('$goids')" );       # get the names of the children
#   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
#   while (my @row = $result->fetchrow) {
#     $hash{$row[0]}{name} = $row[1]; }
#   $result = $dbh->prepare( "SELECT goid_parent FROM obo_goid_edges WHERE goid_parent IN ('$goids')" );  # get the count of children for each child
#   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
#   while (my @row = $result->fetchrow) {
#     my ($parent) = @row;
#     $hash{$parent}{hasChildren}++;
#   }

  foreach my $child (sort keys %hash) {         # for each child
    my $expand_link = '&nbsp;';                 # no expand link is a literal space
#     my ($goNumber) = $child =~ m/GO:(\d+)/;     # get the child's go number
    if ($hash{$child}{hasChildren}) {           # if the child has children, create a link to expand and get its children
#       $expand_link = qq(<span style="text-decoration: underline; color: blue; cursor: pointer;" id="toggle_$goNumber" onclick="expandGoid('$goNumber');" >+</span>);
      $expand_link = qq(<span style="text-decoration: underline; color: blue; cursor: pointer;" id="toggle_$child" onclick="expandTermId('$child');" >+</span>); }
    print qq(<li>$expand_link );                                        # print a list item with the link to expand if there should be one
    print qq($hash{$child}{relationship} );                             # print the relationship
    print qq($child $hash{$child}{name});                               # print the child's go name
#     print qq(<ul id="children_$goNumber" style="display: none">);	# make another unordered list to store the child's children and hide it by default
#     print qq(<li><input id="notQueried_$goNumber" value="loading"></li></ul></li>);	# add a list item to the list and an input element to state that this termId has not been queried before
    print qq(<ul id="children_$child" style="display: none">);		# make another unordered list to store the child's children and hide it by default
    print qq(<li><input id="notQueried_$child" value="loading"></li></ul></li>);	# add a list item to the list and an input element to state that this termId has not been queried before
  } # foreach my $child (sort keys %hash)
} # sub queryChildren

sub treeExpand {
  my ($var, $rootTerm) = &getHtmlVar($query, 'focusTermId');
  my @rootTerms = qw( GO:0008150 GO:0005575 GO:0003674 WBbt:0000100 DOID:4 WBls:0000075 WBPhenotype:0000886 );	# by default have the 7 main roots
  if ($rootTerm) {
#     ($rootTerm) = $rootTerm =~ m/(\d+)/;                        # just the digits
    @rootTerms = ( $rootTerm ); }                               # if given a go number, use that instead

  my %names; my %hasChildren;
# psql way to get data
#   my $goids = join"','GO:", @rootTerms;                 # get the names of all the root terms
#   $result = $dbh->prepare( "SELECT * FROM obo_goid_name WHERE goid_goid IN ('GO:$goids')" );    # get the names of the children
#   $result->execute() or die "Cannot prepare statement: $DBI::errstr\n";
#   while (my @row = $result->fetchrow) { $names{$row[0]} = $row[1]; }

# solr way to get data
  foreach my $termId (@rootTerms) {
#     my $goid = 'GO:' . $gonum;
#     my ($topoHashref) = &getTopoHash($termId);
    my ($topoHashref, $transHashref) = &getTopoHash($termId);
    my %topo  = %$topoHashref;
    my %trans = %$transHashref;
    my ($childrenHashref, $parentsHashref) = &getTopoChildrenParents($termId, $topoHashref);
    my %children = %$childrenHashref;
    if (scalar keys %children > 0) { $hasChildren{$termId}++; }
    my (@nodes) = @{ $topo{"nodes"} };		# use nodes to add sibling termId labels to %label
    for my $index (0 .. @nodes) {
      my ($id, $lbl) = ('', '');
      if ($nodes[$index]{'id'}) { $id = $nodes[$index]{'id'}; }
      if ($nodes[$index]{'lbl'}) { $lbl = $nodes[$index]{'lbl'}; }
      $names{$id} = $lbl; }
  } # foreach my $termId (@rootTerms)

  print qq(<form method="post" action="amigo.cgi">);
  print qq(A different ID to be the focus term : <input name="focusTermId"> e.g. GO:0033554 WBbt:0000100 DOID:4 WBls:0000075 WBPhenotype:0000886<br/></form>);
  foreach my $rootTerm ( @rootTerms ) {
#      my $expand_link = qq(<span style="text-decoration: underline; color: blue; cursor: pointer;" id="toggle_$rootTerm" onclick="expandGoid('$rootTerm');" >+</span>);  # span link to expand node by doing a jquery off of the cgi
     my $expand_link = qq(<span style="text-decoration: underline; color: blue; cursor: pointer;" id="toggle_$rootTerm" onclick="expandTermId('$rootTerm');" >+</span>);  # span link to expand node by doing a jquery off of the cgi
     unless ($hasChildren{$rootTerm}) { $expand_link = ''; }
     print qq(<ul><li id="$rootTerm">$expand_link $rootTerm $names{"$rootTerm"});	# start an unordered list with only element the rootTerm
     print qq(<ul id="children_$rootTerm" style="display: none">);                      # add within another unordered list for the children of this rootTerm, hide by default because clicking to query and load its values will toggle its show/hide state
     print qq(<li><input id="notQueried_$rootTerm" value="loading"></li></ul>);		# add a list item to the list and an input element to state that this rootTerm has not been queried before
     print qq(</li></ul>);                                                              # close the root unordered list and list item
  }
} # sub treeExpand

sub calcNodeWidth {
  my ($nodeCount, $maxAnyCount) = @_;
  my $nodeWidth    = 1; my $nodeScale = 1.5; my $nodeMinSize = 0; my $logScaler = .6;
# $nodeWidth    = ( log($annotationCounts{$id}{'any'})/log($maxAnyCount) * $nodeScale ) + $nodeMinSize;
# $nodeWidth    = ( log(sqrt($annotationCounts{$id}{'any'}+$logScaler))/log(sqrt($maxAnyCount+$logScaler)) * $nodeScale ) + $nodeMinSize;
  $nodeWidth    = ( sqrt($nodeCount)/sqrt($maxAnyCount) * $nodeScale ) + $nodeMinSize;
  return $nodeWidth;
} # sub calcNodeWidth

sub getDiffTime {
  my ($start, $prev, $message) = @_;
  my $now = time;
  $now =~ s/(\....).*$/$1/;
  my $diffStart = $now - $startTime;
  $diffStart =~ s/(\....).*$/$1/;
  my $diffPrev  = $now - $prevTime;
  $diffPrev  =~ s/(\....).*$/$1/;
# print qq(START $start NOW $now PREV $prev DIFFPREV $diffPrev E<br/>);
  $prevTime = $now;
  $message = qq($diffStart seconds from start, $diffPrev seconds from previous check.  Now $message);
  return ($message);
} # sub getDiffTime

sub getWithPost {		# test getting data with post  can delete later
  &printHtmlHeader(); 
  my $genelist = 'WBGene00010209 WBGene00010212 WBGene00010295 WBGene00015814 WBGene00000898 WBGene00001135 WBGene00000012 WBGene00000013 WBGene00000002 WBGene11111111';
  my $url      = 'http://131.215.12.204/~azurebrd/cgi-bin/amigo.cgi';
  my $action   = "HGE Analyze List";
  my $ua       = LWP::UserAgent->new();
  my $response = $ua->post( $url, { 'action' => "$action", 'convertGeneToId' => 'convertGeneToId', 'genelist' => "$genelist" } );
  my $content  = $response->decoded_content();
  print qq(CONT $content CONT<br>);
  &printHtmlFooter(); 
} # sub getWithPost

sub anatomySobaInput {
  &printHtmlHeader(); 
  print qq(<form method="post" action="amigo.cgi" enctype="multipart/form-data">);
  print qq(Enter list of genes here<br/>);
  print qq(<textarea name="genelist" rows="20" cols="60"></textarea><br/>);
  print qq(<input Type="checkbox" name="showProcessTimes" Value="showProcessTimes">Show Process Times<br/>\n);
  print qq(<input Type="checkbox" name="convertGeneToId" Value="convertGeneToId">Convert Genes to IDs<br/>\n);
  print qq(<input Type="checkbox" name="calculateLcaNodes" Value="calculateLcaNodes">Calculate LCA Nodes<br/>\n);
  print qq(<input type="submit" name="action" value="HGE Analyze List"><br/><br/>\n);
  print qq(Upload a file with gene names :<br/>);
  print qq(<input type="file" name="geneNamesFile" /><br/>);
  print qq(<input type="submit" name="action" value="HGE Analyze File"><br/>\n);
  print qq(</form>);
  &printHtmlFooter(); 
} # sub anatomySobaInput

sub anatomySoba {
  my ($filesource) = @_;
  &printHtmlHeader(); 

  my ($var, $datatype)          = &getHtmlVar($query, 'datatype');
  ($var, my $showProcessTimes)  = &getHtmlVar($query, 'showProcessTimes');
  ($var, my $convertGeneToId)   = &getHtmlVar($query, 'convertGeneToId');
  ($var, my $calculateLcaNodes) = &getHtmlVar($query, 'calculateLcaNodes');
#   my ($var, $download)    = &getHtmlVar($query, 'download');
  unless ($datatype) { $datatype = 'anatomy'; }			# later will need to change based on different datatypes
#   my ($solr_url) = &getSolrUrl($focusTermId);
  my $solr_url = $base_solr_url . $datatype . '/';

  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Loading dictionary"); print qq($message<br/>\n); }

  my %dict;
#   my $dictFile = '/home/azurebrd/local/src/git/tissue_enrichment_tool_hypergeometric_test/dict.20151208';
  my $dictFile = '/home/raymond/local/src/git/tissue_enrichment_tool_hypergeometric_test/input/dictionary.csv';
  open (DICT, "<$dictFile") or die "Cannot open $dictFile : $!";
  while (my $line = <DICT>) {
    my (@stuff) = split/,/, $line;
    if ($stuff[0] =~ m/WBGene/) { $dict{$stuff[0]}++; }
  } # while (my $line = <DICT>)
  close (DICT) or die "Cannot close $dictFile : $!";

  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Getting altId mappings"); print qq($message<br/>\n); }

#   my %anatAltToId;
#   my $url = $solr_url . 'select?qt=standard&fl=id,alternate_id&version=2.2&wt=json&indent=on&rows=10000&fq=-is_obsolete:true&fq=document_category:"ontology_class"&q=alternate_id:*';
#   my $page_data   = get $url;                                           # get the URL
#   my $perl_scalar = $json->decode( $page_data );                        # get the solr data
#   my %jsonHash    = %$perl_scalar;
#   foreach my $doc (@{ $jsonHash{'response'}{'docs'} }) {
#     my $id = $$doc{'id'};
# # print "ID $id ID<br>";
#     foreach my $altid (@{ $$doc{'alternate_id'} }) { $anatAltToId{$altid} = $id; }
#   } # foreach my $doc (@{ $jsonHash{'response'}{'docs'} })

  my @annotAnatomyTerms;					# array of annotated terms to loop and do pairwise comparisons
  my $genelist = '';
  if ($filesource eq 'textarea') {
      ($var, $genelist) = &getHtmlVar($query, 'genelist'); }
    elsif ($filesource eq 'file') {
      my $upload_filehandle = $query->upload("geneNamesFile");
      while ( <$upload_filehandle> ) { $genelist .= $_; }
    }
  if ($genelist =~ m/,/) { $genelist =~ s/,/ /g; }

  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Getting postgres gene name mappings"); print qq($message<br/>\n); }
  my %geneNameToId; my %geneIdToName;
  if ($convertGeneToId) {
#     my ($geneNameToIdHashref, $geneIdToNameHashref) = &populateGeneNamesFromPostgres();
    my ($geneNameToIdHashref, $geneIdToNameHashref) = &populateGeneNamesFromFlatfile();
    %geneNameToId        = %$geneNameToIdHashref;
    %geneIdToName        = %$geneIdToNameHashref; }

#   my %geneAnatomy; my %anatomyGene;

  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Processing user genes for validity"); print qq($message<br/>\n); }
  my (@names) = split/\s+/, $genelist;
  unless ($convertGeneToId) { foreach my $name (@names) { $geneNameToId{lc($name)} = $name; $geneIdToName{$name} = $name; } }
  my @invalidGene; my @nodataGene; my @goodGene; 
  foreach my $name (@names) {
    my ($lcname) = lc($name);
    my $wbgene = '';
    if ($geneNameToId{$lcname}) {
        $wbgene = $geneNameToId{$lcname}; 
        if ($dict{$wbgene}) { push @goodGene, $wbgene; }
          else { push @nodataGene, $wbgene; } }
      else { push @invalidGene, $name; }
  } # foreach my $name (@names)

  my %anatomyTerms;
  if (scalar @goodGene > 0) {
      if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Processing hgf"); print qq($message<br/>\n); }
      my $tempfile = '/tmp/hyperGeo' . time;
      open (TMP, ">$tempfile") or die "Cannot open $tempfile : $!";
      print TMP qq(gene,reads\n);
      foreach my $gene (@goodGene) { print TMP qq($gene\n); }
      close (TMP) or die "Cannot close $tempfile : $!";
#       my $hyperData = `python /home/raymond/local/src/git/tissue_enrichment_tool_hypergeometric_test/src/hypergeometricTests.py /home/azurebrd/local/src/git/tissue_enrichment_tool_hypergeometric_test/genesets/WBPaper00013489_Ray_Enriched_WBbt:0006941_25`;
#       my $hyperData = `python /home/azurebrd/public_html/cgi-bin/hypergeometricTests.py /home/azurebrd/local/src/git/tissue_enrichment_tool_hypergeometric_test/genesets/WBPaper00013489_Ray_Enriched_WBbt:0006941_25`;
#       my $hyperData = `python /home/azurebrd/public_html/cgi-bin/hypergeometricTests.py $tempfile`;
      my $hyperData = `python /home/raymond/local/src/git/tissue_enrichment_tool_hypergeometric_test/src/hypergeometricTests.py $tempfile`;
      `rm $tempfile`;
      ($hyperData) = $hyperData =~ m/------------------------\n(.*?)------------------------/ms;
      if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Processing hgf results to display"); print qq($message<br/>\n); }
      my (@hyperData) = split/\n/, $hyperData;
      my $header = shift @hyperData;
      my (@header) = split/,/, $header;
      my $th = join"</th><th>", @header;
      if (scalar @hyperData > 0) {
          print qq(<table><tr><th>$th</th></tr>\n);
          my %sort;
          foreach my $line (@hyperData) {
            my ($name, $wbbt, $value) = $line =~ m/^(.*?)\((WBbt:.*?)\),([^,]*?)$/;
            my $url = 'http://www.wormbase.org/species/all/anatomy_term/' .$wbbt . '#013--10';
            $sort{$value}{$name} = $url;
          } # foreach my $line (@hyperData)
          foreach my $value (sort {$a<=>$b} keys %sort) {
            foreach my $name (sort keys %{ $sort{$value} }) {
              my $url  = $sort{$value}{$name};
              my $link = qq(<a href="$url" target="_blank">$name</a>);
#               print qq($name,$value<br/>);
              print qq(<tr><td>$link</td><td>$value</td></tr>);
            } # foreach my $name (sort keys %{ $sort{$value} })
          } # foreach my $value (sort keys %sort)
          print qq(</table>\n);
        }
        else { print qq(No significantly enriched cell/tissue has been found.<br/>\n); }
    }
    else { print qq(There are no genes with annotated data to generate results.<br/>\n); }
  print qq(<br/>);
  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Displaying gene sets"); print qq($message<br/>\n); }
  if (scalar @invalidGene > 0) {
    my $countInvalidGenes = scalar @invalidGene;
    print qq(Your list has $countInvalidGenes invalid WormBase genes :<br/>\n);
    print qq(<textarea rows="6" cols="80">);
    foreach my $gene (@invalidGene) { print qq($gene\n); } 
    print qq(</textarea><br/><br/>); }
  if (scalar @nodataGene > 0) {
    my $countNodataGenes = scalar @nodataGene;
    print qq(Your list has $countNodataGenes valid WormBase genes that have no annotated data or are excluded from testing :<br/>\n);
    print qq(<textarea rows="6" cols="80">);
    foreach my $gene (@nodataGene) { print qq($gene - $geneIdToName{$gene}\n); } 
    print qq(</textarea><br/><br/>); }
  if (scalar @goodGene > 0) {
    my $countGoodGenes = scalar @goodGene;
    print qq(Your list has $countGoodGenes valid WormBase genes included in statistical testing :<br/>\n);
    print qq(<textarea rows="6" cols="80">);
    foreach my $gene (@goodGene) { print qq($gene - $geneIdToName{$gene}\n); } 
    print qq(</textarea><br/><br/>); }
  print qq(<a href="http://mangolassi.caltech.edu/~azurebrd/cgi-bin/testing/amigo/getWithPost.cgi">perform another query</a><br/>);

  &printHtmlFooter(); 
# http://131.215.12.204/~azurebrd/cgi-bin/amigo.cgi?genelist=WBGene00010209+WBGene00010212+WBGene00010295+WBGene00015814+WBGene11111111+WBGene00000012+WBGene00000013+WBGene00000002+ZK512.6%0D%0A&action=anatomySoba
# http://131.215.12.204/~azurebrd/cgi-bin/amigo.cgi?action=anatomySobaInput
# WBGene00010209 WBGene00010212 WBGene00010295 WBGene00015814 WBGene11111111 WBGene00000012 WBGene00000013 WBGene00000002 ZK512.6 qwera 2z3zt daf-2
} # sub anatomySoba

sub anatomySobaOldGraph {
  &printHtmlHeader(); 

  my ($var, $datatype)          = &getHtmlVar($query, 'datatype');
  ($var, my $showProcessTimes)  = &getHtmlVar($query, 'showProcessTimes');
  ($var, my $convertGeneToId)   = &getHtmlVar($query, 'convertGeneToId');
  ($var, my $calculateLcaNodes) = &getHtmlVar($query, 'calculateLcaNodes');
#   my ($var, $download)    = &getHtmlVar($query, 'download');
  unless ($datatype) { $datatype = 'anatomy'; }			# later will need to change based on different datatypes
#   my ($solr_url) = &getSolrUrl($focusTermId);
  my $solr_url = $base_solr_url . $datatype . '/';

  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Getting altId mappings"); print qq($message<br/>\n); }

  my %anatAltToId;
  my $url = $solr_url . 'select?qt=standard&fl=id,alternate_id&version=2.2&wt=json&indent=on&rows=10000&fq=-is_obsolete:true&fq=document_category:"ontology_class"&q=alternate_id:*';
  my $page_data   = get $url;                                           # get the URL
  my $perl_scalar = $json->decode( $page_data );                        # get the solr data
  my %jsonHash    = %$perl_scalar;
  foreach my $doc (@{ $jsonHash{'response'}{'docs'} }) {
    my $id = $$doc{'id'};
# print "ID $id ID<br>";
    foreach my $altid (@{ $$doc{'alternate_id'} }) { $anatAltToId{$altid} = $id; }
  } # foreach my $doc (@{ $jsonHash{'response'}{'docs'} })

  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Getting postgres gene name mappings"); print qq($message<br/>\n); }
  my @annotAnatomyTerms;					# array of annotated terms to loop and do pairwise comparisons
  my ($var, $genelist) = &getHtmlVar($query, 'genelist');
  my %geneNameToId; my %geneIdToName;
  if ($convertGeneToId) {
    my ($geneNameToIdHashref, $geneIdToNameHashref) = &populateGeneNamesFromPostgres();
    %geneNameToId        = %$geneNameToIdHashref;
    %geneIdToName        = %$geneIdToNameHashref; }

  if ($showProcessTimes) { my ($message) = &getDiffTime($startTime, $prevTime, "Getting first solr query"); print qq($message<br/>\n); }
#   my $url = $base_solr_url . 'anatomy/select?qt=standard&indent=on&wt=json&version=2.2&fl=id,annotation_class_list,regulates_closure&start=0&rows=100000&q=document_category:bioentity&sort=id%20desc&fq=source:%22WB%22&fq=-qualifier:%22not%22';
#   my $url = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&fl=id,annotation_class_list&start=0&rows=100000&q=document_category:bioentity&sort=id%20desc&fq=source:%22WB%22&fq=-qualifier:%22not%22';
  my $url = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&fl=id,bioentity_label,annotation_class_list,regulates_closure&start=0&rows=100000&q=document_category:bioentity&sort=id%20desc&fq=source:%22WB%22&fq=-qualifier:%22not%22';
  my %dataGenes;
  print qq(URL $url URL<br/><br/>);
  my $page_data   = get $url;                                           # get the URL
  my $perl_scalar = $json->decode( $page_data );                        # get the solr data
  my %jsonHash    = %$perl_scalar;
  my %geneAnatomy; my %anatomyGene;
  my %annotationCounts;							# get annotation counts of genes that regulate anatomy term from user gene list

  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Processing first solr query for regulates and annotated"); print qq($message<br/>\n); }
  foreach my $doc (@{ $jsonHash{'response'}{'docs'} }) {
    my $id = $$doc{'id'};
# print "ID $id ID<br>";
    my ($wbgene) = $id =~ m/(WBGene\d+)/;
    $dataGenes{$wbgene}++;
    foreach my $anatomy (@{ $$doc{'annotation_class_list'} }) { 
      if ($anatAltToId{$anatomy}) { $anatomy =  $anatAltToId{$anatomy}; }
      $geneAnatomy{annotated}{$wbgene}{$anatomy}++; }
    foreach my $anatomy (@{ $$doc{'regulates_closure'} }) {
      if ($anatAltToId{$anatomy}) { $anatomy =  $anatAltToId{$anatomy}; }
      $geneAnatomy{regulates}{$wbgene}{$anatomy}++; }
  } # foreach my $doc (@{ $jsonHash{'response'}{'docs'} })

  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Processing user genes for validity"); print qq($message<br/>\n); }
  my (@names) = split/\s+/, $genelist;
  unless ($convertGeneToId) { foreach my $name (@names) { $geneNameToId{lc($name)} = $name; $geneIdToName{$name} = $name; } }
  my @invalidGene; my @nodataGene; my @goodGene; 
  foreach my $name (@names) {
    my ($lcname) = lc($name);
    my $wbgene = '';
    if ($geneNameToId{$lcname}) {
        $wbgene = $geneNameToId{$lcname}; 
        if ($dataGenes{$wbgene}) { push @goodGene, $wbgene; }
          else { push @nodataGene, $wbgene; } }
      else { push @invalidGene, $name; }
  } # foreach my $name (@names)
  if (scalar @invalidGene > 0) {
    print qq(These are not valid WormBase genes :<br/>\n);
    foreach my $gene (@invalidGene) { print qq(invalid Gene : $gene<br/>\n); } 
    print qq(<br\/>\n); }
  if (scalar @nodataGene > 0) {
    print qq(These are valid WormBase genes for which we have no data :<br/>\n);
    foreach my $gene (@nodataGene) { print qq(no data Gene : $gene - $geneIdToName{$gene}<br/>\n); } 
    print qq(<br\/>\n); }
  my %anatomyTerms;
  if (scalar @goodGene > 0) {
      print qq(These genes are being used to generate data :<br/>\n);
      foreach my $gene (@goodGene) { 
        print qq(data Gene : $gene - $geneIdToName{$gene}<br/>\n);
        foreach my $anatomy (sort keys %{ $geneAnatomy{regulates}{$gene} }) {
          $anatomyGene{regulates}{$anatomy}{$gene}++; }
        foreach my $anatomy (sort keys %{ $geneAnatomy{annotated}{$gene} }) {
          $anatomyGene{annotated}{$anatomy}{$gene}++; 
          $anatomyTerms{$anatomy}++; }
      }
      print qq(<br\/>\n); }
    else { print qq(There are no genes with data to generate data<br/>\n); }

  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Quick initializing of stuff"); print qq($message<br/>\n); }
  my $rootId = 'WBbt:0000100';
  my $rootId_placeholder = $rootId;
  $rootId_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
#   my $maxAnyCount  = $annotationCounts{$rootId}{'any'};
  my $maxAnyCount = scalar (@goodGene);

  my $direction = 'back'; my $style = 'solid'; my $edgecolor = 'black';                      # graph arror direction and style and color
  my $nodecolor = 'blue'; my $nodeAnnotatedColor = 'red'; my $nodeNormalColor = 'blue'; my $nodeAnnotatedStyle = 'solid'; my $nodeNormalStyle = 'dashed';
  my $hiddennodecolor = 'white';
  my $nodeWidth              = 1;
  my $weightedNodeWidth      = 1;
  my $unweightedNodeWidth    = 1;
  my $nodeFontSize           = 10;
  my $weightedNodeFontSize   = 10;
  my $unweightedNodeFontSize = 10;

  my (@annotAnatomyTerms) = sort keys %anatomyTerms;

  my %nodeLabels;
#   my %nodeHgLabels;
  my %edgesPtc;								# edges from parent to child
  foreach my $anatomyId (sort keys %anatomyTerms) {
  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "solr query and data extraction for $anatomyId"); print qq($message<br/>\n); }
#     my $anatomy_solr_url = $solr_url . 'select?qt=standard&fl=regulates_transitivity_graph_json,topology_graph_json,annotation_class_label&version=2.2&wt=json&indent=on&rows=1&fq=-is_obsolete:true&fq=document_category:%22ontology_class%22&q=id:%22' . $anatomyId . '%22';
    my $anatomy_solr_url = $solr_url . 'select?qt=standard&fl=id,regulates_transitivity_graph_json,topology_graph_json&version=2.2&wt=json&indent=on&rows=1&fq=-is_obsolete:true&fq=document_category:%22ontology_class%22&q=id:%22' . $anatomyId . '%22';
#     print qq(Processing $anatomyId <a href="$anatomy_solr_url">$anatomy_solr_url</a><br>\n);


    my $page_data   = get $anatomy_solr_url;                                           # get the URL
    my $perl_scalar = $json->decode( $page_data );                        # get the solr data
    my %jsonHash    = %$perl_scalar;
    unless ( $jsonHash{"response"}{"docs"}[0]{"id"} ) {			# some anatomy terms are actually alternate IDs
      my $alternate_solr_url = $solr_url . 'select?qt=standard&fl=id,regulates_transitivity_graph_json,topology_graph_json&version=2.2&wt=json&indent=on&rows=1&fq=-is_obsolete:true&fq=document_category:%22ontology_class%22&q=alternate_id:%22' . $anatomyId . '%22';
#       print qq(Processing Alternate $anatomyId <a href="$alternate_solr_url">$alternate_solr_url</a><br>\n);
      $page_data   = get $alternate_solr_url;                                           # get the URL
      $perl_scalar = $json->decode( $page_data );                        # get the solr data
      %jsonHash    = %$perl_scalar; }

#     my $gviz        = GraphViz2->new(concentrate => 'concentrate');      # generate graphviz for main markup
    my $transHashref = ''; my %transHash; my @nodes;
    my %transNodes;							# track transitivity nodes as nodes to keep from topology data
    if ( $jsonHash{"response"}{"docs"}[0]{"regulates_transitivity_graph_json"} ) {
      $transHashref = $json->decode( $jsonHash{"response"}{"docs"}[0]{"regulates_transitivity_graph_json"} ); 
      %transHash = %$transHashref; 
      (@nodes)   = @{ $transHash{"nodes"} };
      for my $index (0 .. @nodes) { if ($nodes[$index]{'id'}) { my $id  = $nodes[$index]{'id'};  $transNodes{$id}++; } }
    }

#     my $anatomyName = $json->decode( $jsonHash{"response"}{"docs"}[0]{"annotation_class_label"} );
    my $topoHashref = ''; my %topoHash; my @edges;
    if ($jsonHash{"response"}{"docs"}[0]{"topology_graph_json"}) {
      $topoHashref = $json->decode( $jsonHash{"response"}{"docs"}[0]{"topology_graph_json"} );
      %topoHash = %$topoHashref;
      (@edges)   = @{ $topoHash{"edges"} }; 
      (@nodes)   = @{ $topoHash{"nodes"} };
    }
    for my $index (0 .. @edges) {                                       # for each edge, add to graph
      my ($sub, $obj, $pred) = ('', '', '');                            # subject object predicate from topology_graph_json
      if ($edges[$index]{'sub'}) {  $sub  = $edges[$index]{'sub'};  }
      if ($edges[$index]{'obj'}) {  $obj  = $edges[$index]{'obj'};  }
      next unless ( ($transNodes{$sub}) && ($transNodes{$obj}) );
      if ($edges[$index]{'pred'}) { $pred = $edges[$index]{'pred'}; }
      my $direction = 'back'; my $style = 'solid';                      # graph arror direction and style
      if ($sub && $obj && $pred) {                                      # if subject + object + predicate
        my $color = 'black'; 
        $edgesAll{$anatomyId}{$sub}{$obj}++;				# for an annotated term's edges, each child to its parents
        $edgesPtc{$obj}{$sub}++;					# any existing edge, parent to child
      } # if ($sub && $obj && $pred)
    } # for my $index (0 .. @edges)
    for my $index (0 .. @nodes) {                                       # for each node, add to graph
      my ($id, $lbl) = ('', '');                                        # id and label
      if ($nodes[$index]{'id'}) {  $id  = $nodes[$index]{'id'};  }
      if ($nodes[$index]{'lbl'}) { $lbl = $nodes[$index]{'lbl'}; }
      next unless ($transNodes{$id});
      $lbl =~ s/ /<br\/>/g;                                                # replace spaces with html linebreaks in graph for more-square boxes
      $annotationCounts{$id} = scalar keys %{ $anatomyGene{regulates}{$id} };
      my %geneRegulatesNames; foreach my $gene (keys %{ $anatomyGene{regulates}{$id} }) { $geneRegulatesNames{$geneIdToName{$gene}}++; }
#       my $genes = join"<br/>", sort keys %{ $anatomyGene{regulates}{$id} };
      my $genes = join"<br/>", sort keys %geneRegulatesNames;
      $lbl = $id . '<br/>' . $lbl . '<br/>' . $genes;
      my $label = "$lbl";                                          # node label should have full id, not stripped of :, which is required for edge title text
# print "ID $id LBL $lbl E<br/>\n";
      my $hglabel = "$lbl";
#       if ($annotationCounts{$id}) { 					# if there are annotation counts to variation and/or rnai, add them to the box
#         my @annotCounts;
#         foreach my $evidenceType (sort keys %{ $annotationCounts{$id} }) {
#           next if ($evidenceType eq 'any');				# skip 'any', only used for relative size to max value
#           push @annotCounts, qq($annotationCounts{$id}{$evidenceType} $evidenceType); } 
#         my $annotCounts = join"; ", @annotCounts;
#         $hglabel = qq($label<br\/>$annotCounts);				# add html line break and annotation counts to the label
#         $label = qq(LINEBREAK<br\/>$label<br\/><font color="transparent">$annotCounts<\/font>);				# add html line break and annotation counts to the label
#       }
      $nodeLabels{$id}   = $label;
#       $nodeHgLabels{$id} = $hglabel;
      if ($id && $lbl) { $nodesAll{$anatomyId}{$id} = $label; }
    } # for my $index (0 .. @nodes)                                       # for each node, add to graph
  } # foreach my $anatomyId (sort keys %anatomyTerms)

  my $annotAnatomyTerms = join", ", sort keys %anatomyTerms;
  print qq(Annotated anatomy terms for gene set : $annotAnatomyTerms<br/>\n);

  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Starting graphviz graph"); print qq($message<br/>\n); }
  my %allLca;								# all nodes that are LCA to any pair of annotated terms
#   my @dot_nodes; my %dot_edges;
  my $gviz_lca_unweighted = GraphViz2->new(concentrate => 'concentrate', logger => $logger, graph => { ranksep => '.02', nodesep => '.1', rankdir => 'LR', overlap => 'true' }, node => { margin => '0' } );      # generate graphviz for main markup, rankdir horizontal
  my $gviz_lca_weighted = GraphViz2->new(concentrate => 'concentrate', logger => $logger, graph => { ranksep => '.02', nodesep => '.1', rankdir => 'LR', overlap => 'true' }, node => { margin => '0' } );      # generate graphviz for main markup, rankdir horizontal

  $weightedNodeWidth = &calcNodeWidth($annotationCounts{$rootId}/4, $maxAnyCount);
  $weightedNodeFontSize = $weightedNodeWidth / 1.5 * 20;

  my $xlabel = $nodeLabels{$rootId};
  $xlabel    = qq(<b>$xlabel</b>);
#   my $xhglabel = $nodeHgLabels{$rootId};
#   $xhglabel    = qq(<b>$xhglabel</b>);
#   $nodeFontSize = $nodeWidth / 1.5 * 20;
  $gviz_lca_unweighted->add_node(name => "$rootId_placeholder", label => "<$xlabel>", xlabel => "", width => "$unweightedNodeWidth", height => "$unweightedNodeWidth", fixedsize => "shape", shape => "box", fontsize => "$unweightedNodeFontSize", style => "$nodeNormalStyle", color => "$nodecolor", URL => "$url");
  $gviz_lca_weighted->add_node(  name => "$rootId_placeholder", label => "<$xlabel>", xlabel => "", width => "$weightedNodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$weightedNodeFontSize", style => "$nodeNormalStyle", color => "$nodecolor", URL => "$url");


  if ($calculateLcaNodes eq 'calculateLcaNodes') {
    my $ph1;
    while (@annotAnatomyTerms) {
      $ph1 = shift @annotAnatomyTerms;					# compare each annotated term node to all other annotated term nodes
#   if ($ph1 =~ m/0005260/) { print qq(BAD $ph1 BAD<br>\n); next; }
      if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Processing $ph1"); print qq($message<br/>\n); }
      my $ph1_placeholder = $ph1;
      $ph1_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
      $url = "http://www.wormbase.org/species/all/anatomy_term/$ph1";                              # URL to link to wormbase page for object
#       $nodeWidth = &calcNodeWidth($annotationCounts{$ph1}, $maxAnyCount);
#       $nodeFontSize = $nodeWidth / 1.5 * 20;
      my $nodeSizeCutoffLabel = .5;
      my $fontcolor = 'black';
      my $xlabel = 'badTerm';
      if ($nodeLabels{$ph1}) { $xlabel = $nodeLabels{$ph1}; }
      $xlabel = qq(<b>$xlabel</b>);
#       my $xhglabel = $nodeHgLabels{$ph1}; 
#       $xhglabel = qq(<b>$xhglabel</b>);
#   if ($ph1 =~ m/0005260/) { print qq(BAD $ph1 LABEL $xlabel E<br>\n); next; }
      if ($nodeWidth < $nodeSizeCutoffLabel) { 
        $fontcolor = 'transparent'; }	# not actually transparent, goes to #fffffe, later svg global replace to rgba(0,0,0,0.01) for very low opacity
      $weightedNodeWidth = &calcNodeWidth($annotationCounts{$ph1}/4, $maxAnyCount);
      $weightedNodeFontSize = $weightedNodeWidth / 1.5 * 20;
      $gviz_lca_unweighted->add_node(name => "$ph1_placeholder", label => "<$xlabel>", xlabel => "", width => "$unweightedNodeWidth", height => "$unweightedNodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$unweightedNodeFontSize", style => "$nodeAnnotatedStyle", color => "$nodeAnnotatedColor", URL => "$url");
      $gviz_lca_weighted->add_node(  name => "$ph1_placeholder", label => "<$xlabel>", xlabel => "", width => "$weightedNodeWidth", height => "$weightedNodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$weightedNodeFontSize", style => "$nodeAnnotatedStyle", color => "$nodeAnnotatedColor", URL => "$url");
      my $url = 'http://www.wormbase.org/species/all/anatomy_term/' . $ph1 . '#03--10';
#       push @dot_nodes, qq($ph1_placeholder [width="$nodeWidth" shape="circle" color="$nodeAnnotatedColor" fontcolor="$fontcolor" fixedsize=true label=<$xlabel> URL="$url" ]);
      foreach my $ph2 (@annotAnatomyTerms) {				# compare each annotated term node to all other annotated term nodes
        if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Processing $ph1 against $ph2"); print qq($message<br/>\n); }
        my $ph2_placeholder = $ph2;
        $ph2_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
        my $lcaHashref = &calculateLCA($ph1, $ph2);
        my %lca = %$lcaHashref;
        foreach my $lca (sort keys %lca) {
          $url = "http://www.wormbase.org/species/all/anatomy_term/$lca";                              # URL to link to wormbase page for object
          $allLca{$lca}++;
          my $lca_placeholder = $lca;
          $lca_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
          unless ($anatomyTerms{$lca}) { 					# only add lca nodes that are not annotated terms
            $fontcolor = 'black';
            $xlabel = 'badTerm';
            if ($nodeLabels{$lca}) { $xlabel = $nodeLabels{$lca}; }
            $xlabel = qq(<b>$xlabel</b>);
#             $xhglabel = $nodeHgLabels{$lca}; 
#             $xhglabel = qq(<b>$xhglabel</b>);
            if ($nodeWidth < $nodeSizeCutoffLabel) {
              $fontcolor = 'transparent'; }
#             $nodeFontSize = $nodeWidth / 1.5 * 20;
            $weightedNodeWidth = &calcNodeWidth($annotationCounts{$lca}/4, $maxAnyCount);
            $weightedNodeFontSize = $weightedNodeWidth / 1.5 * 20;
            my $url = 'http://www.wormbase.org/species/all/anatomy_term/' . $lca . '#03--10';
            if ($lca_placeholder ne $rootId_placeholder) {		# don't re-create root node if it happens to be lca
              $gviz_lca_unweighted->add_node(name => "$lca_placeholder", label => "<$xlabel>", xlabel => "", width => "$unweightedNodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$unweightedNodeFontSize", style => "$nodeNormalStyle", color => "$nodecolor", URL => "$url");
              $gviz_lca_weighted->add_node(  name => "$lca_placeholder", label => "<$xlabel>", xlabel => "", width => "$weightedNodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$weightedNodeFontSize", style => "$nodeNormalStyle", color => "$nodecolor", URL => "$url");
            }
#             push @dot_nodes, qq($lca_placeholder [width="$nodeWidth" shape="circle" color="$nodecolor" fontcolor="$fontcolor" fixedsize=true label=<$xlabel> URL="$url"]);
          }
        } # foreach my $lca (sort keys %lca)
      } # foreach my $ph2 (@annotAnatomyTerms)				# compare each annotated term node to all other annotated term nodes
    } # while (@annotAnatomyTerms)

    if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Process edges"); print qq($message<br/>\n); }
    my %edgesLca;								# edges that exist in graph generated from annoated terms + lca terms + root
    my @parentNodes = ($rootId);						# nodes that are parents, at first root, later any nodes that should be in graph
    while (@parentNodes) {						# while there are parent nodes, go through them
      my $parent = shift @parentNodes;					# take a parent
      my %edgesPtcCopy = %{ dclone(\%edgesPtc) };				# make a temp copy since edges will be getting deleted per parent
#   print "PARENT $parent<br>";
      while (scalar keys %{ $edgesPtcCopy{$parent} } > 0) {		# while parent has children
        foreach my $child (sort keys %{ $edgesPtcCopy{$parent} }) {	# each child of parent
          if ($allLca{$child} || $anatomyTerms{$child}) {			# good node, keep edge when child is an lca or annotated term
#   print "P $parent C $child GOOD CHILD<br>\n";
              delete $edgesPtcCopy{$parent}{$child};			# remove from %edgesPtc, does not need to be checked further
              push @parentNodes, $child;					# child is a good node, add to parent list to check its children
              $edgesLca{$parent}{$child}++; }				# add parent-child edge to final graph
            else {							# bad node, remove and reconnect edges
#   if ($debugmore eq '1') { print "P $parent C $child REMOVE CHILD<br>\n"; }
              delete $edgesPtcCopy{$parent}{$child};			# remove parent-child edge
              foreach my $grandchild (sort keys %{ $edgesPtcCopy{$child} }) {	# take each grandchild of child
#   if ($debugmore eq '1') { print "P $parent C $child GC $grandchild CONNECT TO GC<br>\n"; }
                delete $edgesPtcCopy{$child}{$grandchild};		# remove child-grandchild edge
                $edgesPtcCopy{$parent}{$grandchild}++; } }		# make replacement edge between parent and grandchild
        } # foreach my $child (sort keys %{ $edgesPtcCopy{$parent} })
      } # while (scalar keys %{ $edgesPtcCopy{$parent} } > 0)
    } # while (@parentNodes)
    if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Add edges to graph"); print qq($message<br/>\n); }
    foreach my $parent (sort keys %edgesLca) {
      my $parent_placeholder = $parent;
      $parent_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
      foreach my $child (sort keys %{ $edgesLca{$parent} }) {
        my $child_placeholder = $child;
        $child_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
#   print "P $parent C $child EPTC<br>\n";
#         $dot_edges{$child_placeholder}{$parent_placeholder}++;
        $gviz_lca_unweighted->add_edge(from => "$parent_placeholder", to => "$child_placeholder", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
        $gviz_lca_weighted->add_edge(  from => "$parent_placeholder", to => "$child_placeholder", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
      } # foreach my $child (sort keys %{ $edgesLca{$parent} })
    } # foreach my $parent (sort keys %edgesLca)

  } else {		# show all edges and all nodes
    if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Add edges to graph"); print qq($message<br/>\n); }
    foreach my $parent (sort keys %edgesPtc) {
      my $parent_placeholder = $parent;
      $parent_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
      foreach my $child (sort keys %{ $edgesPtc{$parent} }) {
        my $child_placeholder = $child;
        $child_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
        $gviz_lca_unweighted->add_edge(from => "$parent_placeholder", to => "$child_placeholder", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
        $gviz_lca_weighted->add_edge(  from => "$parent_placeholder", to => "$child_placeholder", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
      } # foreach my $child (sort keys %{ $edgesPtc{$parent} })
    } # foreach my $parent (sort keys %edgesPtc)
    if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Add nodes to graph"); print qq($message<br/>\n); }
    foreach my $term (sort keys %nodeLabels) {
      my $term_placeholder = $term;
      $term_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
      $url = "http://www.wormbase.org/species/all/anatomy_term/$term";                              # URL to link to wormbase page for object
      my $nodeSizeCutoffLabel = .5;
      my $fontcolor = 'black';
      my $xlabel = 'badTerm';
      if ($nodeLabels{$term}) { $xlabel = $nodeLabels{$term}; }
      $xlabel = qq(<b>$xlabel</b>);
      if ($nodeWidth < $nodeSizeCutoffLabel) { 
        $fontcolor = 'transparent'; }	# not actually transparent, goes to #fffffe, later svg global replace to rgba(0,0,0,0.01) for very low opacity
      $weightedNodeWidth    = &calcNodeWidth($annotationCounts{$term}/4, $maxAnyCount);
      $weightedNodeFontSize = $weightedNodeWidth / 1.5 * 20;
      if ($anatomyTerms{$term}) {						# annotated terms
        $gviz_lca_unweighted->add_node(name => "$term_placeholder", label => "<$xlabel>", xlabel => "", width => "$unweightedNodeWidth", height => "$unweightedNodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$unweightedNodeFontSize", style => "$nodeAnnotatedStyle", color => "$nodeAnnotatedColor", URL => "$url");
        $gviz_lca_weighted->add_node(  name => "$term_placeholder", label => "<$xlabel>", xlabel => "", width => "$weightedNodeWidth", height => "$weightedNodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$weightedNodeFontSize", style => "$nodeAnnotatedStyle", color => "$nodeAnnotatedColor", URL => "$url");
      } else {									# regular terms
        $gviz_lca_unweighted->add_node(name => "$term_placeholder", label => "<$xlabel>", xlabel => "", width => "$unweightedNodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$unweightedNodeFontSize", style => "$nodeNormalStyle", color => "$nodecolor", URL => "$url");
        $gviz_lca_weighted->add_node(  name => "$term_placeholder", label => "<$xlabel>", xlabel => "", width => "$weightedNodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$weightedNodeFontSize", style => "$nodeNormalStyle", color => "$nodecolor", URL => "$url");
      }
    } # foreach my $term (sort keys %nodeLabels)
  } # else # if ($calculateLcaNodes eq 'calculateLcaNodes') 

  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Generate graph"); print qq($message<br/>\n); }
  my $lca_unweighted_output = '';
  $gviz_lca_unweighted->run();                                   # generate graph as svg
  my $svgGenerated = $gviz_lca_unweighted->dot_output();
  my ($svgMarkup) = &svgCleanup($svgGenerated, 'from_gene_list');
  ($svgMarkup) =~ s/<svg/<svg id="svg_unweighted"/;             		# give an id to the .svg
  $lca_unweighted_output .= "$svgMarkup";

#   print $lca_unweighted_output;				# uncomment to show unweighted graph

  my $lca_weighted_output = '';
  $gviz_lca_weighted->run();                                   # generate graph as svg
  my $svgGenerated = $gviz_lca_weighted->dot_output();
  my ($svgMarkup) = &svgCleanup($svgGenerated, 'from_gene_list');
  ($svgMarkup) =~ s/<svg/<svg id="svg_unweighted"/;             		# give an id to the .svg
  $lca_weighted_output .= "$svgMarkup";

  print $lca_weighted_output;


  print qq(<br>\n);
  if ($showProcessTimes) { (my $message) = &getDiffTime($startTime, $prevTime, "Done"); print qq($message<br/>\n); }
  &printHtmlFooter(); 
# WBGene00010209 WBGene00010212 WBGene00010295 WBGene00015814 WBGene11111111 ZK512.6 
} # sub anatomySobaOldGraph

sub populateGeneNamesFromFlatfile {
  my %geneNameToId; my %geneIdToName;
  my $infile = '/home/azurebrd/cron/gin_names/gin_names.txt';
  open (IN, "<$infile") or die "Cannot open $infile : $!";
  while (my $line = <IN>) {
    chomp $line;
    my ($id, $name, $primary) = split/\t/, $line;
    if ($primary eq 'primary') { $geneIdToName{$id}     = $name; }
    my ($lcname)           = lc($name);
    $geneNameToId{$lcname} = $id; }
  close (IN) or die "Cannot close $infile : $!";
  return (\%geneNameToId, \%geneIdToName);
} # sub populateGeneNamesFromFlatfile

sub populateGeneNamesFromPostgres {
  my %geneNameToId; my %geneIdToName;
#   my @tables = qw( gin_locus );
  my @tables = qw( gin_wbgene gin_seqname gin_synonyms gin_locus );
#   my @tables = qw( gin_seqname gin_synonyms gin_locus );
  foreach my $table (@tables) {
    my $result = $dbh->prepare( "SELECT * FROM $table;" );
    $result->execute();
    while (my @row = $result->fetchrow()) {
      my $id                 = "WBGene" . $row[0];
      my $name               = $row[1];
      my ($lcname)           = lc($name);
      $geneIdToName{$id}     = $name;
      $geneNameToId{$lcname} = $id; } }
  return (\%geneNameToId, \%geneIdToName);
} # sub populateGeneNamesFromPostgres

sub calculateNodesAndEdges {
  my ($focusTermId, $datatype) = @_;
  unless ($datatype) { $datatype = 'phenotype'; }			# later will need to change based on different datatypes
  my $toReturn = '';
#   my ($solr_url) = &getSolrUrl($focusTermId);
  my $solr_url = $base_solr_url . 'phenotype/';
    # link 1, from wbgene get wbphenotypes from   "grouped":{ "annotation_class":{ "matches":12, "ngroups":4, "groups":[{ "groupValue":"WBPhenotype:0000674", # }]}}

  my $rootId = 'WBPhenotype:0000886';
  if ($datatype eq 'phenotype') { $rootId = 'WBPhenotype:0000886'; }

  my %allLca;								# all nodes that are LCA to any pair of annotated terms
  my %nodes;
  my %edgesPtc;								# edges from parent to child

  my $nodeWidth    = 1;
  my $weightedNodeWidth    = 1;
  my $unweightedNodeWidth  = 1;
  my %annotationCounts;							# get annotation counts from evidence type
  my %phenotypes; my @annotPhenotypes;					# array of annotated terms to loop and do pairwise comparisons
  my $annotation_count_solr_url = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&rows=100000&fl=regulates_closure,id,annotation_class&q=document_category:annotation&fq=-qualifier:%22not%22&fq=bioentity:%22WB:' . $focusTermId . '%22';
  my $page_data   = get $annotation_count_solr_url;                                           # get the URL
  my $perl_scalar = $json->decode( $page_data );                        # get the solr data
  my %jsonHash    = %$perl_scalar;
  foreach my $doc (@{ $jsonHash{'response'}{'docs'} }) {
      my $phenotype = $$doc{'annotation_class'};
      $phenotypes{$phenotype}++;
      my $id = $$doc{'id'};
      my $varCount = 0; my $rnaiCount = 0;
      if ($id =~ m/WB:WBVar\d+/) {  my (@wbvar)  = $id =~ m/(WB:WBVar\d+)/g;  $varCount  = scalar @wbvar;  }
      if ($id =~ m/WB:WBRNAi\d+/) { my (@wbrnai) = $id =~ m/(WB:WBRNAi\d+)/g; $rnaiCount = scalar @wbrnai; }
      foreach my $phenotype (@{ $$doc{'regulates_closure'} }) {
        if ($varCount) {  for (1 .. $varCount) {  $annotationCounts{$phenotype}{'any'}++; $annotationCounts{$phenotype}{'Allele'}++; 
                                                  $nodes{$phenotype}{'counts'}{'any'}++;  $nodes{$phenotype}{'counts'}{'Allele'}++;  } }
        if ($rnaiCount) { for (1 .. $rnaiCount) { $annotationCounts{$phenotype}{'any'}++; $annotationCounts{$phenotype}{'RNAi'}++;     
                                                  $nodes{$phenotype}{'counts'}{'any'}++;  $nodes{$phenotype}{'counts'}{'RNAi'}++;    } }
      }
  }
  foreach my $phenotypeId (sort keys %phenotypes) {
    push @annotPhenotypes, $phenotypeId;
    my $phenotype_solr_url = $solr_url . 'select?qt=standard&fl=regulates_transitivity_graph_json,topology_graph_json&version=2.2&wt=json&indent=on&rows=1&fq=-is_obsolete:true&fq=document_category:%22ontology_class%22&q=id:%22' . $phenotypeId . '%22';

    my $page_data   = get $phenotype_solr_url;                                           # get the URL
    my $perl_scalar = $json->decode( $page_data );                        # get the solr data
    my %jsonHash    = %$perl_scalar;
    my $gviz        = GraphViz2->new(concentrate => 'concentrate');      # generate graphviz for main markup
    my $transHashref = $json->decode( $jsonHash{"response"}{"docs"}[0]{"regulates_transitivity_graph_json"} );
    my %transHash = %$transHashref;
    my (@nodes)   = @{ $transHash{"nodes"} };
    my %transNodes;							# track transitivity nodes as nodes to keep from topology data
    for my $index (0 .. @nodes) { if ($nodes[$index]{'id'}) { my $id  = $nodes[$index]{'id'};  $transNodes{$id}++; } }

    my $topoHashref = $json->decode( $jsonHash{"response"}{"docs"}[0]{"topology_graph_json"} );
    my %topoHash = %$topoHashref;
    my (@edges)   = @{ $topoHash{"edges"} };
    for my $index (0 .. @edges) {                                       # for each edge, add to graph
      my ($sub, $obj, $pred) = ('', '', '');                            # subject object predicate from topology_graph_json
      if ($edges[$index]{'sub'}) {  $sub  = $edges[$index]{'sub'};  }
      if ($edges[$index]{'obj'}) {  $obj  = $edges[$index]{'obj'};  }
      next unless ( ($transNodes{$sub}) && ($transNodes{$obj}) );
      if ($edges[$index]{'pred'}) { $pred = $edges[$index]{'pred'}; }
      my $direction = 'back'; my $style = 'solid';                      # graph arror direction and style
      if ($sub && $obj && $pred) {                                      # if subject + object + predicate
        $edgesAll{$phenotypeId}{$sub}{$obj}++;				# for an annotated term's edges, each child to its parents
        $edgesPtc{$obj}{$sub}++;					# any existing edge, parent to child
      } # if ($sub && $obj && $pred)
    } # for my $index (0 .. @edges)
    my (@nodes)   = @{ $topoHash{"nodes"} };
    for my $index (0 .. @nodes) {                                       # for each node, add to graph
      my ($id, $lbl) = ('', '');                                        # id and label
      if ($nodes[$index]{'id'}) {  $id  = $nodes[$index]{'id'};  }
      if ($nodes[$index]{'lbl'}) { $lbl = $nodes[$index]{'lbl'}; }
      next unless ($id);
      $nodes{$id}{label} = $lbl;
      next unless ($transNodes{$id});
#       $lbl =~ s/ /<br\/>/g;                                                # replace spaces with html linebreaks in graph for more-square boxes
      my $label = "$lbl";                                          # node label should have full id, not stripped of :, which is required for edge title text
      if ($annotationCounts{$id}) { 					# if there are annotation counts to variation and/or rnai, add them to the box
        my @annotCounts;
        foreach my $evidenceType (sort keys %{ $annotationCounts{$id} }) {
          next if ($evidenceType eq 'any');				# skip 'any', only used for relative size to max value
          push @annotCounts, qq($annotationCounts{$id}{$evidenceType} $evidenceType); }
        my $annotCounts = join"; ", @annotCounts;
        $label = qq(LINEBREAK<br\/>$label<br\/><font color="transparent">$annotCounts<\/font>);				# add html line break and annotation counts to the label
      }
      if ($id && $lbl) { 
        $nodesAll{$phenotypeId}{$id} = $lbl;
      }
    }
  } # foreach my $phenotype (sort keys %phenotypes)

  while (@annotPhenotypes) {
    my $ph1 = shift @annotPhenotypes;					# compare each annotated term node to all other annotated term nodes
    my $url = "http://www.wormbase.org/species/all/phenotype/$ph1";                              # URL to link to wormbase page for object
    my $xlabel = $ph1; 	# FIX
    $nodes{$ph1}{annot}++;
    foreach my $ph2 (@annotPhenotypes) {				# compare each annotated term node to all other annotated term nodes
      my $lcaHashref = &calculateLCA($ph1, $ph2);
      my %lca = %$lcaHashref;
      foreach my $lca (sort keys %lca) {
        $url = "http://www.wormbase.org/species/all/phenotype/$lca";                              # URL to link to wormbase page for object
        $allLca{$lca}++;
        unless ($phenotypes{$lca}) { 					# only add lca nodes that are not annotated terms
          $xlabel = $lca; 					# FIX
          $nodes{$lca}{lca}++;
        }
      } # foreach my $lca (sort keys %lca)
    } # foreach my $ph2 (@annotPhenotypes)				# compare each annotated term node to all other annotated term nodes
  } # while (@annotPhenotypes)

  my %edgesLca;								# edges that exist in graph generated from annoated terms + lca terms + root
  my @parentNodes = ($rootId);						# nodes that are parents, at first root, later any nodes that should be in graph
  while (@parentNodes) {						# while there are parent nodes, go through them
    my $parent = shift @parentNodes;					# take a parent
    my %edgesPtcCopy = %{ dclone(\%edgesPtc) };				# make a temp copy since edges will be getting deleted per parent
    while (scalar keys %{ $edgesPtcCopy{$parent} } > 0) {		# while parent has children
      foreach my $child (sort keys %{ $edgesPtcCopy{$parent} }) {	# each child of parent
        if ($allLca{$child} || $phenotypes{$child}) { 			# good node, keep edge when child is an lca or annotated term
            delete $edgesPtcCopy{$parent}{$child};			# remove from %edgesPtc, does not need to be checked further
            push @parentNodes, $child;					# child is a good node, add to parent list to check its children
            $edgesLca{$parent}{$child}++; }				# add parent-child edge to final graph
          else {							# bad node, remove and reconnect edges
            delete $edgesPtcCopy{$parent}{$child};			# remove parent-child edge
            foreach my $grandchild (sort keys %{ $edgesPtcCopy{$child} }) {	# take each grandchild of child
              delete $edgesPtcCopy{$child}{$grandchild};		# remove child-grandchild edge
              $edgesPtcCopy{$parent}{$grandchild}++; } }		# make replacement edge between parent and grandchild
      } # foreach my $child (sort keys %{ $edgesPtcCopy{$parent} })
    } # while (scalar keys %{ $edgesPtcCopy{$parent} } > 0)
  } # while (@parentNodes)
  foreach my $parent (sort keys %edgesLca) {
    my $parent_placeholder = $parent;
    $parent_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
    foreach my $child (sort keys %{ $edgesLca{$parent} }) {
      my $child_placeholder = $child;
      $child_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
#       $toReturn .= qq(EDGE $parent TO $child E<br/>\n);
#       $gviz_lca_edges->add_edge(from => "$parent_placeholder", to => "$child_placeholder", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
#       $gviz_lca_unweighted->add_edge(from => "$parent_placeholder", to => "$child_placeholder", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
#       $gviz_homogeneous->add_edge(from => "$parent_placeholder", to => "$child_placeholder", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
    } # foreach my $child (sort keys %{ $edgesLca{$parent} })
  } # foreach my $parent (sort keys %edgesLca)

#   foreach my $node (sort keys %nodes) {
#     if ($nodes{$node}{annot}) {    $toReturn .= qq($node annot<br/>); }
#       elsif ($nodes{$node}{lca}) { $toReturn .= qq($node lca<br/>); }
#   }
  return ($toReturn, \%nodes, \%edgesLca);
} # sub calculateNodesAndEdges


sub annotSummaryJsonp {
# http://131.215.12.204/~azurebrd/cgi-bin/amigo.cgi?action=annotSummaryJsonp&focusTermId=WBGene00000899
#   print qq(Content-type: application/json\n\n);	# this was for json
# for cross domain access, needs to be jsonp with header below, content-type is different, json has a function wrapped around it.
  print $query->header(
    -type => 'application/javascript',
    -access_control_allow_origin => '*',
  );
  my ($var, $focusTermId) = &getHtmlVar($query, 'focusTermId');
  my ($var, $datatype)    = &getHtmlVar($query, 'datatype');
  my ($return, $nodesHashref, $edgesLcaHashref) = &calculateNodesAndEdges($focusTermId, $datatype);
  my %nodes    = %$nodesHashref;
  my %edgesLca = %$edgesLcaHashref;
  my @nodes = ();
  my $rootNode = '0000886';
  my $diameterMultiplier = 60;
  foreach my $node (sort keys %nodes) {
    my $name = $nodes{$node}{label};
    $name =~ s/ /\\n/g;
    my @annotCounts;
    foreach my $evidenceType (sort keys %{ $nodes{$node}{'counts'} }) {
      next if ($evidenceType eq 'any');				# skip 'any', only used for relative size to max value
#       my $annotationCount = $nodes{$node}{'counts'}{$evidenceType}; my $type = $evidenceType;
#       if ($annotationCount > 1) { $type .= 's'; }
#       push @annotCounts, qq($annotationCount $type);
      push @annotCounts, qq($nodes{$node}{'counts'}{$evidenceType} $evidenceType); }
    my $annotCounts = join"; ", @annotCounts;
    my $diameter = $diameterMultiplier * &calcNodeWidth($nodes{$node}{'counts'}{'any'}, $nodes{"WBPhenotype:$rootNode"}{'counts'}{'any'});
    my $diameter_unweighted = 40;
    my $diameter_weighted = $diameter;
    my $fontSize = $diameter * .2; if ($fontSize < 4) { $fontSize = 4; }
    my $fontSize_weighted = $fontSize;
    my $fontSize_unweighted = 6;
    my $borderWidth = 2; 
    my $borderWidth_weighted = $borderWidth;
    my $borderWidth_unweighted = 2;				# scaled diameter and fontSize to keep borderWidth the same, but passing values in case we ever want to change them, we won't have to change the cytoscape receiving the json
    if ($node eq "WBPhenotype:$rootNode") {  $node =~ s/WBPhenotype://; push @nodes, qq({ "data" : { "id" : "$node", "name" : "$name", "annotCounts" : "$annotCounts", "borderStyle" : "dashed", "nodeColor" : "blue", "borderWidthUnweighted" : "$borderWidth_unweighted", "borderWidthWeighted" : "$borderWidth_weighted", "borderWidth" : "$borderWidth", "fontSizeUnweighted" : "$fontSize_unweighted", "fontSizeWeighted" : "$fontSize_weighted", "fontSize" : "$fontSize", "diameter" : $diameter, "diameter_weighted" : $diameter_weighted, "diameter_unweighted" : $diameter_unweighted, "nodeShape" : "rectangle" } }); }
      elsif ($nodes{$node}{lca}) {           $node =~ s/WBPhenotype://; push @nodes, qq({ "data" : { "id" : "$node", "name" : "$name", "annotCounts" : "$annotCounts", "borderStyle" : "dashed", "nodeColor" : "blue", "borderWidthUnweighted" : "$borderWidth_unweighted", "borderWidthWeighted" : "$borderWidth_weighted", "borderWidth" : "$borderWidth", "fontSizeUnweighted" : "$fontSize_unweighted", "fontSizeWeighted" : "$fontSize_weighted", "fontSize" : "$fontSize", "diameter" : $diameter, "diameter_weighted" : $diameter_weighted, "diameter_unweighted" : $diameter_unweighted, "nodeShape" : "ellipse" } });   }
      elsif ($nodes{$node}{annot}) {         $node =~ s/WBPhenotype://; push @nodes, qq({ "data" : { "id" : "$node", "name" : "$name", "annotCounts" : "$annotCounts", "borderStyle" : "solid", "nodeColor" : "red", "borderWidthUnweighted" : "$borderWidth_unweighted", "borderWidthWeighted" : "$borderWidth_weighted", "borderWidth" : "$borderWidth", "fontSizeUnweighted" : "$fontSize_unweighted", "fontSizeWeighted" : "$fontSize_weighted", "fontSize" : "$fontSize", "diameter" : $diameter, "diameter_weighted" : $diameter_weighted, "diameter_unweighted" : $diameter_unweighted, "nodeShape" : "ellipse" } });     } }

  my $nodes = join",\n", @nodes; 
  print qq(jsonCallback\(\n);
  print qq({ "elements" : {\n);
  print qq("nodes" : [\n);
  print qq($nodes\n);
  print qq(],\n);
  my @edges = ();
  foreach my $source (sort keys %edgesLca) {
    foreach my $target (sort keys %{ $edgesLca{$source } }) {
      my $cSource = $source; $cSource =~ s/WBPhenotype://;
      my $cTarget = $target; $cTarget =~ s/WBPhenotype://;
      my $name = $cSource . $cTarget;
      push @edges, qq({ "data" : { "id" : "$name", "weight" : 1, "source" : "$cSource", "target" : "$cTarget" } }); } }
#   push @edges, qq({ "data" : { "id" : "legend_nodirect_legend_yesdirect", "weight" : 1, "source" : "legend_nodirect", "target" : "legend_yesdirect" } });
#   push @edges, qq({ "data" : { "id" : "legend_root_legend_nodirect", "weight" : 1, "source" : "legend_root", "target" : "legend_nodirect" } });
#   push @edges, qq({ "data" : { "id" : "legend_legend_legend_root", "weight" : 1, "source" : "legend_legend", "target" : "legend_root" } });
  my $edges = join",\n", @edges; 
  print qq("edges" : [\n);
  print qq($edges\n);
  print qq(]\n);
  print qq(} }\n);
  print qq(\);\n);
} # sub annotSummaryJsonp

sub annotSummaryJson {			# temporarily keep this for the live www.wormbase going through the fake phenotype_graph_json widget
# http://131.215.12.204/~azurebrd/cgi-bin/amigo.cgi?action=annotSummaryJson&focusTermId=WBGene00000899
  print qq(Content-type: application/json\n\n);	# this was for json
  my ($var, $focusTermId) = &getHtmlVar($query, 'focusTermId');
  my ($var, $datatype)    = &getHtmlVar($query, 'datatype');
  my ($return, $nodesHashref, $edgesLcaHashref) = &calculateNodesAndEdges($focusTermId, $datatype);
  my %nodes    = %$nodesHashref;
  my %edgesLca = %$edgesLcaHashref;
  my @nodes = ();
  my $rootNode = '0000886';
  my $diameterMultiplier = 60;
  foreach my $node (sort keys %nodes) {
    my $name = $nodes{$node}{label};
    $name =~ s/ /\\n/g;
    my @annotCounts;
    foreach my $evidenceType (sort keys %{ $nodes{$node}{'counts'} }) {
      next if ($evidenceType eq 'any');				# skip 'any', only used for relative size to max value
#       my $annotationCount = $nodes{$node}{'counts'}{$evidenceType}; my $type = $evidenceType;
#       if ($annotationCount > 1) { $type .= 's'; }
#       push @annotCounts, qq($annotationCount $type);
      push @annotCounts, qq($nodes{$node}{'counts'}{$evidenceType} $evidenceType); }
    my $annotCounts = join"; ", @annotCounts;
    my $diameter = $diameterMultiplier * &calcNodeWidth($nodes{$node}{'counts'}{'any'}, $nodes{"WBPhenotype:$rootNode"}{'counts'}{'any'});
    my $diameter_unweighted = 40;
    my $diameter_weighted = $diameter;
    my $fontSize = $diameter * .2; if ($fontSize < 4) { $fontSize = 4; }
    my $fontSize_weighted = $fontSize;
    my $fontSize_unweighted = 6;
    my $borderWidth = 2; 
    my $borderWidth_weighted = $borderWidth;
    my $borderWidth_unweighted = 2;				# scaled diameter and fontSize to keep borderWidth the same, but passing values in case we ever want to change them, we won't have to change the cytoscape receiving the json
    if ($node eq "WBPhenotype:$rootNode") {  $node =~ s/WBPhenotype://; push @nodes, qq({ "data" : { "id" : "$node", "name" : "$name", "annotCounts" : "$annotCounts", "borderStyle" : "dashed", "nodeColor" : "blue", "borderWidthUnweighted" : "$borderWidth_unweighted", "borderWidthWeighted" : "$borderWidth_weighted", "borderWidth" : "$borderWidth", "fontSizeUnweighted" : "$fontSize_unweighted", "fontSizeWeighted" : "$fontSize_weighted", "fontSize" : "$fontSize", "diameter" : $diameter, "diameter_weighted" : $diameter_weighted, "diameter_unweighted" : $diameter_unweighted, "nodeShape" : "rectangle" } }); }
      elsif ($nodes{$node}{lca}) {           $node =~ s/WBPhenotype://; push @nodes, qq({ "data" : { "id" : "$node", "name" : "$name", "annotCounts" : "$annotCounts", "borderStyle" : "dashed", "nodeColor" : "blue", "borderWidthUnweighted" : "$borderWidth_unweighted", "borderWidthWeighted" : "$borderWidth_weighted", "borderWidth" : "$borderWidth", "fontSizeUnweighted" : "$fontSize_unweighted", "fontSizeWeighted" : "$fontSize_weighted", "fontSize" : "$fontSize", "diameter" : $diameter, "diameter_weighted" : $diameter_weighted, "diameter_unweighted" : $diameter_unweighted, "nodeShape" : "ellipse" } });   }
      elsif ($nodes{$node}{annot}) {         $node =~ s/WBPhenotype://; push @nodes, qq({ "data" : { "id" : "$node", "name" : "$name", "annotCounts" : "$annotCounts", "borderStyle" : "solid", "nodeColor" : "red", "borderWidthUnweighted" : "$borderWidth_unweighted", "borderWidthWeighted" : "$borderWidth_weighted", "borderWidth" : "$borderWidth", "fontSizeUnweighted" : "$fontSize_unweighted", "fontSizeWeighted" : "$fontSize_weighted", "fontSize" : "$fontSize", "diameter" : $diameter, "diameter_weighted" : $diameter_weighted, "diameter_unweighted" : $diameter_unweighted, "nodeShape" : "ellipse" } });     } }

  my $nodes = join",\n", @nodes; 
  print qq({ "elements" : {\n);
  print qq("nodes" : [\n);
  print qq($nodes\n);
  print qq(],\n);
  my @edges = ();
  foreach my $source (sort keys %edgesLca) {
    foreach my $target (sort keys %{ $edgesLca{$source } }) {
      my $cSource = $source; $cSource =~ s/WBPhenotype://;
      my $cTarget = $target; $cTarget =~ s/WBPhenotype://;
      my $name = $cSource . $cTarget;
      push @edges, qq({ "data" : { "id" : "$name", "weight" : 1, "source" : "$cSource", "target" : "$cTarget" } }); } }
#   push @edges, qq({ "data" : { "id" : "legend_nodirect_legend_yesdirect", "weight" : 1, "source" : "legend_nodirect", "target" : "legend_yesdirect" } });
#   push @edges, qq({ "data" : { "id" : "legend_root_legend_nodirect", "weight" : 1, "source" : "legend_root", "target" : "legend_nodirect" } });
#   push @edges, qq({ "data" : { "id" : "legend_legend_legend_root", "weight" : 1, "source" : "legend_legend", "target" : "legend_root" } });
  my $edges = join",\n", @edges; 
  print qq("edges" : [\n);
  print qq($edges\n);
  print qq(]\n);
  print qq(} }\n);
} # sub annotSummaryJson

sub annotSummaryCytoscape {
# http://131.215.12.204/~azurebrd/cgi-bin/amigo.cgi?action=annotSummaryCytoscape&focusTermId=WBGene00000899
  my ($var, $focusTermId) = &getHtmlVar($query, 'focusTermId');
  my ($var, $datatype)    = &getHtmlVar($query, 'datatype');
  my $toPrint = ''; my $return = '';

#   my $jsonUrl = 'http://131.215.12.204/~azurebrd/wbgene00000899b.json';
#   my $jsonUrl = 'http://131.215.12.204/~azurebrd/cgi-bin/amigo.cgi?action=annotSummaryJson&focusTermId=' . $focusTermId;
  my $jsonUrl = 'amigo.cgi?action=annotSummaryJson&focusTermId=' . $focusTermId;
  print << "EndOfText";
Content-type: text/html\n
<!DOCTYPE html>
<html>
<head>
<link href="http://131.215.12.204/~azurebrd/work/cytoscape/style.css" rel="stylesheet" />
<link href="http://cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.min.css" rel="stylesheet" type="text/css" />
<meta charset=utf-8 />
<meta name="viewport" content="user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, minimal-ui">
<title>$focusTermId Cytoscape view</title>


<script src="http://code.jquery.com/jquery-2.0.3.min.js"></script>

<script src="http://131.215.12.204/~azurebrd/javascript/cytoscape.min.js"></script>

<script src="http://131.215.12.204/~azurebrd/javascript/dagre.min.js"></script>
<script src="https://cdn.rawgit.com/cytoscape/cytoscape.js-dagre/1.1.2/cytoscape-dagre.js"></script>

<script src="http://cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.min.js"></script>
<script src="https://cdn.rawgit.com/cytoscape/cytoscape.js-qtip/2.2.5/cytoscape-qtip.js"></script>

<script type="text/javascript">
\$(function(){

  var elesJson = {
    nodes: [
      { data: { id: 'a', foo: 3, bar: 5, baz: 7 } },
      { data: { id: 'b', foo: 7, bar: 1, baz: 3 } },
      { data: { id: 'c', foo: 2, bar: 7, baz: 6 } },
      { data: { id: 'd', foo: 9, bar: 5, baz: 2 } },
      { data: { id: 'e', foo: 2, bar: 4, baz: 5 } }
    ],
  
    edges: [
      { data: { id: 'ae', weight: 1, source: 'a', target: 'e' } },
      { data: { id: 'ab', weight: 3, source: 'a', target: 'b' } },
      { data: { id: 'be', weight: 4, source: 'b', target: 'e' } },
      { data: { id: 'bc', weight: 5, source: 'b', target: 'c' } },
      { data: { id: 'ce', weight: 6, source: 'c', target: 'e' } },
      { data: { id: 'cd', weight: 2, source: 'c', target: 'd' } },
      { data: { id: 'de', weight: 7, source: 'd', target: 'e' } }
    ]
  };

  \$('#cy2').cytoscape({
    style: cytoscape.stylesheet()
      .selector('node')
        .css({
          'background-color': '#6272A3',
          'shape': 'rectangle',
          'width': 'mapData(foo, 0, 10, 10, 30)',
          'height': 'mapData(bar, 0, 10, 10, 50)',
          'content': 'data(id)'
        })
      .selector('edge')
        .css({
          'width': 'mapData(weight, 0, 10, 3, 9)',
          'line-color': '#B1C1F2',
          'target-arrow-color': '#B1C1F2',
          'target-arrow-shape': 'triangle',
          'opacity': 0.8
        })
      .selector(':selected')
        .css({
          'background-color': 'black',
          'line-color': 'black',
          'target-arrow-color': 'black',
          'source-arrow-color': 'black',
          'opacity': 1
        }),

    elements: elesJson,

    layout: {
      name: 'breadthfirst',
      directed: true,
      padding: 10
    },

    ready: function(){
      // ready 2
    }
  });


  // get exported json from cytoscape desktop via ajax
  var graphP = \$.ajax({
    url: '$jsonUrl', // wine-and-cheese.json
    type: 'GET',
    dataType: 'json'
  });

  Promise.all([ graphP ]).then(initCy);

  function initCy( then ){
    var elements = then[0].elements;
    var cyPhenGraph = window.cyPhenGraph = cytoscape({
      container: document.getElementById('cyPhenGraph'),
      layout: { name: 'dagre', padding: 10, nodeSep: 5 },
      style: cytoscape.stylesheet()
        .selector('node')
          .css({
            'content': 'data(name)',
            'background-color': 'white',
            'shape': 'data(nodeShape)',
            'border-color': 'data(nodeColor)',
            'border-style': 'data(borderStyle)',
            'border-width': 2,
            'width': 'data(diameter)',
            'height': 'data(diameter)',
            'text-valign': 'center',
            'text-wrap': 'wrap',
            'min-zoomed-font-size': 8,
            'border-opacity': 0.3,
            'font-size': 'data(fontSize)'
          })
        .selector('edge')
          .css({
            'target-arrow-shape': 'none',
            'source-arrow-shape': 'triangle',
            'width': 2,
            'line-color': '#ddd',
            'target-arrow-color': '#ddd',
            'source-arrow-color': '#ddd'
          })
        .selector('.highlighted')
          .css({
            'background-color': '#61bffc',
            'line-color': '#61bffc',
            'target-arrow-color': '#61bffc',
            'transition-property': 'background-color, line-color, target-arrow-color',
            'transition-duration': '0.5s'
          })
        .selector('.faded')
          .css({
            'opacity': 0.25,
            'text-opacity': 0
          }),
      elements: elements,
      wheelSensitivity: 0.2,
    
      ready: function(){
        window.cyPhenGraph = this;
        cyPhenGraph.elements().unselectify();
        
        cyPhenGraph.on('tap', 'node', function(e){
          var node = e.cyTarget; 
          var nodeId   = node.data('id');
          var neighborhood = node.neighborhood().add(node);
          cyPhenGraph.elements().addClass('faded');
          neighborhood.removeClass('faded');

          var node = e.cyTarget;
          var nodeId   = node.data('id');
          var nodeName = node.data('name');
          var annotCounts = node.data('annotCounts');
          var qtipContent = annotCounts + '<br/><a target="_blank" href="http://www.wormbase.org/species/all/phenotype/WBPhenotype:' + nodeId + '#03--10">' + nodeName + '</a>';
          node.qtip({
               position: {
                 my: 'top center',
                 at: 'bottom center'
               },
               style: {
                 classes: 'qtip-bootstrap',
                 tip: {
                   width: 16,
                   height: 8
                 }
               },
               content: qtipContent,
               show: {
                  e: e.type,
                  ready: true
               },
               hide: {
                  e: 'mouseout unfocus'
               }
          }, e);
        });
        
        cyPhenGraph.on('tap', function(e){
          if( e.cyTarget === cyPhenGraph ){
            cyPhenGraph.elements().removeClass('faded');
          }
        });

        cyPhenGraph.on('mouseover', 'node', function(event) {
            var node = event.cyTarget;
            var nodeId   = node.data('id');
            var nodeName = node.data('name');
            var annotCounts = node.data('annotCounts');
            var qtipContent = annotCounts + '<br/><a target="_blank" href="http://www.wormbase.org/species/all/phenotype/WBPhenotype:' + nodeId + '#03--10">' + nodeName + '</a>';
            \$('#info').html( qtipContent );
        });

      }

    });
  }

  \$('#radio_weighted').on('click', function(){
    var nodes = cyPhenGraph.nodes();
    for( var i = 0; i < nodes.length; i++ ){
      var node     = nodes[i];
      var nodeId   = node.data('id');
      var diameterWeighted   = node.data('diameter_weighted');
      cyPhenGraph.\$('#' + nodeId).data('diameter', diameterWeighted);
      var fontSizeWeighted   = node.data('fontSizeWeighted');
      cyPhenGraph.\$('#' + nodeId).data('fontSize', fontSizeWeighted);
    }
    cyPhenGraph.layout();
  });
  \$('#radio_unweighted').on('click', function(){
    var nodes = cyPhenGraph.nodes();
    for( var i = 0; i < nodes.length; i++ ){
      var node     = nodes[i];
      var nodeId   = node.data('id');
      var diameterUnweighted = node.data('diameter_unweighted');
      var diameterWeighted   = node.data('diameter_weighted');
      cyPhenGraph.\$('#' + nodeId).data('diameter', diameterUnweighted);
      var fontSizeUnweighted = node.data('fontSizeUnweighted');
      var fontSizeWeighted   = node.data('fontSizeWeighted');
      cyPhenGraph.\$('#' + nodeId).data('fontSize', fontSizeUnweighted);
    }
    cyPhenGraph.layout();
  });
  \$('#view_png_button').on('click', function(){
    var png64 = cyPhenGraph.png();
    \$('#png-export').attr('src', png64);
    \$('#png-export').show();
    \$('#exportdiv').show();
    \$('#cyPhenGraph').hide();
    \$('#weightstate').hide();
    \$('#view_png_button').hide();
    \$('#view_edit_button').show();
    \$('#info').text('drag image to desktop, or right-click and save image as');
  });
  \$('#view_edit_button').on('click', function(){
    \$('#png-export').hide();
    \$('#exportdiv').hide();
    \$('#cyPhenGraph').show();
    \$('#weightstate').show();
    \$('#view_png_button').show();
    \$('#view_edit_button').hide();
  });
});
</script>

</head>
<body>
<div style="width: 1705px;">
  <div id="cyPhenGraph"  style="border: 1px solid #aaa; float: left;  position: relative; height: 750px; width: 750px;"></div>
  <div id="exportdiv" style="width: 750px; position: relative; float: left; display: none;"><img id="png-export" style="border: 1px solid #ddd; display: none;"></div>
    <div id="loading">
      <span class="fa fa-refresh fa-spin"></span>
    </div>
  <div id="cy2" style="border: 1px solid #aaa; float: left; position: relative; height: 750px; width: 400px;"></div>
  <!--<div id="cy" style="height: 100%; width: 100%; position: absolute;"></div>-->
  <div id="controldiv" style="z-index: 9999; border: 1px solid #aaa; position: relative; float: left; width: 200px;">
    <div id="exportdiv" style="z-index: 9999; position: relative; top: 0; left: 0; width: 200px;">
      <button id="view_png_button">export png</button>
      <button id="view_edit_button" style="display: none;">go back</button><br/>
    </div>
    <div id="legenddiv" style="z-index: 9999; position: relative; top: 0; left: 0; width: 200px;">
    Legend :<br/>
    <table>
    <tr><td valign="center"><svg width="22pt" height="22pt" viewBox="0.00 0.00 44.00 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
    <polygon fill="white" stroke="none" points="-4,4 -4,-40 40,-40 40,4 -4,4"/>
    <g id="node1" class="node"><title></title>
    <polygon fill="none" stroke="blue" stroke-dasharray="5,2" points="36,-36 0,-36 0,-0 36,-0 36,-36"/></g></g></svg></td><td valign="center">Root</td></tr>
    <tr><td valign="center"><svg width="22pt" height="22pt" viewBox="0.00 0.00 44.00 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
    <polygon fill="white" stroke="none" points="-4,4 -4,-40 40,-40 40,4 -4,4"/>
    <g id="node1" class="node"><title></title>
    <ellipse fill="none" stroke="blue" stroke-dasharray="5,2" cx="18" cy="-18" rx="18" ry="18"/></g></g></svg></td><td valign="center">Without Direct Annotation</td></tr>
    <tr><td valign="center"><svg width="22pt" height="22pt" viewBox="0.00 0.00 44.00 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
    <polygon fill="white" stroke="none" points="-4,4 -4,-40 40,-40 40,4 -4,4"/>
    <g id="node1" class="node"><title></title>
    <ellipse fill="none" stroke="red" cx="18" cy="-18" rx="18" ry="18"/></g></g></svg></td><td valign="center">With Direct Annotation</td></tr>
    </table></div>
    <div id="weightstate" style="z-index: 9999; position: relative; top: 0; left: 0; width: 200px;">
    <input type="radio" name="radio_type" id="radio_weighted"   checked="checked" >Annotation weighted</input><br/>
    <input type="radio" name="radio_type" id="radio_unweighted">Annotation unweighted</input><br/>
    </div><br/>
    <div id="info" style="z-index: 9999; position: relative; top: 0; left: 0; width: 200px;">Mouseover or click node for more information.</div><br/>
  </div>
</div>

<!--<div id="legenddiv" style="z-index: 9999; position: absolute; bottom: 0; left: 0; width: 200px;">
Legend :<br/>
<table>
<tr><td valign="center"><svg width="22pt" height="22pt" viewBox="0.00 0.00 44.00 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
<polygon fill="white" stroke="none" points="-4,4 -4,-40 40,-40 40,4 -4,4"/>
<g id="node1" class="node"><title></title>
<polygon fill="none" stroke="blue" stroke-dasharray="5,2" points="36,-36 0,-36 0,-0 36,-0 36,-36"/></g></g></svg></td><td valign="center">Root</td></tr>
<tr><td valign="center"><svg width="22pt" height="22pt" viewBox="0.00 0.00 44.00 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
<polygon fill="white" stroke="none" points="-4,4 -4,-40 40,-40 40,4 -4,4"/>
<g id="node1" class="node"><title></title>
<ellipse fill="none" stroke="blue" stroke-dasharray="5,2" cx="18" cy="-18" rx="18" ry="18"/></g></g></svg></td><td valign="center">Without Direct Annotation</td></tr>
<tr><td valign="center"><svg width="22pt" height="22pt" viewBox="0.00 0.00 44.00 44.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 40)">
<polygon fill="white" stroke="none" points="-4,4 -4,-40 40,-40 40,4 -4,4"/>
<g id="node1" class="node"><title></title>
<ellipse fill="none" stroke="red" cx="18" cy="-18" rx="18" ry="18"/></g></g></svg></td><td valign="center">With Direct Annotation</td></tr>
</table>
<svg width="60pt" height="200pt"
 viewBox="0.00 0.00 94.27 288.13" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 284.134)">
<title>test0</title>
<polygon fill="white" stroke="none" points="-4,4 -4,-284.134 90.267,-284.134 90.267,4 -4,4"/>
<g id="node1" class="node"><title>With\nDirect\nAnnotation</title>
<ellipse fill="none" stroke="red" cx="43.1335" cy="-43.1335" rx="43.2674" ry="43.2674"/>
<text text-anchor="middle" x="43.1335" y="-54.4335" font-family="Times,serif" font-size="14.00">With</text>
<text text-anchor="middle" x="43.1335" y="-39.4335" font-family="Times,serif" font-size="14.00">Direct</text>
<text text-anchor="middle" x="43.1335" y="-24.4335" font-family="Times,serif" font-size="14.00">Annotation</text>
</g>
<g id="node2" class="node"><title>Without\nDirect\nAnnotation</title>
<ellipse fill="none" stroke="blue" stroke-dasharray="5,2" cx="43.1335" cy="-147.134" rx="43.2674" ry="43.2674"/>
<text text-anchor="middle" x="43.1335" y="-158.434" font-family="Times,serif" font-size="14.00">Without</text>
<text text-anchor="middle" x="43.1335" y="-143.434" font-family="Times,serif" font-size="14.00">Direct</text>
<text text-anchor="middle" x="43.1335" y="-128.434" font-family="Times,serif" font-size="14.00">Annotation</text>
</g>
<g id="node3" class="node"><title>Root</title>
<polygon fill="none" stroke="blue" stroke-dasharray="5,2" points="79.1335,-280.134 7.13351,-280.134 7.13351,-208.134 79.1335,-208.134 79.1335,-280.134"/>
<text text-anchor="middle" x="43.1335" y="-240.434" font-family="Times,serif" font-size="14.00">Root</text>
</g>
</g>
</svg></div><br/>-->
EndOfText
print qq($return);
print qq($toPrint);
print qq(</body></html>);
} # sub annotSummaryCytoscape

# horizontal
# <svg width="288pt" height="94pt"
#  viewBox="0.00 0.00 288.13 94.27" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
# <g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 90.267)">
# <title>test0</title>
# <polygon fill="white" stroke="none" points="-4,4 -4,-90.267 284.134,-90.267 284.134,4 -4,4"/>
# <!-- With\nDirect\nAnnotation -->
# <g id="node1" class="node"><title>With\nDirect\nAnnotation</title>
# <ellipse fill="none" stroke="red" cx="43.1335" cy="-43.1335" rx="43.2674" ry="43.2674"/>
# <text text-anchor="middle" x="43.1335" y="-54.4335" font-family="Times,serif" font-size="14.00">With</text>
# <text text-anchor="middle" x="43.1335" y="-39.4335" font-family="Times,serif" font-size="14.00">Direct</text>
# <text text-anchor="middle" x="43.1335" y="-24.4335" font-family="Times,serif" font-size="14.00">Annotation</text>
# </g>
# <!-- Without\nDirect\nAnnotation -->
# <g id="node2" class="node"><title>Without\nDirect\nAnnotation</title>
# <ellipse fill="none" stroke="blue" stroke-dasharray="5,2" cx="147.134" cy="-43.1335" rx="43.2674" ry="43.2674"/>
# <text text-anchor="middle" x="147.134" y="-54.4335" font-family="Times,serif" font-size="14.00">Without</text>
# <text text-anchor="middle" x="147.134" y="-39.4335" font-family="Times,serif" font-size="14.00">Direct</text>
# <text text-anchor="middle" x="147.134" y="-24.4335" font-family="Times,serif" font-size="14.00">Annotation</text>
# </g>
# <!-- Root -->
# <g id="node3" class="node"><title>Root</title>
# <polygon fill="none" stroke="blue" stroke-dasharray="5,2" points="280.134,-79.1335 208.134,-79.1335 208.134,-7.13351 280.134,-7.13351 280.134,-79.1335"/>
# <text text-anchor="middle" x="244.134" y="-39.4335" font-family="Times,serif" font-size="14.00">Root</text>
# </g>
# </g>
# </svg>

sub annotSummaryGraph {
# test
# http://mangolassi.caltech.edu/~azurebrd/cgi-bin/testing/amigo/wobr/amigo.cgi?action=annotSummaryGraph&focusTermId=WBGene00000001
# http://131.215.12.204/~azurebrd/cgi-bin/amigo.cgi?action=annotSummaryGraph&focusTermId=WBGene00000086
  my ($var, $focusTermId) = &getHtmlVar($query, 'focusTermId');
  my ($var, $datatype)    = &getHtmlVar($query, 'datatype');
  my ($var, $download)    = &getHtmlVar($query, 'download');
  unless ($datatype) { $datatype = 'phenotype'; }			# later will need to change based on different datatypes
#   my ($solr_url) = &getSolrUrl($focusTermId);
  my $solr_url = $base_solr_url . 'phenotype/';
    # link 1, from wbgene get wbphenotypes from   "grouped":{ "annotation_class":{ "matches":12, "ngroups":4, "groups":[{ "groupValue":"WBPhenotype:0000674", # }]}}

  my $nodeWidth    = 1;
  my $weightedNodeWidth    = 1;
  my $unweightedNodeWidth  = 1;

  my %annotationCounts;							# get annotation counts from evidence type
  my %phenotypes; my @annotPhenotypes;					# array of annotated terms to loop and do pairwise comparisons
#   my $annotation_count_solr_url = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&rows=100000&fl=regulates_closure,id&q=document_category:annotation&fq=-qualifier:%22not%22&fq=bioentity:%22WB:' . $focusTermId . '%22';
  my $annotation_count_solr_url = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&rows=100000&fl=regulates_closure,id,annotation_class&q=document_category:annotation&fq=-qualifier:%22not%22&fq=bioentity:%22WB:' . $focusTermId . '%22';
# sample	http://131.215.12.215:8080/solr/phenotype/select?qt=standard&indent=on&wt=json&version=2.2&rows=100000&fl=regulates_closure,id&q=document_category:annotation&fq=-qualifier:%22not%22&fq=bioentity:%22WB:WBGene00000086%22
  my $page_data   = get $annotation_count_solr_url;                                           # get the URL
  my $perl_scalar = $json->decode( $page_data );                        # get the solr data
  my %jsonHash    = %$perl_scalar;
  foreach my $doc (@{ $jsonHash{'response'}{'docs'} }) {
      my $phenotype = $$doc{'annotation_class'};
      $phenotypes{$phenotype}++;
      my $id = $$doc{'id'};
      my $varCount = 0; my $rnaiCount = 0;
      if ($id =~ m/WB:WBVar\d+/) {  my (@wbvar)  = $id =~ m/(WB:WBVar\d+)/g;  $varCount  = scalar @wbvar;  }
      if ($id =~ m/WB:WBRNAi\d+/) { my (@wbrnai) = $id =~ m/(WB:WBRNAi\d+)/g; $rnaiCount = scalar @wbrnai; }
      foreach my $phenotype (@{ $$doc{'regulates_closure'} }) {
        if ($varCount) {  for (1 .. $varCount) {  $annotationCounts{$phenotype}{'any'}++; $annotationCounts{$phenotype}{'Allele'}++; } }
        if ($rnaiCount) { for (1 .. $rnaiCount) { $annotationCounts{$phenotype}{'any'}++; $annotationCounts{$phenotype}{'RNAi'}++;      } }
      }
  }
#   my $annotation_count_solr_url = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&rows=1000000&fl=evidence_type&group=true&group.field=annotation_class&group.ngroups=true&group.format=grouped&group.limit=1000&q=document_category:annotation&fq=-qualifier:%22not%22&fq=bioentity:%22WB:' . $focusTermId . '%22';
# sample  http://131.215.12.204:8080/solr/phenotype/select?qt=standard&indent=on&wt=json&version=2.2&rows=1000000&fl=evidence_type&group=true&group.field=annotation_class&group.ngroups=true&group.format=grouped&group.limit=1000&q=document_category:annotation&fq=-qualifier:%22not%22&fq=bioentity:%22WB:WBGene00000898%22
#   foreach my $arrayElement (@{ $jsonHash{'grouped'}{'annotation_class'}{'groups'} }) {
#     my $phenotype = $$arrayElement{'groupValue'};
#     foreach my $doc (@{ $$arrayElement{'doclist'}{'docs'} }) {
#       my $evidenceType = $$doc{'evidence_type'};
#       $annotationCounts{$phenotype}{$evidenceType}++; } }

#   my $wbgene_solr_url = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&rows=1000000&fl=evidence_type&group=true&group.field=annotation_class&group.ngroups=true&group.format=grouped&group.limit=1000&q=document_category:annotation&fq=-qualifier:%22not%22&fq=source:%22WB%22&fq=bioentity:%22WB:' . $focusTermId . '%22';
# # solr url for wbgene
# #   print qq(<a href="$wbgene_solr_url">$wbgene_solr_url</a><br>\n);
#   my $page_data   = get $wbgene_solr_url;                                           # get the URL
#   my $perl_scalar = $json->decode( $page_data );                        # get the solr data
#   my %jsonHash    = %$perl_scalar;
#   my %phenotypes; 
# #   my %nodesAll;								# for an annotated phenotype ID, all nodes in its topological map that have transitivity
# #   my %edgesAll;								# for an annotated phenotype ID, all edges in its topological map that have transitivity
# #   print qq($jsonHash{'grouped'}{'annotation_class'}{'groups'}<br>\n);    
#   foreach my $arrayElement (@{ $jsonHash{'grouped'}{'annotation_class'}{'groups'} }) {
# # phenotype IDs
# #     print qq($$arrayElement{'groupValue'}<br>\n);
#     $phenotypes{$$arrayElement{'groupValue'}}++;
#   }

  my $rootId = 'WBPhenotype:0000886';
  my $rootId_placeholder = $rootId;
  $rootId_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
  my $maxAnyCount  = $annotationCounts{$rootId}{'any'};

  my $direction = 'back'; my $style = 'solid'; my $edgecolor = 'black';                      # graph arror direction and style and color
  my $nodecolor = 'blue'; my $nodeAnnotatedColor = 'red'; my $nodeNormalColor = 'blue'; my $nodeAnnotatedStyle = 'solid'; my $nodeNormalStyle = 'dashed';
  my $hiddennodecolor = 'white';
  my $nodeFontSize = 10;
  my $unweightedNodeFontSize = 10;
  my $weightedNodeFontSize = 10;

  my %nodeLabels;
  my %nodeHgLabels;
  my %edgesPtc;								# edges from parent to child
  my $gviz_aggregate_weighted        = GraphViz2->new(concentrate => 'concentrate', graph => { nodesep => '.1', rankdir => 'LR' });      # generate graphviz for main markup
  my $gviz_aggregate_unweighted      = GraphViz2->new(concentrate => 'concentrate', graph => { nodesep => '.1', rankdir => 'LR' });      # generate graphviz for main markup
  foreach my $phenotypeId (sort keys %phenotypes) {
    push @annotPhenotypes, $phenotypeId;
    my $phenotype_solr_url = $solr_url . 'select?qt=standard&fl=regulates_transitivity_graph_json,topology_graph_json&version=2.2&wt=json&indent=on&rows=1&fq=-is_obsolete:true&fq=document_category:%22ontology_class%22&q=id:%22' . $phenotypeId . '%22';
# solr url for phenotype
#     print qq(<a href="$phenotype_solr_url">$phenotype_solr_url</a><br>\n);

    my $page_data   = get $phenotype_solr_url;                                           # get the URL
    my $perl_scalar = $json->decode( $page_data );                        # get the solr data
    my %jsonHash    = %$perl_scalar;
    my $gviz        = GraphViz2->new(concentrate => 'concentrate');      # generate graphviz for main markup
    my $transHashref = $json->decode( $jsonHash{"response"}{"docs"}[0]{"regulates_transitivity_graph_json"} );
    my %transHash = %$transHashref;
    my (@nodes)   = @{ $transHash{"nodes"} };
    my %transNodes;							# track transitivity nodes as nodes to keep from topology data
    for my $index (0 .. @nodes) { if ($nodes[$index]{'id'}) { my $id  = $nodes[$index]{'id'};  $transNodes{$id}++; } }

    my $topoHashref = $json->decode( $jsonHash{"response"}{"docs"}[0]{"topology_graph_json"} );
    my %topoHash = %$topoHashref;
    my (@edges)   = @{ $topoHash{"edges"} };
#     my (@edges) = $json->decode( $jsonHash{"response"}{"docs"}[0]{"topology_graph_json"}{"edges"} );
    for my $index (0 .. @edges) {                                       # for each edge, add to graph
      my ($sub, $obj, $pred) = ('', '', '');                            # subject object predicate from topology_graph_json
      if ($edges[$index]{'sub'}) {  $sub  = $edges[$index]{'sub'};  }
      if ($edges[$index]{'obj'}) {  $obj  = $edges[$index]{'obj'};  }
      next unless ( ($transNodes{$sub}) && ($transNodes{$obj}) );
      if ($edges[$index]{'pred'}) { $pred = $edges[$index]{'pred'}; }
      my $direction = 'back'; my $style = 'solid';                      # graph arror direction and style
      if ($sub && $obj && $pred) {                                      # if subject + object + predicate
        my $color = 'black'; 
        $edgesAll{$phenotypeId}{$sub}{$obj}++;				# for an annotated term's edges, each child to its parents
        $edgesPtc{$obj}{$sub}++;					# any existing edge, parent to child
        if ($edgesPtc{$obj}{$sub} < 2) {
          $sub =~ s/:/_placeholderColon_/g;                               # edges won't have proper title text if ids have : in them
          $obj =~ s/:/_placeholderColon_/g;                               # edges won't have proper title text if ids have : in them
#         $gviz->add_edge("$obj" => "$sub", dir => "$direction", color => "$color", fontcolor => "$color", style => "$style");
          $gviz->add_edge(from => "$obj", to => "$sub", dir => "$direction", color => "$color", fontcolor => "$color", style => "$style");
#         $gviz_aggregate_weighted->add_edge("$obj" => "$sub", dir => "$direction", color => "$color", fontcolor => "$color", style => "$style");
          $gviz_aggregate_weighted->add_edge(from => "$obj", to => "$sub", dir => "$direction", color => "$color", fontcolor => "$color", style => "$style", arrowsize => ".3");
          $gviz_aggregate_unweighted->add_edge(from => "$obj", to => "$sub", dir => "$direction", color => "$color", fontcolor => "$color", style => "$style", arrowsize => ".3");
        }
                                                                        # add edge to graph
      } # if ($sub && $obj && $pred)
    } # for my $index (0 .. @edges)
    my (@nodes)   = @{ $topoHash{"nodes"} };
#     my (@nodes) = $json->decode( $jsonHash{"response"}{"docs"}[0]{"topology_graph_json"}{"nodes"} );
    for my $index (0 .. @nodes) {                                       # for each node, add to graph
      my ($id, $lbl) = ('', '');                                        # id and label
      if ($nodes[$index]{'id'}) {  $id  = $nodes[$index]{'id'};  }
      if ($nodes[$index]{'lbl'}) { $lbl = $nodes[$index]{'lbl'}; }
      next unless ($transNodes{$id});
#       $label{$id} = $lbl;                                               # map id to label
#       if ($children{$id}) { next; }                                     # don't add node for the children
#       my $url = "/species/all/$class/$id";                              # URL to link to wormbase page for object
# UNCOMMENT TO GET words in different lines
#       $lbl =~ s/ /\n/g;                                                # replace spaces with linebreaks in graph for more-square boxes
      $lbl =~ s/ /<br\/>/g;                                                # replace spaces with html linebreaks in graph for more-square boxes
# UNCOMMENT TO GET ID IN BOX
#       my $label = "$id\n$lbl";                                          # node label should have full id, not stripped of :, which is required for edge title text
      my $label = "$lbl";                                          # node label should have full id, not stripped of :, which is required for edge title text
      my $hglabel = "$lbl";
      if ($annotationCounts{$id}) { 					# if there are annotation counts to variation and/or rnai, add them to the box
        my @annotCounts;
        foreach my $evidenceType (sort keys %{ $annotationCounts{$id} }) {
          next if ($evidenceType eq 'any');				# skip 'any', only used for relative size to max value
          push @annotCounts, qq($annotationCounts{$id}{$evidenceType} $evidenceType); } 
        my $annotCounts = join"; ", @annotCounts;
#         $label .= qq(\nIndividual Counts: $annotCounts);				# add annotation counts to the label
#         $label .= qq(\nTotal Counts: $annotCounts);				# add annotation counts to the label
#         $label .= qq(\nCounts: $annotCounts);				# add annotation counts to the label
#         $label .= qq(\n$annotCounts);				# add annotation counts to the label
#         $label .= qq(<br\/><font color="transparent">$annotCounts</font>);				# add html line break and annotation counts to the label
        $hglabel = qq($label<br\/>$annotCounts);				# add html line break and annotation counts to the label
        $label = qq(LINEBREAK<br\/>$label<br\/><font color="transparent">$annotCounts<\/font>);				# add html line break and annotation counts to the label
# print STDERR qq(LABEL $label LAB\n);
      }
      $nodeLabels{$id} = $label;
      $nodeHgLabels{$id} = $hglabel;
#       my $color = 'blue';
#       if ($phenotypes{$id}) { $color = 'red'; }
      if ($id && $lbl) { 
        $nodesAll{$phenotypeId}{$id} = $label;
      }
      my $url = 'http://www.wormbase.org/species/all/phenotype/' . $id . '#03--10';
      my $id_placeholder = $id;
      $id_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
#       if ($id && $lbl) { $gviz->add_node("$id", label => "$label", shape => "box", fontsize => "10", color => "red", URL => "$url"); }
      if ($id && $lbl) { 
#         $gviz->add_node("$id", label => "$label", shape => "box", fontsize => "10", color => "$color");
#         $gviz->add_node(name => "$id", URL => "$url", label => "$label", shape => "box", fontsize => "10", color => "$color"); 
      }
      if ($id && $lbl) { 
#         $gviz_aggregate_weighted->add_node("$id", label => "$label", shape => "box", fontsize => "10", color => "$color");
#         $gviz_aggregate_weighted->add_node(name => "$id", URL => "$url", label => "$label", shape => "box", fontsize => "10", color => "$color");
#         $nodeWidth = &calcNodeWidth($annotationCounts{$id}{'any'}, $maxAnyCount);
#         $nodeWidth = 1;
#         $nodeWidth    = ( sqrt($annotationCounts{$id}{'any'})/sqrt($maxAnyCount) * $nodeScale ) + $nodeMinSize;
        $weightedNodeWidth = &calcNodeWidth($annotationCounts{$id}{'any'}/4, $maxAnyCount);
        $weightedNodeFontSize = $weightedNodeWidth / 1.5 * 20;
#   my $rootId = 'WBPhenotype:0000886';
        if ($id eq $rootId) {
            $gviz_aggregate_unweighted->add_node(name => "$id_placeholder", URL => "$url", label => "<$lbl>", shape => "box", fixedsize => "shape", width => "$unweightedNodeWidth", height => "$unweightedNodeWidth", fontsize => "$unweightedNodeFontSize", color => "$nodeNormalColor", style => "$nodeNormalStyle");
            $gviz_aggregate_weighted->add_node(name => "$id_placeholder", URL => "$url", label => "<$lbl>", shape => "box", fixedsize => "shape", width => "$weightedNodeWidth", height => "$weightedNodeWidth", fontsize => "$weightedNodeFontSize", color => "$nodeNormalColor", style => "$nodeNormalStyle"); }
          elsif ($phenotypes{$id}) {
            $gviz_aggregate_unweighted->add_node(name => "$id_placeholder", URL => "$url", label => "<$lbl>", shape => "circle", fixedsize => "shape", width => "$unweightedNodeWidth", fontsize => "$unweightedNodeFontSize", color => "$nodeAnnotatedColor", style => "$nodeAnnotatedStyle");
            $gviz_aggregate_weighted->add_node(name => "$id_placeholder", URL => "$url", label => "<$lbl>", shape => "circle", fixedsize => "shape", width => "$weightedNodeWidth", fontsize => "$weightedNodeFontSize", color => "$nodeAnnotatedColor", style => "$nodeAnnotatedStyle"); }
          else {
            $gviz_aggregate_unweighted->add_node(name => "$id_placeholder", URL => "$url", label => "<$lbl>", shape => "circle", fixedsize => "shape", width => "$unweightedNodeWidth", fontsize => "$unweightedNodeFontSize", color => "$nodeNormalColor", style => "$nodeNormalStyle");
            $gviz_aggregate_weighted->add_node(name => "$id_placeholder", URL => "$url", label => "<$lbl>", shape => "circle", fixedsize => "shape", width => "$weightedNodeWidth", fontsize => "$weightedNodeFontSize", color => "$nodeNormalColor", style => "$nodeNormalStyle"); }
#   my $nodecolor = 'blue'; my $nodeAnnotatedColor = 'red'; my $nodeNormalColor = 'blue'; my $nodeAnnotatedStyle = 'solid'; my $nodeNormalStyle = 'dotted';


      }
                                                                        # add node to graph
    }
# #     my $svgGenerated = $gviz->as_svg;                                   # generate graph as svg
#     $gviz->run();                                   # generate graph as svg
#     my $svgGenerated = $gviz->dot_output();
# #     my $tempfile = '/tmp/gvfile';
# # #     my $svgGenerated = $gviz->run(output_file => $tempfile);                                   # generate graph as svg
# #     $gviz->run(output_file => $tempfile);                                   # generate graph as svg
# #     $/ = undef;
# #     open (IN, "<$tempfile") or die "Cannot open $tempfile : $!";
# #     my $svgGenerated = <IN>;
# #     close (IN) or die "Cannot close $tempfile : $!";
# #     $/ = "";
#     my ($svgMarkup) = $svgGenerated =~ m/(<svg.*<\/svg>)/s;             # capture svg markup
#     $svgMarkup =~ s/<title>test<\/title>//g;                            # remove automatic title
#     $svgMarkup =~ s/_placeholderColon_/:/g;                             # ids can't be created with a : in them, so have to add the : after the svg is generated
# invididual annotated term graph
#     print qq($svgMarkup<br/>\n);

  } # foreach my $phenotype (sort keys %phenotypes)

  my %allLca;								# all nodes that are LCA to any pair of annotated terms
  my $gviz_pruned        = GraphViz2->new(concentrate => 'concentrate');      # generate graphviz for main markup
  my @dot_nodes; my %dot_edges;
  my $gviz_lca_edges      = GraphViz2->new(concentrate => 'concentrate', logger => $logger, graph => { ranksep => '.02', nodesep => '.1', rankdir => 'LR', overlap => 'true' }, node => { margin => '0' } );      # generate graphviz for main markup, rankdir horizontal
  my $gviz_lca_unweighted = GraphViz2->new(concentrate => 'concentrate', logger => $logger, graph => { ranksep => '.02', nodesep => '.1', rankdir => 'LR', overlap => 'true' }, node => { margin => '0' } );      # generate graphviz for main markup, rankdir horizontal
  my $gviz_homogeneous   = GraphViz2->new(concentrate => 'concentrate', logger => $logger, graph => { ranksep => '.02', nodesep => '.1', rankdir => 'LR', overlap => 'true' }, node => { margin => '0' } );      # generate graphviz for main markup, rankdir horizontal
#   my $ph1 = shift @annotPhenotypes; my $ph2 = '';
  my $ph1 = ''; my $ph2 = '';
  my $url = "http://www.wormbase.org/species/all/phenotype/$rootId";                              # URL to link to wormbase page for object
# #   $gviz_pruned->add_node("$rootId", label => "$rootId\nVariant", shape => "box", fontsize => "10", color => "$nodecolor");
#   $gviz_pruned->add_node(name => "$rootId_placeholder", label => "$rootId\nVariant", shape => "box", fontsize => "10", color => "$nodecolor");
# #   $gviz_lca_edges->add_node("$rootId", label => "$rootId\nVariant", shape => "box", fontsize => "10", color => "$nodecolor", URL => "$url");
# #   $gviz_lca_edges->add_node("$rootId", label => "$nodeLabels{$rootId}", shape => "box", fontsize => "10", color => "$nodecolor", URL => "$url");
#   $gviz_lca_edges->add_node(name => "$rootId_placeholder", label => "$nodeLabels{$rootId}", shape => "box", fontsize => "10", color => "$nodecolor", URL => "$url");

#   $nodeWidth    = ( log($annotationCounts{$rootId}{'any'})/log($maxAnyCount) * $nodeScale ) + $nodeMinSize;
#   $nodeWidth    = ( log(sqrt($annotationCounts{$rootId}{'any'}+$logScaler))/log(sqrt($maxAnyCount+$logScaler)) * $nodeScale ) + $nodeMinSize;
#   $nodeWidth    = ( sqrt($annotationCounts{$rootId}{'any'})/sqrt($maxAnyCount) * $nodeScale ) + $nodeMinSize;


    # generate legend node and edges
  $nodeWidth = &calcNodeWidth($annotationCounts{$rootId}{'any'}/4, $maxAnyCount);
  $nodeFontSize = $nodeWidth / 1.5 * 20;
  $gviz_lca_edges->add_node(name => "legend_legend", label => "<<b>Legend : </b>>", xlabel => "", width => "$nodeWidth", height => "$nodeWidth", fixedsize => "shape", shape => "box", fontsize => "$nodeFontSize", style => "$nodeNormalStyle", color => "white", URL => "$url");
  $gviz_lca_edges->add_node(name => "legend_root", label => "<<b>Root<br/>\nTerm</b>>", xlabel => "", width => "$nodeWidth", height => "$nodeWidth", fixedsize => "shape", shape => "box", fontsize => "$nodeFontSize", style => "$nodeNormalStyle", color => "$nodeNormalColor", URL => "$url");
  $gviz_lca_edges->add_node(name => "legend_nodirect", label => "<<b>Without<br/>\nDirect<br/>\nAnnotation</b>>", xlabel => "", width => "$nodeWidth", height => "$nodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$nodeFontSize", style => "$nodeNormalStyle", color => "$nodeNormalColor", URL => "$url");
  $gviz_lca_edges->add_node(name => "legend_yesdirect", label => "<<b>With<br/>\nDirect<br/>\nAnnotation</b>>", xlabel => "", width => "$nodeWidth", height => "$nodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$nodeFontSize", style => "$nodeAnnotatedStyle", color => "$nodeAnnotatedColor", URL => "$url");
  $gviz_lca_edges->add_edge(from => "legend_nodirect", to => "legend_yesdirect", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
  $gviz_lca_edges->add_edge(from => "legend_root", to => "legend_nodirect", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
  $gviz_lca_edges->add_edge(from => "legend_legend", to => "legend_root", dir => "$direction", color => "white", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 

    # generate legend node and edges
  $nodeWidth = &calcNodeWidth($annotationCounts{$rootId}{'any'}/4, $maxAnyCount);
  $nodeFontSize = $nodeWidth / 1.5 * 20;
  $gviz_lca_unweighted->add_node(name => "legend_legend", label => "<<b>Legend : </b>>", xlabel => "", width => "$nodeWidth", height => "$nodeWidth", fixedsize => "shape", shape => "box", fontsize => "$nodeFontSize", style => "$nodeNormalStyle", color => "white", URL => "$url");
  $gviz_lca_unweighted->add_node(name => "legend_root", label => "<<b>Root<br/>\nTerm</b>>", xlabel => "", width => "$nodeWidth", height => "$nodeWidth", fixedsize => "shape", shape => "box", fontsize => "$nodeFontSize", style => "$nodeNormalStyle", color => "$nodeNormalColor", URL => "$url");
  $gviz_lca_unweighted->add_node(name => "legend_nodirect", label => "<<b>Without<br/>\nDirect<br/>\nAnnotation</b>>", xlabel => "", width => "$nodeWidth", height => "$nodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$nodeFontSize", style => "$nodeNormalStyle", color => "$nodeNormalColor", URL => "$url");
  $gviz_lca_unweighted->add_node(name => "legend_yesdirect", label => "<<b>With<br/>\nDirect<br/>\nAnnotation</b>>", xlabel => "", width => "$nodeWidth", height => "$nodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$nodeFontSize", style => "$nodeAnnotatedStyle", color => "$nodeAnnotatedColor", URL => "$url");
  $gviz_lca_unweighted->add_edge(from => "legend_nodirect", to => "legend_yesdirect", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
  $gviz_lca_unweighted->add_edge(from => "legend_root", to => "legend_nodirect", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
  $gviz_lca_unweighted->add_edge(from => "legend_legend", to => "legend_root", dir => "$direction", color => "white", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 

  $nodeWidth = &calcNodeWidth($annotationCounts{$rootId}{'any'}, $maxAnyCount);
  my $xlabel = $nodeLabels{$rootId};
  my $xhglabel = $nodeHgLabels{$rootId};
  $xlabel = qq(<b>$xlabel</b>);
  $xhglabel = qq(<b>$xhglabel</b>);
  $nodeFontSize = $nodeWidth / 1.5 * 20;
  $gviz_lca_edges->add_node(name => "$rootId_placeholder", label => "<$xlabel>", xlabel => "", width => "$nodeWidth", height => "$nodeWidth", fixedsize => "shape", shape => "box", fontsize => "$nodeFontSize", style => "$nodeNormalStyle", color => "$nodecolor", URL => "$url");
  $gviz_lca_unweighted->add_node(name => "$rootId_placeholder", label => "<$xlabel>", xlabel => "", width => "$unweightedNodeWidth", height => "$unweightedNodeWidth", fixedsize => "shape", shape => "box", fontsize => "$unweightedNodeFontSize", style => "$nodeNormalStyle", color => "$nodecolor", URL => "$url");
  $gviz_homogeneous->add_node(name => "$rootId_placeholder", label => "<$xhglabel>", xlabel => "", fixedsize => "shape", shape => "box", fontsize => "10", color => "$hiddennodecolor", URL => "$url");
  push @dot_nodes, qq($rootId_placeholder [fixedsize=true label="$nodeLabels{$rootId}"]);
  while (@annotPhenotypes) {
    $ph1 = shift @annotPhenotypes;					# compare each annotated term node to all other annotated term nodes
    my $ph1_placeholder = $ph1;
    $ph1_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
    $url = "http://www.wormbase.org/species/all/phenotype/$ph1";                              # URL to link to wormbase page for object
# #     $gviz_pruned->add_node("$ph1", label => "$nodeLabels{$ph1}", shape => "box", fontsize => "10", color => "$nodeAnnotatedColor");
#     $gviz_pruned->add_node(name => "$ph1_placeholder", label => "$nodeLabels{$ph1}", shape => "box", fontsize => "10", color => "$nodeAnnotatedColor");
#     $nodeFontSize = int( log($annotationCounts{$ph1}{'any'})/log($maxAnyCount) * 20) + 5;	# latest good one
#     $nodeWidth    = ( log($annotationCounts{$ph1}{'any'})/log($maxAnyCount) * $nodeScale ) + $nodeMinSize;
#     $nodeWidth    = ( log(sqrt($annotationCounts{$ph1}{'any'}+$logScaler))/log(sqrt($maxAnyCount+$logScaler)) * $nodeScale ) + $nodeMinSize;
#     $nodeWidth    = ( sqrt($annotationCounts{$ph1}{'any'})/sqrt($maxAnyCount) * $nodeScale ) + $nodeMinSize;
    $nodeWidth = &calcNodeWidth($annotationCounts{$ph1}{'any'}, $maxAnyCount);
    $nodeFontSize = $nodeWidth / 1.5 * 20;
#     $gviz_lca_edges->add_node("$ph1", label => "$nodeLabels{$ph1}", shape => "box", fontsize => "$nodeFontSize", color => "$nodeAnnotatedColor", URL => "$url");
#     $gviz_lca_edges->add_node(name => "$ph1_placeholder", label => "$nodeLabels{$ph1}", shape => "box", fontsize => "$nodeFontSize", color => "$nodeAnnotatedColor", URL => "$url");
    my $nodeSizeCutoffLabel = .5;
    my $fontcolor = 'black';
    my $xlabel = $nodeLabels{$ph1}; 
    $xlabel = qq(<b>$xlabel</b>);
    my $xhglabel = $nodeHgLabels{$ph1}; 
    $xhglabel = qq(<b>$xhglabel</b>);
    if ($nodeWidth < $nodeSizeCutoffLabel) { 
#       $xlabel =~ s/ /\n/g;
      $fontcolor = 'transparent'; }	# not actually transparent, goes to #fffffe, later svg global replace to rgba(0,0,0,0.01) for very low opacity
    $gviz_lca_edges->add_node(name => "$ph1_placeholder", label => "<$xlabel>", xlabel => "", width => "$nodeWidth", height => "$nodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$nodeFontSize", fontcolor => "$fontcolor", style => "$nodeAnnotatedStyle", color => "$nodeAnnotatedColor", URL => "$url");
    $gviz_lca_unweighted->add_node(name => "$ph1_placeholder", label => "<$xlabel>", xlabel => "", width => "$unweightedNodeWidth", height => "$unweightedNodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$unweightedNodeFontSize", style => "$nodeAnnotatedStyle", color => "$nodeAnnotatedColor", URL => "$url");
    $gviz_homogeneous->add_node(name => "$ph1_placeholder", label => "<$xhglabel>", xlabel => "", shape => "circle", fontsize => "10", color => "$hiddennodecolor", URL => "$url");
    my $url = 'http://www.wormbase.org/species/all/phenotype/' . $ph1 . '#03--10';
    push @dot_nodes, qq($ph1_placeholder [width="$nodeWidth" shape="circle" color="$nodeAnnotatedColor" fontcolor="$fontcolor" fixedsize=true label=<$xlabel> URL="$url" ]);
#     $gviz_lca_edges->add_node("$ph1", label => "", shape => "circle", fontsize => "$nodeFontSize", color => "$nodeAnnotatedColor", URL => "$url");
    foreach my $ph2 (@annotPhenotypes) {				# compare each annotated term node to all other annotated term nodes
      my $ph2_placeholder = $ph2;
      $ph2_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
      my $lcaHashref = &calculateLCA($ph1, $ph2);
      my %lca = %$lcaHashref;
      foreach my $lca (sort keys %lca) {
        $url = "http://www.wormbase.org/species/all/phenotype/$lca";                              # URL to link to wormbase page for object
        $allLca{$lca}++;
        my $lca_placeholder = $lca;
        $lca_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
#         print qq($ph1 - $ph2 - Lowest Common Ancestor $lca<br/>);
#         if ($phenotypes{$lca}) { $nodecolor = $nodeAnnotatedColor; } else { $nodecolor = $nodeNormalColor; }
#           $gviz_pruned->add_node("$lca", label => "$nodeLabels{$lca}", shape => "box", fontsize => "10", color => "$nodecolor");
        unless ($phenotypes{$lca}) { 					# only add lca nodes that are not annotated terms
          $nodeFontSize = int( log($annotationCounts{$lca}{'any'})/log($maxAnyCount) * 20) + 5;
#           $nodeWidth    = ( log($annotationCounts{$lca}{'any'})/log($maxAnyCount) * $nodeScale ) + $nodeMinSize;
#           $nodeWidth    = ( log(sqrt($annotationCounts{$lca}{'any'}+$logScaler))/log(sqrt($maxAnyCount+$logScaler)) * $nodeScale ) + $nodeMinSize;
#           $nodeWidth    = ( sqrt($annotationCounts{$lca}{'any'})/sqrt($maxAnyCount) * $nodeScale ) + $nodeMinSize;
          $nodeWidth = &calcNodeWidth($annotationCounts{$lca}{'any'}, $maxAnyCount);
# #           $gviz_pruned->add_node("$lca_placeholder", label => "$nodeLabels{$lca}", shape => "box", fontsize => "10", color => "$nodecolor");
#           $gviz_pruned->add_node(name => "$lca_placeholder", label => "$nodeLabels{$lca}", shape => "box", fontsize => "10", color => "$nodecolor");
# #           $gviz_lca_edges->add_node("$lca", label => "$nodeLabels{$lca}", shape => "box", fontsize => "$nodeFontSize", color => "$nodecolor", URL => "$url");
# #           $gviz_lca_edges->add_node(name => "$lca_placeholder", label => "$nodeLabels{$lca}", shape => "box", fontsize => "$nodeFontSize", color => "$nodecolor", URL => "$url");
          $fontcolor = 'black';
          $xlabel = $nodeLabels{$lca}; 
          $xlabel = qq(<b>$xlabel</b>);
          $xhglabel = $nodeHgLabels{$lca}; 
          $xhglabel = qq(<b>$xhglabel</b>);
#           $xlabel = qq(<FONT COLOR='blue'>TESTxlabel</FONT>);
#           $xlabel = qq(<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0"><TR><TD><FONT COLOR="blue">$xlabel</FONT></TD></TR></TABLE>>);
          if ($nodeWidth < $nodeSizeCutoffLabel) {
#             $xlabel =~ s/ /\n/g;
            $fontcolor = 'transparent'; }
          $nodeFontSize = $nodeWidth / 1.5 * 20;
          my $url = 'http://www.wormbase.org/species/all/phenotype/' . $lca . '#03--10';
          if ($lca_placeholder ne $rootId_placeholder) {		# don't re-create root node if it happens to be lca
            $gviz_lca_edges->add_node(name => "$lca_placeholder", label => "<$xlabel>", xlabel => "", width => "$nodeWidth", fixedsize => "shape", shape => "circle", fontcolor => "$fontcolor", fontsize => "$nodeFontSize", style => "$nodeNormalStyle", color => "$nodecolor", URL => "$url");
            $gviz_lca_unweighted->add_node(name => "$lca_placeholder", label => "<$xlabel>", xlabel => "", width => "$unweightedNodeWidth", fixedsize => "shape", shape => "circle", fontsize => "$unweightedNodeFontSize", style => "$nodeNormalStyle", color => "$nodecolor", URL => "$url");
            $gviz_homogeneous->add_node(name => "$lca_placeholder", label => "<$xhglabel>", xlabel => "", shape => "circle", fontsize => "10", color => "$hiddennodecolor", URL => "$url");
          }
          push @dot_nodes, qq($lca_placeholder [width="$nodeWidth" shape="circle" color="$nodecolor" fontcolor="$fontcolor" fixedsize=true label=<$xlabel> URL="$url"]);
#           $gviz_lca_edges->add_node("$lca", label => "", shape => "circle", fontsize => "$nodeFontSize", color => "$nodecolor", URL => "$url");
        }
#         unless ($lca eq $ph1) { 					# don't add edges connecting node to itself if lca is same as annotated term
# #           print qq(EDGE LCA $lca TO ONE $ph1<br>);
#           $gviz_pruned->add_edge(from => "$lca_placeholder", to => "$ph1_placeholder", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style"); 
#         }
#         unless ($lca eq $ph2) { 					# don't add edges connecting node to itself if lca is same as annotated term
# #           print qq(EDGE LCA $lca TO TWO $ph2<br>);
#           $gviz_pruned->add_edge(from => "$lca_placeholder", to => "$ph2_placeholder", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style"); 
#         }
#         unless ($lca eq "$rootId") { 			# don't add edges connecting root to itself if lca is same as root
# #           print qq(EDGE ROOT TO $lca<br>);
#           $gviz_pruned->add_edge(from => "$rootId_placeholder", to => "$lca_placeholder", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style"); 
#         }
      } # foreach my $lca (sort keys %lca)
    } # foreach my $ph2 (@annotPhenotypes)				# compare each annotated term node to all other annotated term nodes
  } # while (@annotPhenotypes)
#   print "Pruned Graph<br/>\n";
#   $gviz_pruned->run();                                   # generate graph as svg
#   my $svgGenerated = $gviz_pruned->dot_output();
#   my ($svgMarkup) = $svgGenerated =~ m/(<svg.*<\/svg>)/s;             # capture svg markup
#   $svgMarkup =~ s/<title>test<\/title>//g;                            # remove automatic title
#   $svgMarkup =~ s/_placeholderColon_/:/g;                             # ids can't be created with a : in them, so have to add the : after the svg is generated
#   print qq($svgMarkup);
#   print "<br><br>";

# ($var, my $debugmore) = &getHtmlVar($query, 'debugmore');

#         $edgesPtc{$obj}{$sub}++;					# any existing edge, parent to child
  my %edgesLca;								# edges that exist in graph generated from annoated terms + lca terms + root
  my @parentNodes = ($rootId);						# nodes that are parents, at first root, later any nodes that should be in graph
  while (@parentNodes) {						# while there are parent nodes, go through them
    my $parent = shift @parentNodes;					# take a parent
    my %edgesPtcCopy = %{ dclone(\%edgesPtc) };				# make a temp copy since edges will be getting deleted per parent
# print "PARENT $parent<br>";
    while (scalar keys %{ $edgesPtcCopy{$parent} } > 0) {		# while parent has children
      foreach my $child (sort keys %{ $edgesPtcCopy{$parent} }) {	# each child of parent
        if ($allLca{$child} || $phenotypes{$child}) { 			# good node, keep edge when child is an lca or annotated term
# print "P $parent C $child GOOD CHILD<br>\n";
            delete $edgesPtcCopy{$parent}{$child};			# remove from %edgesPtc, does not need to be checked further
            push @parentNodes, $child;					# child is a good node, add to parent list to check its children
            $edgesLca{$parent}{$child}++; }				# add parent-child edge to final graph
          else {							# bad node, remove and reconnect edges
# if ($debugmore eq '1') { print "P $parent C $child REMOVE CHILD<br>\n"; }
            delete $edgesPtcCopy{$parent}{$child};			# remove parent-child edge
            foreach my $grandchild (sort keys %{ $edgesPtcCopy{$child} }) {	# take each grandchild of child
# if ($debugmore eq '1') { print "P $parent C $child GC $grandchild CONNECT TO GC<br>\n"; }
              delete $edgesPtcCopy{$child}{$grandchild};		# remove child-grandchild edge
              $edgesPtcCopy{$parent}{$grandchild}++; } }		# make replacement edge between parent and grandchild
      } # foreach my $child (sort keys %{ $edgesPtcCopy{$parent} })
    } # while (scalar keys %{ $edgesPtcCopy{$parent} } > 0)
  } # while (@parentNodes)
  foreach my $parent (sort keys %edgesLca) {
    my $parent_placeholder = $parent;
    $parent_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
    foreach my $child (sort keys %{ $edgesLca{$parent} }) {
      my $child_placeholder = $child;
      $child_placeholder =~ s/:/_placeholderColon_/g;                                  # edges won't have proper title text if ids have : in them
# print "P $parent C $child EPTC<br>\n";
      $dot_edges{$child_placeholder}{$parent_placeholder}++;
      $gviz_lca_edges->add_edge(from => "$parent_placeholder", to => "$child_placeholder", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
      $gviz_lca_unweighted->add_edge(from => "$parent_placeholder", to => "$child_placeholder", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
      $gviz_homogeneous->add_edge(from => "$parent_placeholder", to => "$child_placeholder", dir => "$direction", color => "$edgecolor", fontcolor => "$edgecolor", style => "$style", arrowsize => ".3"); 
    } # foreach my $child (sort keys %{ $edgesLca{$parent} })
  } # foreach my $parent (sort keys %edgesLca)


  my $lca_edges_output = '';
#   $lca_edges_output .= "LCA Edges Graph<br/>\n";
#   $lca_edges_output .= "Weighted Graph<br/>\n";
#   my $svgGenerated = $gviz_lca_edges->as_svg;                                   # generate graph as svg
  $gviz_lca_edges->run();                                   # generate graph as svg
  my $svgGenerated = $gviz_lca_edges->dot_output();
#   my $tempfile = '/tmp/gvfile';
#   $gviz_lca_edges->run(output_file => $tempfile);                                   # generate graph as svg
#   $/ = undef;
#   open (IN, "<$tempfile") or die "Cannot open $tempfile : $!";
#   my $svgGenerated = <IN>;
#   close (IN) or die "Cannot close $tempfile : $!";
#   $/ = "";
  my ($svgMarkup) = &svgCleanup($svgGenerated, $focusTermId);
  ($svgMarkup) =~ s/<svg/<svg id="svg_weighted"/;             		# give an id to the .svg
#   my ($svgMarkup) = $svgGenerated =~ m/(<svg.*<\/svg>)/s;             # capture svg markup
# # print STDERR qq($svgMarkup\n);
#   $svgMarkup =~ s/<title>test<\/title>//g;                            # remove automatic title
#   $svgMarkup =~ s/_placeholderColon_/:/g;                             # ids can't be created with a : in them, so have to add the : after the svg is generated
#   $svgMarkup =~ s/LINEBREAK//g;                             		# remove leading hidden linebreak to offset counts of rnai and variation in transparent line afterward
#   $svgMarkup =~ s/fill="#fffffe"/fill="rgba\(0,0,0,0.01\)"/g;		# cannot set opacity value directly at creating, so setting fontcolor to transparent, which becomes #fffffe which we can replace with an rgba with very low opacity
#   my (@xlinkTitle) = $svgMarkup =~ m/xlink:title="(.*?)"/g;
#   foreach my $xlt (@xlinkTitle) {
# # print STDERR qq($xlt\n);
#     my $xltEdited = $xlt;
#     $xltEdited =~ s/&lt;br\/&gt;/\n/g;
#     $xltEdited =~ s/&lt;\/?b&gt;//g;
#     $xltEdited =~ s/&lt;font color=&quot;transparent&quot;&gt;//g;
#     $xltEdited =~ s/&lt;\/font&gt;//g;
# #     $xltEdited =~ s/&lt;[^&]*?&gt;//g;
# #     $xltEdited =~ s/<.*?>//g;
#     $xltEdited =~ s/^\n//;						# remove leading linebreak added by placeholder line break for centering label
#     $svgMarkup =~ s/$xlt/$xltEdited/g; 
# # print "XLT $xlt -> XLTE $xltEdited<br/>";
#   } # foreach my $xlt (@xlinkTitle)
# <g id="a_node3"><a xlink:href="http://www.wormbase.org/species/all/phenotype/WBPhenotype:0000576#03--10" xlink:title="&lt;b&gt;organism&lt;br/&gt;physiology&lt;br/&gt;variant&lt;br/&gt;3 RNAi; 1 Variation&lt;/b&gt;">
#   print qq($svgMarkup);
#   print qq($jsonHash{'grouped'}{'annotation_class'}{'groups'}[0]{'groupValue'}<br>\n);    
  $lca_edges_output .= "$svgMarkup";
#   $lca_edges_output .= qq(<br/><br/>);

  my $lca_unweighted_output = '';
  $gviz_lca_unweighted->run();                                   # generate graph as svg
  my $svgGenerated = $gviz_lca_unweighted->dot_output();
  my ($svgMarkup) = &svgCleanup($svgGenerated, $focusTermId);
  ($svgMarkup) =~ s/<svg/<svg id="svg_unweighted"/;             		# give an id to the .svg
  $lca_unweighted_output .= "$svgMarkup";

#   print qq(<br/><br/>);
  my $lca_homogeneous_output = '';
#   $lca_homogeneous_output .= "LCA Homogeneous Graph<br/>\n";
#   $lca_homogeneous_output .= "Unweighted Graph<br/>\n";
  $gviz_homogeneous->run();                                   # generate graph as svg
  my $svgGenerated = $gviz_homogeneous->dot_output();
  my ($svgMarkup) = &svgCleanup($svgGenerated, $focusTermId);
#   ($svgMarkup) =~ s/<svg/<svg id="svg_unweighted" style="display: none"/;             		# give an id to the .svg
  ($svgMarkup) =~ s/<svg/<svg id="svg_textonly"/;             		# give an id to the .svg
#   print qq($svgMarkup);
  $lca_homogeneous_output .= qq($svgMarkup);
#   $lca_homogeneous_output .= qq(<br/><br/>);

  my $dot_nodes = join" ", @dot_nodes;
  my $dot_edges = '';
  foreach my $child (sort keys %dot_edges) {
    my $parents = join" ", sort keys %{ $dot_edges{$child} };
    $dot_edges .= qq($child -> { $parents } [arrowsize=.3] );
  }
  my $dot_lca = qq(digraph G { rankdir=RL { node [fontsize=10 width=0.5] $dot_nodes } $dot_edges } );
#   print "<br/><br/>$dot_lca<br/>";

  my $aggregate_weighted_output = '';
#   print qq(<br/><br/>);
#   print "Aggregate Graph<br/>\n";
#   $aggregate_output .= "Aggregate Graph<br/>\n";
#   my $svgGenerated = $gviz_aggregate_weighted->as_svg;                         # generate graph as svg
  $gviz_aggregate_weighted->run();                                   # generate graph as svg
  my $svgGenerated_weighted = $gviz_aggregate_weighted->dot_output();
#   my $tempfile = '/tmp/gvfile';
#   $gviz_aggregate->run(output_file => $tempfile);                                   # generate graph as svg
#   $/ = undef;
#   open (IN, "<$tempfile") or die "Cannot open $tempfile : $!";
#   my $svgGenerated = <IN>;
#   close (IN) or die "Cannot close $tempfile : $!";
#   $/ = "";
#   my ($svgMarkup) = $svgGenerated =~ m/(<svg.*<\/svg>)/s;             # capture svg markup
#   $svgMarkup =~ s/<title>test<\/title>//g;                            # remove automatic title
#   $svgMarkup =~ s/_placeholderColon_/:/g;                             # ids can't be created with a : in them, so have to add the : after the svg is generated
  my ($svgMarkup_weighted) = &svgCleanup($svgGenerated_weighted, $focusTermId);
#   ($svgMarkup) =~ s/<svg/<svg id="svg_aggregate" style="display: none"/;             		# give an id to the .svg
  ($svgMarkup_weighted) =~ s/<svg/<svg id="svg_aggregate_weighted"/;             		# give an id to the .svg
#   print qq($svgMarkup);
#   print qq(<br/><br/>);
  $aggregate_weighted_output .= qq($svgMarkup_weighted);
#   $aggregate_output .= qq(<br/><br/>);

  my $aggregate_unweighted_output = '';
  $gviz_aggregate_unweighted->run();                                   # generate graph as svg
  my $svgGenerated_unweighted = $gviz_aggregate_unweighted->dot_output();
  my ($svgMarkup_unweighted) = &svgCleanup($svgGenerated_unweighted, $focusTermId);
  ($svgMarkup_unweighted) =~ s/<svg/<svg id="svg_aggregate_unweighted"/;             		# give an id to the .svg
  $aggregate_unweighted_output .= qq($svgMarkup_unweighted);

  if ($download) { 
    print qq(Content-type: image/svg+xml\n\n\n);
    if ($download eq 'weighted') {                   print $lca_edges_output;                }
      elsif ($download eq 'unweighted') {            print $lca_unweighted_output;           }
      elsif ($download eq 'textonly') {              print $lca_homogeneous_output;          }
      elsif ($download eq 'aggregate_weighted')   {  print $aggregate_weighted_output;       }
      elsif ($download eq 'aggregate_unweighted') {  print $aggregate_unweighted_output;     }
  } else {
    &printHtmlHeader(); 
#     print qq(Content-type: text/plain\n\n\n);
    my @types = qw( weighted unweighted textonly aggregate_unweighted aggregate_weighted );	# put these back for advisory board demo  2016 01 29
#     my @types = qw( weighted unweighted );
    foreach my $type (@types) {
      my $checked = '';
      if ($type eq 'weighted') { $checked = qq(checked="checked"); }
      print qq(<input type="radio" name="radio_type" id="radio_$type" $checked onclick="document.getElementById('svg_weighted').style.display='none'; document.getElementById('svg_unweighted').style.display='none'; document.getElementById('svg_textonly').style.display='none'; document.getElementById('svg_aggregate_weighted').style.display='none'; document.getElementById('svg_aggregate_unweighted').style.display='none'; document.getElementById('svg_$type').style.display='';">annotation $type</input> <a href="amigo.cgi?action=annotSummaryGraph&datatype=$datatype&focusTermId=$focusTermId&download=$type" target="new">view SVG</a><br/>);
#       print qq(<span onclick="document.getElementById('svg_weighted').style.display='none'; alert('blah');">hide</span>);
    }
    ($lca_unweighted_output)            =~ s/<svg/<svg style="display: none"/;             		# don't show other graphs in display
    ($lca_homogeneous_output)          =~ s/<svg/<svg style="display: none"/;             		# don't show other graphs in display
    ($aggregate_weighted_output)       =~ s/<svg/<svg style="display: none"/;             		# don't show other graphs in display
    ($aggregate_unweighted_output)     =~ s/<svg/<svg style="display: none"/;             		# don't show other graphs in display
    print $lca_edges_output;
    print $lca_unweighted_output;
    print $lca_homogeneous_output;
    print $aggregate_weighted_output;
    print $aggregate_unweighted_output;
    print qq(<br/>Reported phenotypes might be observed only using complex genetic backgrounds or conditions.<br/>);
  }


# to generate through generated dot and commandline call to generate svg
#   my $tempfiledot = '/tmp/gvfile.dot'; my $tempfilesvg = '/tmp/gvfile.svg';
#   open (OUT, ">$tempfiledot") or die "Cannot create $tempfiledot : $!";
#   print OUT $dot_lca;
#   close (OUT) or die "Cannot close $tempfiledot : $!";
#   `dot -Tsvg -q $tempfiledot > $tempfilesvg`;
#   $/ = undef;
#   open (IN, "<$tempfilesvg") or die "Cannot open $tempfilesvg : $!";
#   my $svgGenerated = <IN>;
#   close (IN) or die "Cannot close $tempfilesvg : $!";
#   $/ = "";
#   my ($svgMarkup) = $svgGenerated =~ m/(<svg.*<\/svg>)/s;             # capture svg markup
#   $svgMarkup =~ s/<title>test<\/title>//g;                            # remove automatic title
#   $svgMarkup =~ s/_placeholderColon_/:/g;                             # ids can't be created with a : in them, so have to add the : after the svg is generated
# #   $svgMarkup =~ s/(font-size="10.00")/font-weight="bold" $1/g;		# cannot set font-weight, adding it to all with font-size = 10
#   $svgMarkup =~ s/fill="#fffffe"/fill="rgba\(0,0,0,0.01\)"/g;		# cannot set opacity value directly at creating, so setting fontcolor to transparent, which becomes #fffffe which we can replace with an rgba with very low opacity
#   print qq($svgMarkup<br/>\n);

#   print "<br/><br/>AFTERWARD<br/>";

    # link 2  foreach wbphenotype, get nodes and edges from
#   my $phenotypeId = 'WBPhenotype:0000637';
#   my $phenotype_solr_url = $solr_url . 'select?qt=standard&fl=regulates_transitivity_graph_json&version=2.2&wt=json&indent=on&rows=1&fq=-is_obsolete:true&fq=document_category:%22ontology_class%22&q=id:%22' . $phenotypeId . '%22';
# http://131.215.12.204:8080/solr/phenotype/select?qt=standard&fl=regulates_transitivity_graph_json&version=2.2&wt=json&indent=on&rows=1&fq=-is_obsolete:true&fq=document_category:%22ontology_class%22&q=id:%22WBPhenotype:0000637%22
} # sub annotSummaryGraph

sub svgCleanup {
  my ($svgGenerated, $focusTermId) = @_;
  my ($svgMarkup) = $svgGenerated =~ m/(<svg.*<\/svg>)/s;             # capture svg markup
# print STDERR qq($svgMarkup\n);
  my ($height, $width) = ('', '');
  if ($svgMarkup =~ m/<svg width="(\d+)pt" height="(\d+)pt"/) { $width = $1; $height = $2; }
  my $hwratio = $height / $width;
  my $widthResolution = 960;
  if ($width > $widthResolution) { 
    my $newwidth  = $widthResolution;
    my $newheight = int($newwidth * $hwratio);
    $svgMarkup =~ s/<svg width="${width}pt" height="${height}pt"/<svg width="${newwidth}pt" height="${newheight}pt"/g;
  }
#   $svgMarkup =~ s/<title>legend_legend--legend_root<\/title>//g;                            # remove automatic title
#   $svgMarkup =~ s/<title>legend_legend<\/title>//g;                            # remove automatic title
#   $svgMarkup =~ s/<title>legend_root<\/title>//g;                            # remove automatic title
#   $svgMarkup =~ s/<title>legend_nodirect<\/title>//g;                            # remove automatic title
  $svgMarkup =~ s/<title>[^<]*?<\/title>/<title>${focusTermId}Phenotypes<\/title>/g;                            # remove automatic title
  $svgMarkup =~ s/<title>test<\/title>//g;                            # remove automatic title
  $svgMarkup =~ s/<title>Perl<\/title>//g;                            # remove automatic title
  $svgMarkup =~ s/_placeholderColon_/:/g;                             # ids can't be created with a : in them, so have to add the : after the svg is generated
  $svgMarkup =~ s/LINEBREAK//g;                             		# remove leading hidden linebreak to offset counts of rnai and variation in transparent line afterward
  $svgMarkup =~ s/fill="#fffffe"/fill="rgba\(0,0,0,0.01\)"/g;		# cannot set opacity value directly at creating, so setting fontcolor to transparent, which becomes #fffffe which we can replace with an rgba with very low opacity
  my (@xlinkTitle) = $svgMarkup =~ m/xlink:title="(.*?)"/g;
  foreach my $xlt (@xlinkTitle) {
# print STDERR qq($xlt\n);
    my $xltEdited = $xlt;
    $xltEdited =~ s/&lt;br\/&gt;/\n/g;
    $xltEdited =~ s/&lt;\/?b&gt;//g;
    $xltEdited =~ s/&lt;font color=&quot;transparent&quot;&gt;//g;
    $xltEdited =~ s/&lt;\/font&gt;//g;
#     $xltEdited =~ s/&lt;[^&]*?&gt;//g;
#     $xltEdited =~ s/<.*?>//g;
    $xltEdited =~ s/^\n//;						# remove leading linebreak added by placeholder line break for centering label
    $svgMarkup =~ s/$xlt/$xltEdited/g; 
# print "XLT $xlt -> XLTE $xltEdited<br/>";
  } # foreach my $xlt (@xlinkTitle)
  return $svgMarkup;
} # sub svgCleanup

sub calculateLCA {						# find all lowest common ancestors
  my ($ph1, $ph2) = @_;
  my @terms = ( $ph1, $ph2 );
  my %amountInBoth;
  my %inBoth;							# get all nodes that are in both sets
  foreach my $annotTerm (@terms) {
    foreach my $phenotype (sort keys %{ $nodesAll{$annotTerm} }) {
      $amountInBoth{$phenotype}++; } }
  foreach my $term (sort keys %amountInBoth) { if ($amountInBoth{$term} > 1) { $inBoth{$term}++; } }
  %ancestorNodes = ();
#   foreach my $inBoth (sort keys %inBoth) { print qq($ph1, $ph2 INB $inBoth<br>); }
  foreach my $annotTerm (@terms) {
    foreach my $child (sort keys %{ $edgesAll{$annotTerm} }) {
      if ($inBoth{$child}) {
        foreach my $parent (sort keys %{ $edgesAll{$annotTerm}{$child} }) { $ancestorNodes{$parent}++; } } } }
  my %lca;
  foreach my $bothNode (sort keys %inBoth) {
    unless ($ancestorNodes{$bothNode}) { $lca{$bothNode}++; }
#     print qq($ph1 $ph2 BOTH $bothNode -- );
#     if ($ancestorNodes{$bothNode}) { print qq(ANCESTOR $bothNode --); }
#     print qq(<br/>);
  }
  return \%lca;
} # sub calculateLCA

# sub addToAncestors {
#   my ($annotTerm, $bothNode) = @_;
#   foreach my $parent (sort keys %{ $edgesAll{$annotTerm}{$bothNode} }) {
# print qq(AT $annotTerm CHILD $bothNode PARENT $parent<br>);
#     $ancestorNodes{$parent}++;
#     &addToAncestors($annotTerm, $parent);
#   }
# } # sub addToAncestors

sub dag {
  &printHtmlHeader(); 

#   my ($var, $val) = &getHtmlVar($query, 'goid');
  my ($var, $val) = &getHtmlVar($query, 'focusTermId');

  my $focusTermId = "GO:0033554";		# default focusTermId if none given
  if ($val) { $focusTermId = $val; }

  my ($topoHashref, $transHashref) = &getTopoHash($focusTermId);
  my %topo = %$topoHashref;
  my %trans = %$transHashref;

#   This is bad, transitivity is not correct in the  regulates_transitivity_graph_json  from berkeleybop
#   my ($topoHashref, $transHashref) = &getTopoHash($goid);
#   my %trans = %$transHashref;
#   my %transitivity;
#   for my $index (0 .. @{ $trans{"edges"} }) {
#     my ($sub, $obj, $pred) = ('', '', '');
#     if ($trans{"edges"}[$index]{'sub'}) {  $sub  = $trans{"edges"}[$index]{'sub'};  }
#     if ($trans{"edges"}[$index]{'obj'}) {  $obj  = $trans{"edges"}[$index]{'obj'};  }
#     if ($trans{"edges"}[$index]{'pred'}) { $pred = $trans{"edges"}[$index]{'pred'}; }
#     $transitivity{$obj} = $pred;
#   }

#   my %children; 			# children of the wanted goid, value is relationship type (predicate) ; are the corresponding nodes on an edge where the object is the goid
#   my %parents;				# direct parents of the wanted goid, value is relationship type (predicte) ; are the corresponding nodes on an edge where the subject is the goid
#   my (@edges) = @{ $topo{"edges"} };
#   for my $index (0 .. @edges) {
#     my ($sub, $obj, $pred) = ('', '', '');
#     if ($edges[$index]{'sub'}) { $sub = $edges[$index]{'sub'}; }
#     if ($edges[$index]{'obj'}) { $obj = $edges[$index]{'obj'}; }
#     if ($edges[$index]{'pred'}) { $pred = $edges[$index]{'pred'}; }
#     if ($obj eq $goid) { $children{$sub} = $pred; }		# track children here
#     if ($sub eq $goid) { $parents{$obj}  = $pred; }		# track parents here
#   }

  my ($childrenHashref, $parentsHashref) = &getTopoChildrenParents($focusTermId, $topoHashref);
  my %children = %$childrenHashref;
  my %parents  = %$parentsHashref;

  my %colorMap;
  $colorMap{"is_a"}                          = 'black';
  $colorMap{"part_of"}                       = 'blue';
  $colorMap{"has_part"}                      = 'purple';
  $colorMap{"regulates"}                     = 'orange';
  $colorMap{"positively_regulates"}          = 'green';
  $colorMap{"negatively_regulates"}          = 'red';
  $colorMap{"occurs_in"}                     = 'cyan';
  $colorMap{"daughter_of"}                   = 'pink';
  $colorMap{"daughter_of_in_hermaphrodite"}  = 'pink';
  $colorMap{"daughter_of_in_male"}           = 'pink';
  $colorMap{"develops_from"}                 = 'brown';
  $colorMap{"xunion_of"}                     = 'brown';
  $colorMap{"exclusive_union_of"}            = 'brown';
  my %edgeTypeExists;
  
  my %child;				# for any term, each subkey is a child
  my (@edges) = @{ $topo{"edges"} };
  for my $index (0 .. @edges) {
    my ($sub, $obj, $pred) = ('', '', '');
    if ($edges[$index]{'sub'}) {  $sub  = $edges[$index]{'sub'};  }
    if ($edges[$index]{'obj'}) {  $obj  = $edges[$index]{'obj'};  }
    if ($edges[$index]{'pred'}) { $pred = $edges[$index]{'pred'}; }
    if ($sub && $obj && $pred) { 
      if ($children{$sub}) { next; }	# don't add edge for the children
      my $color = 'black'; if ($colorMap{$pred}) { $color = $colorMap{$pred}; $edgeTypeExists{$pred}++; }
#       $paths{"parentToChild"}{"$obj"}{"$sub"} = $pred;	# put all child nodes under parent node	# NOT USED 
      $paths{"childToParent"}{"$sub"}{"$obj"} = $pred;	# put all parent nodes under child node
      $child{$sub}{$obj}++;
#       $gviz->add_edge("$obj" => "$sub", dir => "back", label => "$pred", color => "$color", fontcolor => "$color");
      $gviz->add_edge("$obj" => "$sub", dir => "back", color => "$color", fontcolor => "$color");
#       print qq("$obj" => "$sub", dir => "back", PRED $pred : color => "$color", fontcolor => "$color"<br>\n);
    } # if ($sub && $obj && $pred)
  } # for my $index (0 .. @edges)

  my %label;				# id to name
  my (@nodes) = @{ $topo{"nodes"} };
  for my $index (0 .. @nodes) {
    my ($id, $lbl) = ('', '');
    if ($nodes[$index]{'id'}) { $id = $nodes[$index]{'id'}; }
    if ($nodes[$index]{'lbl'}) { $lbl = $nodes[$index]{'lbl'}; }
    $label{$id} = $lbl;
    if ($children{$id}) { next; }	# don't add node for the children
#     unless ($id eq $focusTermId) { $ancestors{$id}++; }		# ancestors are nodes that are neither the GOID nor its children ; should come from transitivity not topology 2013 10 31
    my $url = "amigo.cgi?action=Tree&focusTermId=$id";
    $lbl =~ s/ /\\n/g;
    if ($id && $lbl) { $gviz->add_node("$id", label => "$id\n$lbl", shape => "box", fontsize => "10", color => "red", URL => "$url"); }	# have GOID and name in the node
  }

  foreach my $pred (sort keys %edgeTypeExists) {
    my $color = $colorMap{$pred};
    $gviz_legend->add_node("A_$pred", label => "A", shape => "box", fontsize => "10", color => "red");
    $gviz_legend->add_node("B_$pred", label => "B", shape => "box", fontsize => "10", color => "red");
    $gviz_legend->add_edge("A_$pred" => "B_$pred", label => "$pred", color => "$color", fontsize => "10", fontcolor => "black");
    print qq(<span style="color:$color">------> </span>$pred<br/>\n);	# make a legend using html, it's not in the same style as graphViz
  }

#   print qq(<embed width="200" height="100" type="image/svg+xml" src="whatsource.svg">\n);	# if generating an image and embedding it
  my $svgGenerated = $gviz->as_svg;
  my ($svgMarkup) = $svgGenerated =~ m/(<svg.*<\/svg>)/s;
  print qq($svgMarkup\n);
#   print qq(</embed>\n);

    # make a legend using graphViz, it's kind of bulky
  my $svgLegendGenerated = $gviz_legend->as_svg;
  my ($svgLegendMarkup) = $svgLegendGenerated =~ m/(<svg.*<\/svg>)/s;
  print qq($svgLegendMarkup\n);

  my $parent_table = '';
  if (scalar keys %parents > 0) { 
    $parent_table .= qq(<br/><br/><br/><br/>);
    $parent_table .= qq(parents of <span style="color:green">$focusTermId : $label{$focusTermId}</span> : \n);
    foreach my $parent (sort keys %parents) {
      my $relationship = $parents{$parent};
      my $name = $label{$parent};
      my ($link_parent) = &makeLink($parent, $parent);
      my ($link_name) = &makeLink($parent, $name);
#       my $siblingsLink = qq(<br/><span style="text-decoration: underline; color: blue; cursor: pointer;" onclick="toggleShowHide('table_siblings_$parent');">display siblings</span>);
#       $parent_table .= qq($siblingsLink through parent $link_parent $relationship $link_name);
      my $siblingsLink = qq(<span id="span_plusMinus_$parent" style="border:solid 1px black; cursor: pointer;" onclick="togglePlusMinus('span_plusMinus_$parent'); toggleShowHide('table_siblings_$parent');">&nbsp;+&nbsp;</span>);
      $parent_table .= qq(<br/>$link_parent $siblingsLink);
#       my ($topoHashref) = &getTopoHash($parent);
      my ($topoHashref, $transHashref) = &getTopoHash($parent);
      my %topo  = %$topoHashref;
      my %trans = %$transHashref;

      my (@nodes) = @{ $topo{"nodes"} };		# use nodes to add sibling focusTermId labels to %label
      for my $index (0 .. @nodes) {
        my ($id, $lbl) = ('', '');
        if ($nodes[$index]{'id'}) { $id = $nodes[$index]{'id'}; }
        if ($nodes[$index]{'lbl'}) { $lbl = $nodes[$index]{'lbl'}; }
        $label{$id} = $lbl; }

      my ($siblingsHashref, $grandparentsHashref) = &getTopoChildrenParents($parent, $topoHashref);
      my %siblings = %$siblingsHashref;
      my @siblingRows = ();
      foreach my $sibling (sort keys %siblings) {
        next if ($sibling eq $focusTermId);
        my $sib_rel = $siblings{$sibling};
        my $name = $label{$sibling};
        my ($link_sibling) = &makeLink($sibling, $sibling);
        my ($link_name) = &makeLink($sibling, $name);
#         $parent_table .= qq( $sib_rel $link_sibling $link_name <br/> );
        push @siblingRows, qq(<tr><td width="30"></td><td>$sib_rel</td><td>$link_sibling</td><td>$link_name</tr>);
      }
      if (scalar @siblingRows > 0) {
        $parent_table .= qq(<table id="table_siblings_$parent" style="display: none">);
        foreach my $siblingRow (@siblingRows) { $parent_table .= $siblingRow; }
        $parent_table .= qq(</table>); }
    } # foreach my $parent (sort keys %parents)
  }
  if ($parent_table) { print $parent_table; }
  

  my $child_table = ''; my $ancestor_table = '';
    $child_table .= "children : <br/>\n";
    $child_table .= qq(<table border="1"><tr><th>relationship</th><th>id</th><th>name</th></tr>\n);
    foreach my $child (sort keys %children) {
      my $relationship = $children{$child};
      my ($link_child) = &makeLink($child, $child);
      my $child_name = $label{$child};
      my ($link_childname) = &makeLink($child, $child_name);
      $child_table .= qq(<tr><td>$relationship</td><td>$link_child</td><td>$link_childname</td></tr>\n);
    } # foreach my $child (sort keys %children)
    $child_table .= qq(</table>\n);
# to display childer table, uncomment
#   if ($child_table) { print $child_table; }

  my %ancestors;			# ancestors are nodes that are neither the GOID nor its children
  my (@tnodes) = @{ $trans{"nodes"} };	# for inferred tree view, use transitivity instead of topology
  for my $index (0 .. @tnodes) {
    my ($id, $lbl) = ('', '');
    if ($tnodes[$index]{'id'}) { $id = $tnodes[$index]{'id'}; }
#     if ($children{$id}) { next; }	# don't add node for the children
    unless ($id eq $focusTermId) { $ancestors{$id}++; }		# ancestors are nodes that are neither the GOID nor its children
  } 

  my %inferredTree;		# sort nodes by depth of steps (longest path)
  my $max_indent = 0;		# how many steps is the longest path, will indent that much
  $ancestor_table .= "ancestors : <br/>\n";
  $ancestor_table .= qq(<table border="1"><tr><th>steps</th><th>relationship</th><th>id</th><th>name</th></tr>\n);
  foreach my $ancestor (sort keys %ancestors) {
    next unless $ancestor;
#     my ($directNumFound, $inferredNumFound) = &getDirectInferredGenes($ancestor);
    my ($inferredLink) = &getInferredGenesHrefTarget($ancestor);	# raymond + chris don't care about gene counts for ancestors
#     my ($directLink)   = &getDirectGenesHrefTarget($ancestor);	# raymond + chris don't care about gene counts for ancestors
    my ($link_ancestor) = &makeLink($ancestor, $ancestor);
    my $ancestor_name = $label{$ancestor};
    my ($link_ancestorname) = &makeLink($ancestor, $ancestor_name);
#     my ($max_steps) = &getLongestPath( $ancestor, $focusTermId );		# most steps between ancestor and focusTermId
    my ($max_steps, $relationship) = &getLongestPathAndTransitivity( $ancestor, $focusTermId );	# given focusTermId and ancestor, get the longest path and dominant inferred transitivity
    my $indentation = $max_steps - 1; if ($indentation > $max_indent) { $max_indent = $indentation; }
    $inferredTree{$indentation}{qq($relationship : $link_ancestor $link_ancestorname [${inferredLink}])}++;	# raymond solr virtual server is really fast, added them back
#     $inferredTree{$indentation}{qq($relationship : $link_ancestor $link_ancestorname gene products: ${directLink}, ${inferredLink})}++;	# raymond + chris don't care about gene counts for ancestors
#     $inferredTree{$indentation}{qq($relationship : $link_ancestor $link_ancestorname)}++;	# raymond + chris don't care about gene counts for ancestors
    $ancestor_table .= qq(<tr><td>$max_steps</td><td>$relationship</td><td>$link_ancestor</td><td>$link_ancestorname</td></tr>\n);
  } # foreach my $ancestor (sort keys %ancestors)
  $ancestor_table .= qq(</table>\n);
# to display ancestor table, uncomment
#   print $ancestor_table;

  print "<br/><br/><br/>\n";
  my $spacer = '&nbsp;&nbsp;&nbsp;';
  foreach my $depth (reverse sort {$a<=>$b} keys %inferredTree) {
    foreach my $row (sort keys %{ $inferredTree{$depth} }) {
      my $indentation = $max_indent - $depth;			# indentation is max indent minux depth
      for (1 .. $indentation) { print $spacer; }		# for each indentation print the corresponding spacer
      print qq($row<br/>\n); } }				# print the data row
  for (1 .. $max_indent) { print $spacer; }			# add indentation for main term
#   my ($directNumFound, $inferredNumFound) = &getDirectInferredGenes($goid);
#   my ($inferredLink) = &getInferredGenesHrefTarget($goid);	# slow to get each count from its own url
#   my ($directLink)   = &getDirectGenesHrefTarget($goid);	# slow to get each count from its own url
#   my ($directGenesCountHashref)   = &getGenesCountHash($goid, 'direct');	# get hash of goid to direct genes count
  my ($inferredGenesCountHashref) = &getGenesCountHash($focusTermId, 'inferred');	# get hash of focusTermId to inferred genes count
#   my %directGenesCount   = %$directGenesCountHashref;
#   my $directLink   = &makeGenesLink($goid, $directGenesCount{$goid},   'direct');
  my %inferredGenesCount = %$inferredGenesCountHashref;
#   my $inferredLink = &makeGenesLink($goid, $inferredGenesCount{$goid}, 'inferred');
  my $inferredLink = &makeGenesLink($focusTermId, $inferredGenesCount{$focusTermId}, $label{$focusTermId});
#   print qq($spacer<span style="color:green">$goid : $label{$goid}</span> gene products: ${inferredLink}<br/>\n);	# add data for main term
  print qq($spacer<span style="color:green">$focusTermId : $label{$focusTermId}</span> [${inferredLink}]<br/>\n);	# add data for main term
  foreach my $child (sort keys %children) {			# for each child
#     my ($directNumFound, $inferredNumFound) = &getDirectInferredGenes($child);
#     my ($inferredLink) = &getInferredGenesHrefTarget($child);	# slow to get each count from its own url
#     my ($directLink) = &getDirectGenesHrefTarget($child);	# slow to get each count from its own url
#     my $directLink   = &makeGenesLink($child, $directGenesCount{$child},   'direct');
#     my $inferredLink = &makeGenesLink($child, $inferredGenesCount{$child}, 'inferred');
    my $inferredLink = &makeGenesLink($child, $inferredGenesCount{$child}, $label{$child});
    my $relationship = $children{$child};
    my ($link_child) = &makeLink($child, $child);		# make link to id
    my $child_name = $label{$child};
    my ($link_childname) = &makeLink($child, $child_name);	# make link to name
    for (1 .. $max_indent) { print $spacer; }			# add indentation for children term
    print $spacer . $spacer . qq($relationship : $link_child $link_childname [${inferredLink}]<br/>\n);	# add data for child
#     print $spacer . $spacer . qq($relationship : $link_child $link_childname gene products: ${inferredLink}<br/>\n);	# add data for child
  } # foreach my $child (sort keys %children)

  print qq(<br/><br/>\n);

  &treeExpand();
  
  &printHtmlFooter(); 
} # sub dag

sub makeGenesLink {				# give a focusTermId, number of genes for that focusTermId, and direct vs inferred ;  create a link to show the genes
#   my ($goid, $numFound, $directOrInferred) = @_;
  my ($focusTermId, $numFound, $focusTermName) = @_;		# always show inferred genes, not direct, and pass name of focusTermId
#   my $link = "0 $directOrInferred";		# by default there are zero of the given direct vs inferred
  my $link = "0 gene products";			# by default there are zero of the given direct vs inferred
  if ($numFound > 0) {				# if there's at least one gene, make the link to this CGI
#     $link = qq(<a target="new" href="amigo.cgi?action=showGenes&directOrInferred=$directOrInferred&goid=$goid">$numFound ($directOrInferred)</a>);
#     $link = qq(<a target="new" href="amigo.cgi?action=showGenes&focusTermName=$focusTermName&goid=$goid">$numFound (inferred)</a>);
    $link = qq(<a target="new" href="amigo.cgi?action=showGenes&focusTermName=$focusTermName&focusTermId=$focusTermId">$numFound gene products</a>); }
  return $link;
} # makeGenestLink

sub getGenesCountHash {				# for a given focusTermId, get the genes count of itself and its direct children, option direct or inferred genes
  my ($focusTermId, $directOrInferred) = @_;
  my %genesCount;				# count of genes for the given direct vs inferred
  my ($solr_url) = &getSolrUrl($focusTermId);
#   my $url = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&q=document_category:bioentity&facet=true&facet.field=annotation_class_list&facet.limit=-1&facet.mincount=1&facet.prefix=GO&facet.sort=count&fq=source:%22WB%22&fq=annotation_class_list:%22' . $focusTermId . '%22';
  my $url = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&q=document_category:bioentity&facet=true&facet.field=annotation_class_list&facet.limit=-1&facet.mincount=1&facet.sort=count&fq=source:%22WB%22&fq=annotation_class_list:%22' . $focusTermId . '%22';
# print "URL $url URL";		# currently not getting the right counts because facet_count->facet_fields->annotation_class_list is empty.  2013 11 09
  my $searchField = 'annotation_class_list';	# by default assume direct search for URL and JSON field
  if ($directOrInferred eq 'inferred') { 	# if inferred, change the URL and JSON field
    $searchField = 'regulates_closure';
    $url = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&q=document_category:bioentity&facet=true&facet.field=regulates_closure&facet.limit=-1&facet.mincount=1&facet.sort=count&fq=source:%22WB%22&fq=regulates_closure:%22' . $focusTermId . '%22'; }
  my $page_data = get $url;
  my $perl_scalar = $json->decode( $page_data );
  my %jsonHash = %$perl_scalar;

  $genesCount{$focusTermId} = $jsonHash{'response'}{'numFound'}; 	# get the main focusTermId gene count and store in %genesCount
  while (scalar @{ $jsonHash{'facet_counts'}{'facet_fields'}{$searchField} } > 0) {	# while there are pairs of genes/count in the JSON array
    my $focusTermId = shift @{ $jsonHash{'facet_counts'}{'facet_fields'}{$searchField} }; # get the focusTermId
    my $count = shift @{ $jsonHash{'facet_counts'}{'facet_fields'}{$searchField} }; 	# get the count
    $genesCount{$focusTermId} = $count;							# add the mapping to %genesCount
  } # while (scalar @{ $jsonHash{'facet_counts'}{'facet_fields'}{$searchField} } > 0)

  return \%genesCount;
} # sub getGenesCountHash

sub showGenes {					# page to show gene products linked to a focusTermId
  &printHtmlHeader(); 
  my ($var, $focusTermId) = &getHtmlVar($query, 'focusTermId');
#   my ($var, $directOrInferred) = &getHtmlVar($query, 'directOrInferred');
  my ($var, $focusTermName) = &getHtmlVar($query, 'focusTermName');
  my %url;
  my ($solr_url) = &getSolrUrl($focusTermId);
  $url{"direct"} = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&fl=id,bioentity_label&start=0&rows=10000000&q=document_category:bioentity&fq=source:%22WB%22&fq=%7B!cache=false%7Dannotation_class_list:%22'. $focusTermId . '%22';	# with wbgenes listed, more specific q, cache off
  $url{"inferred"} = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&fl,bioentity_label=id&start=0&rows=10000000&q=document_category:bioentity&fq=source:%22WB%22&fq=%7B!cache=false%7Dregulates_closure:%22' . $focusTermId . '%22';	# with wbgenes listed, more specific q, cache off
  foreach my $type (sort keys %url) {
    my $url = $url{$type};
    my $page = get $url; my $numFound = 0; my @genes;
    if ($page =~ m/"numFound":(\d+),/) { $numFound = $1; }
    if ($numFound > 0) {							# if there are genes to show
      if ($type eq 'direct') {				# direct have one message
          print qq(List of $numFound genes that were annotated with $focusTermId $focusTermName.<br/>\n); }
        elsif ($type eq 'inferred') {				# inferred have another message
          print qq(List of $numFound genes that were annotated with $focusTermId $focusTermName or any of its transitive descendant terms.<br/>\n); }
  my $perl_scalar = $json->decode( $page );
  my %jsonHash = %$perl_scalar;
  foreach my $hashRef (@{ $jsonHash{"response"}{"docs"} }) {
    my $id   = $$hashRef{'id'};
    my $name = $$hashRef{'bioentity_label'};
    if ($id =~ m/^WB:/) { $id =~ s/^WB://; }
    my $url = 'http://www.wormbase.org/species/c_elegans/gene/' . $id;
    print qq(<a href="$url">$id</a> <a href="$url">$name</a><br/>\n)
  }

#       (@genes) = $page =~ m/"id":"WB:(WBGene\d+)"/g;			# gene the genes
#       foreach my $gene (sort @genes) { print qq($gene<br/>\n); }		# and list the genes
    } # if ($numFound > 0)
    print qq(<br/>\n);
  } # foreach my $type (sort keys %url)
    

#   my $url = 'http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&q=document_category:bioentity&fq=source:%22WB%22&fq=%7B!cache=false%7Dannotation_class_list:%22'. $goid . '%22';	# with wbgenes listed, more specific q, cache off
#   if ($directOrInferred eq 'inferred') {
#     $url = 'http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&q=document_category:bioentity&fq=source:%22WB%22&fq=%7B!cache=false%7Dregulates_closure:%22' . $goid . '%22'; }	# with wbgenes listed, more specific q, cache off
#   my $page = get $url; my $numFound = 0; my @genes;
#   if ($page =~ m/"numFound":(\d+),/) { $numFound = $1; }
#   if ($numFound > 0) {							# if there are genes to show
#     if ($directOrInferred eq 'direct') {				# direct have one message
#         print qq(List of $numFound genes that were annotated with $goid .<br/>\n); }
#       elsif ($directOrInferred eq 'inferred') {				# inferred have another message
#         print qq(List of $numFound genes that were annotated with $goid or any of its transitive descendant terms.<br/>\n); }
#     (@genes) = $page =~ m/"id":"WB:(WBGene\d+)"/g;			# gene the genes
#     foreach my $gene (sort @genes) { print qq($gene<br/>\n); }		# and list the genes
#   } # if ($numFound > 0)
  &printHtmlFooter(); 
} # sub showGenes

sub getLongestPathAndTransitivity {			# given two nodes, get the longest path and dominant inferred transitivity
  my ($ancestor, $focusTermId) = @_;					# the ancestor and focusTermId from which to find the longest path
  &recurseLongestPath($focusTermId, $focusTermId, $ancestor, $focusTermId);	# recurse to find longest path given current, start, end, and list of current path
  my $max_nodes = 0;							# the most nodes found among all paths travelled
  my %each_finalpath_transitivity;					# hash of inferred sensitivity value for each path that finished
  foreach my $finpath (@{ $paths{"finalpath"} }) {			# for each of the paths that reached the end node
    my $nodes = scalar @$finpath;					# amount of nodes in the path
    if ($nodes > $max_nodes) { $max_nodes = $nodes; }			# if more nodes than max, set new max

    my $child = shift @$finpath; my $parent = shift @$finpath;		# get first node and its parent along this path
    my $relationship_one = $paths{"childToParent"}{$child}{$parent};	# get relationship between them (from json)
    my $relationship_two = '';						# initialize relationship between parent and its parent 
    while (scalar @$finpath > 0) {					# while there are steps in the path
      $child = $parent;							# the child in the new step is the previous parent
      $parent = shift @$finpath;					# the new parent is the next node in the path
      $relationship_two = $paths{"childToParent"}{$child}{$parent};	# the second relationship is the relationship between this pair
      $relationship_one = &getInferredRelationship($relationship_one, $relationship_two); 	# get inferred relationship given those two relationships
    }
    $each_finalpath_transitivity{$relationship_one}++;			# add final inferred transitivity relationship to hash
  } # foreach my $finpath (@finalpath)
  delete $paths{"finalpath"};						# reset finalpath for other ancestors
  my $max_steps = $max_nodes - 1;					# amount of steps is one less than amount of nodes

  my %transitivity_priority;						# when different paths have different inferred transitivity, highest number takes precedence
  $transitivity_priority{"is_a"}                 = 1;
  $transitivity_priority{"has_part"}             = 2;
  $transitivity_priority{"part_of"}              = 3;
  $transitivity_priority{"regulates"}            = 4;
  $transitivity_priority{"negatively_regulates"} = 5;
  $transitivity_priority{"positively_regulates"} = 6;
  $transitivity_priority{"occurs_in"}            = 7;
  $transitivity_priority{"unknown"}              = 8;			# in case some relationship or pair of relationships is unaccounted for
  my @all_inferred_paths_transitivity = sort { $transitivity_priority{$b} <=> $transitivity_priority{$a} } keys %each_finalpath_transitivity ;
									# sort all inferred transitivities by highest precedence
  my $dominant_inferred_transitivity = shift @all_inferred_paths_transitivity;	# dominant is the one with highest precedence
  return ($max_steps, $dominant_inferred_transitivity);			# return the maximum number of steps and dominant inferred transitivity
# my ($relationship) = &getInferredRelationship($one, $two); 
} # sub getLongestPathAndTransitivity 

sub recurseLongestPath {

  my ($current, $start, $end, $curpath) = @_;				# current node, starting node, end node, path travelled so far
  my %ignoreNonTransitivePredicate;					# there predicate relationships from the topoHash are non transitive and should be ignored for determining indendation depth (pretend the edge doesn't exist) 2013 11 13
  $ignoreNonTransitivePredicate{"daughter_of"}++;
  $ignoreNonTransitivePredicate{"daughter_of_in_hermaphrodite"}++;
  $ignoreNonTransitivePredicate{"daughter_of_in_male"}++;
  $ignoreNonTransitivePredicate{"develops_from"}++;
  $ignoreNonTransitivePredicate{"exclusive_union_of"}++;
  foreach my $parent (sort keys %{ $paths{"childToParent"}{$current} }) {	# for each parent of the current node
    next if ($ignoreNonTransitivePredicate{$paths{"childToParent"}{$current}{$parent}});	# skip non-transitive edges
    my @curpath = split/\t/, $curpath;					# convert current path to array
    push @curpath, $parent;						# add the current parent
    if ($parent eq $end) {						# if current parent is the end node
        my @tmpWay = @curpath;						# make a copy of the array
        push @{ $paths{"finalpath"} }, \@tmpWay; }			# put a reference to the array copy into the finalpath
      else {								# not the end node yet
        my $curpath = join"\t", @curpath;				# pass literal current path instead of reference
        &recurseLongestPath($parent, $start, $end, $curpath); }		# recurse to keep looking for the final node
  } # foreach $parent (sort keys %{ $paths{"childToParent"}{$current} })
} # sub recurseLongestPath

sub getInferredRelationship {
  my ($one, $two) = @_; my $relationship = 'unknown';
  if ($one eq 'is_a') {
      if ($two eq 'is_a') {                     $relationship = 'is_a';                  }
      elsif ($two eq 'part_of') {               $relationship = 'part_of';               }
      elsif ($two eq 'regulates') {             $relationship = 'regulates';             }
      elsif ($two eq 'positively_regulates') {  $relationship = 'positively_regulates';  }
      elsif ($two eq 'negatively_regulates') {  $relationship = 'negatively_regulates';  }
      elsif ($two eq 'has_part') {              $relationship = 'has_part';              } }
    elsif ($one eq 'part_of') { 
      if ($two eq 'is_a') {                     $relationship = 'part_of';               }
      elsif ($two eq 'part_of') {               $relationship = 'part_of';               } }
    elsif ($one eq 'regulates') { 
      if ($two eq 'is_a') {                     $relationship = 'regulates';             }
      elsif ($two eq 'part_of') {               $relationship = 'regulates';             } }
    elsif ($one eq 'positively_regulates') { 
      if ($two eq 'is_a') {                     $relationship = 'positively_regulates';  }
      elsif ($two eq 'part_of') {               $relationship = 'regulates';             } }
    elsif ($one eq 'negatively_regulates') { 
      if ($two eq 'is_a') {                     $relationship = 'negatively_regulates';  }
      elsif ($two eq 'part_of') {               $relationship = 'regulates';             } }
    elsif ($one eq 'has_part') { 
      if ($two eq 'is_a') {                     $relationship = 'has_part';              }
      elsif ($two eq 'has_part') {              $relationship = 'has_part';              } }
  return $relationship;
} # sub getInferredRelationship

sub makeLink {
  my ($focusTermId, $text) = @_;
  my $url = "amigo.cgi?action=Tree&focusTermId=$focusTermId";
  my $link = qq(<a href="$url">$text</a>);
  return $link;
} # sub makeLink

sub printHtmlFooter { print qq(</body></html>\n); }

sub printHtmlHeader { 
  my $javascript = << "EndOfText";
<script src="http://code.jquery.com/jquery-1.9.1.js"></script>
<!--<script src="amigo.js"></script>-->
<script type="text/javascript">
function toggleShowHide(element) {
    document.getElementById(element).style.display = (document.getElementById(element).style.display == "none") ? "" : "none";
    return false;
}
function togglePlusMinus(element) {
    document.getElementById(element).innerHTML = (document.getElementById(element).innerHTML == "&nbsp;+&nbsp;") ? "&nbsp;-&nbsp;" : "&nbsp;+&nbsp;";
    return false;
}
</script>
EndOfText
  print qq(Content-type: text/html\n\n<html><head><title>Amigo testing</title>$javascript</head><body>\n); }

sub getHtmlVar {                
  no strict 'refs';             
  my ($query, $var, $err) = @_; 
  unless ($query->param("$var")) {
    if ($err) { print "<FONT COLOR=blue>ERROR : No such variable : $var</FONT><BR>\n"; }
  } else { 
    my $oop = $query->param("$var");
    $$var = &untaint($oop);         
    return ($var, $$var);           
  } 
} # sub getHtmlVar

sub untaint {
  my $tainted = shift;
  my $untainted;
  if ($tainted eq "") {
    $untainted = "";
  } else { # if ($tainted eq "")
    $tainted =~ s/[^\w\-.,;:?\/\\@#\$\%\^&*\>\<(){}[\]+=!~|' \t\n\r\f\"]//g;
    if ($tainted =~ m/^([\w\-.,;:?\/\\@#\$\%&\^*\>\<(){}[\]+=!~|' \t\n\r\f\"]+)$/) {
      $untainted = $1;
    } else {
      die "Bad data Tainted in $tainted";
    }
  } # else # if ($tainted eq "")
  return $untainted;
} # sub untaint


# invidividual page search for each set of counts (very slow)
# sub getInferredGenesHrefTarget { return ('1 testing'); }
# sub getDirectGenesHrefTarget { return ('2 testing'); }
# REVERT
sub getInferredGenesHrefTarget {
  my ($focusTermId) = @_;
  my ($solr_url) = &getSolrUrl($focusTermId);
  my $inferredUrl = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&fl=%2Cscore&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=regulates_closure:%22' . $focusTermId . '%22';	# just the numFound
  my $inferredPage = get $inferredUrl; my $inferredNumFound = 0; 
  if ($inferredPage =~ m/"numFound":(\d+),/) { $inferredNumFound = $1; }
#   my $inferredLink = '0 (direct+inferred)';
  my $inferredLink = '0 gene products';
  if ($inferredNumFound > 0) {
#     $inferredLink = qq(<a target="new" href="amigo.cgi?action=showInferredGenes&focusTermId=$focusTermId">$inferredNumFound (direct+inferred)</a>);
    $inferredLink = qq(<a target="new" href="amigo.cgi?action=showGenes&focusTermId=$focusTermId">$inferredNumFound gene products</a>); }
  return $inferredLink;
} # sub getInferredGenesHrefTarget

# sub getDirectGenesHrefTarget {
#   my ($goid) = @_;
#   my ($solr_url) = &getSolrUrl($goid);
#   my $directUrl = $solr_url . 'select?qt=standard&indent=on&wt=json&version=2.2&fl=id%2Cscore&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=annotation_class_list:%22' . $goid . '%22';	# just the numFound
#   my $directPage = get $directUrl; my $directNumFound = 0; 
#   if ($directPage =~ m/"numFound":(\d+),/) { $directNumFound = $1; }
#   my $directLink = '0 (direct)';
#   if ($directNumFound > 0) {
#     $directLink = qq(<a target="new" href="amigo.cgi?action=showDirectGenes&goid=$goid">$directNumFound (direct)</a>); }
#   return $directLink;
# } # sub getDirectGenesHrefTarget


__END__

Given a node in a parent-child table, follow it to find all edges and paths to ancestors.
http://stackoverflow.com/questions/1144827/sql-find-all-direct-descendants-in-a-tree
WITH RECURSIVE q AS
        (
        SELECT  h, 1 AS level, ARRAY[goid_parent] AS breadcrumb
        FROM    obo_goid_edges h
        WHERE   goid_child = 'GO:0010610'
        UNION ALL
        SELECT  hi, q.level + 1 AS level, breadcrumb || goid_parent
        FROM    q
        JOIN    obo_goid_edges hi
        ON      hi.goid_child = (q.h).goid_parent
        )
SELECT  REPEAT('  ', level) || (q.h).goid_parent,
        (q.h).goid_child,
        (q.h).goid_parent,
        (q.h).relationship,
        level,
        breadcrumb::VARCHAR AS path
FROM    q
ORDER BY
        breadcrumb

           ?column?           | goid_child | goid_parent | relationship | level |                                                 path                          
------------------------------+------------+-------------+--------------+-------+------------------------------------------------------------------------------------------------------
   GO:0033554                 | GO:0010610 | GO:0033554  | part_of      |     1 | {GO:0033554}
     GO:0006950               | GO:0033554 | GO:0006950  | is_a         |     2 | {GO:0033554,GO:0006950}
       GO:0050896             | GO:0006950 | GO:0050896  | is_a         |     3 | {GO:0033554,GO:0006950,GO:0050896}
         GO:0008150           | GO:0050896 | GO:0008150  | is_a         |     4 | {GO:0033554,GO:0006950,GO:0050896,GO:0008150}
     GO:0051716               | GO:0033554 | GO:0051716  | is_a         |     2 | {GO:0033554,GO:0051716}
       GO:0044763             | GO:0051716 | GO:0044763  | is_a         |     3 | {GO:0033554,GO:0051716,GO:0044763}
         GO:0009987           | GO:0044763 | GO:0009987  | is_a         |     4 | {GO:0033554,GO:0051716,GO:0044763,GO:0009987}
           GO:0008150         | GO:0009987 | GO:0008150  | is_a         |     5 | {GO:0033554,GO:0051716,GO:0044763,GO:0009987,GO:0008150}
         GO:0044699           | GO:0044763 | GO:0044699  | is_a         |     4 | {GO:0033554,GO:0051716,GO:0044763,GO:0044699}
           GO:0008150         | GO:0044699 | GO:0008150  | is_a         |     5 | {GO:0033554,GO:0051716,GO:0044763,GO:0044699,GO:0008150}
       GO:0050896             | GO:0051716 | GO:0050896  | is_a         |     3 | {GO:0033554,GO:0051716,GO:0050896}
         GO:0008150           | GO:0050896 | GO:0008150  | is_a         |     4 | {GO:0033554,GO:0051716,GO:0050896,GO:0008150}
   GO:0043488                 | GO:0010610 | GO:0043488  | is_a         |     1 | {GO:0043488}
     GO:0043487               | GO:0043488 | GO:0043487  | is_a         |     2 | {GO:0043488,GO:0043487}
       GO:0010608             | GO:0043487 | GO:0010608  | is_a         |     3 | {GO:0043488,GO:0043487,GO:0010608}
         GO:0010468           | GO:0010608 | GO:0010468  | is_a         |     4 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468}
           GO:0010467         | GO:0010468 | GO:0010467  | regulates    |     5 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0010467}
             GO:0043170       | GO:0010467 | GO:0043170  | is_a         |     6 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0010467,GO:0043170}
               GO:0071704     | GO:0043170 | GO:0071704  | is_a         |     7 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0010467,GO:0043170,GO:0071704}
                 GO:0008152   | GO:0071704 | GO:0008152  | is_a         |     8 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0010467,GO:0043170,GO:0071704,GO:0008152}
                   GO:0008150 | GO:0008152 | GO:0008150  | is_a         |     9 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0010467,GO:0043170,GO:0071704,GO:0008152,GO:0008150}
           GO:0060255         | GO:0010468 | GO:0060255  | is_a         |     5 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0060255}
             GO:0019222       | GO:0060255 | GO:0019222  | is_a         |     6 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0060255,GO:0019222}
               GO:0008152     | GO:0019222 | GO:0008152  | regulates    |     7 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0060255,GO:0019222,GO:0008152}
                 GO:0008150   | GO:0008152 | GO:0008150  | is_a         |     8 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0060255,GO:0019222,GO:0008152,GO:0008150}
               GO:0050789     | GO:0019222 | GO:0050789  | is_a         |     7 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0060255,GO:0019222,GO:0050789}
                 GO:0008150   | GO:0050789 | GO:0008150  | regulates    |     8 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0060255,GO:0019222,GO:0050789,GO:0008150}
                 GO:0065007   | GO:0050789 | GO:0065007  | is_a         |     8 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0060255,GO:0019222,GO:0050789,GO:0065007}
                   GO:0008150 | GO:0065007 | GO:0008150  | is_a         |     9 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0060255,GO:0019222,GO:0050789,GO:0065007,GO:0008150}
             GO:0043170       | GO:0060255 | GO:0043170  | regulates    |     6 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0060255,GO:0043170}
               GO:0071704     | GO:0043170 | GO:0071704  | is_a         |     7 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0060255,GO:0043170,GO:0071704}
                 GO:0008152   | GO:0071704 | GO:0008152  | is_a         |     8 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0060255,GO:0043170,GO:0071704,GO:0008152}
                   GO:0008150 | GO:0008152 | GO:0008150  | is_a         |     9 | {GO:0043488,GO:0043487,GO:0010608,GO:0010468,GO:0060255,GO:0043170,GO:0071704,GO:0008152,GO:0008150}
       GO:0065008             | GO:0043487 | GO:0065008  | is_a         |     3 | {GO:0043488,GO:0043487,GO:0065008}
         GO:0065007           | GO:0065008 | GO:0065007  | is_a         |     4 | {GO:0043488,GO:0043487,GO:0065008,GO:0065007}
           GO:0008150         | GO:0065007 | GO:0008150  | is_a         |     5 | {GO:0043488,GO:0043487,GO:0065008,GO:0065007,GO:0008150}
(36 rows)





# transitivity :
# i  + i  = i
# i  + p  = p 
# i  + r  = r 
# i  + r+ = r+
# i  + r- = r-
# i  + hp = hp
# p  + i  = p
# p  + p  = p
# r  + i  = r
# r  + p  = r
# r+ + i  = r+
# r+ + p  = r
# r- + i  = r-
# r- + p  = r
# hp + i  = hp
# hp + hp = hp

# separate routines to do the same thing with different URLs and messages
# sub showInferredGenes {					# page to show gene products linked to a goid
#   &printHtmlHeader(); 
#   my ($var, $goid) = &getHtmlVar($query, 'goid');
#   my $inferredUrl = 'http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&q=document_category:bioentity&fq=source:%22WB%22&fq=%7B!cache=false%7Dregulates_closure:%22' . $goid . '%22';	# with wbgenes listed, more specific q, cache off
# # http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=regulates_closure:%22' . $goid . '%22';
#   my $inferredPage = get $inferredUrl; my $inferredNumFound = 0; my @genes;
#   if ($inferredPage =~ m/"numFound":(\d+),/) { $inferredNumFound = $1; }
#   if ($inferredNumFound > 0) {
#     print qq(List of $inferredNumFound genes that were annotated with $goid or any of its transitive descendant terms.<br/>\n);
#     (@genes) = $inferredPage =~ m/"id":"WB:(WBGene\d+)"/g;
#     foreach my $gene (sort @genes) { print qq($gene<br/>\n); }
#   }
#   &printHtmlFooter(); 
# } # sub showInferredGenes
# sub showDirectGenes {					# page to show gene products linked to a goid
#   &printHtmlHeader(); 
#   my ($var, $goid) = &getHtmlVar($query, 'goid');
#   my $inferredUrl = 'http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&q=document_category:bioentity&fq=source:%22WB%22&fq=%7B!cache=false%7Dannotation_class_list:%22'. $goid . '%22';	# with wbgenes listed, more specific q, cache off
#   my $inferredPage = get $inferredUrl; my $inferredNumFound = 0; my @genes;
#   if ($inferredPage =~ m/"numFound":(\d+),/) { $inferredNumFound = $1; }
#   if ($inferredNumFound > 0) {
#     print qq(List of $inferredNumFound genes that were annotated with $goid .<br/>\n);
#     (@genes) = $inferredPage =~ m/"id":"WB:(WBGene\d+)"/g;
#     foreach my $gene (sort @genes) { print qq($gene<br/>\n); }
#   }
#   &printHtmlFooter(); 
# } # sub showDirectGenes




# parent to child
# sub getLongestPath {
#   my ($ancestor, $goid) = @_;						# the ancestor and goid from which to find the longest path
#   &recurseLongestPath($ancestor, $ancestor, $goid, $ancestor);		# recurse to find longest path given current, start, end, and list of current path
#   my $max_nodes = 0;							# the most nodes found among all paths travelled
#   foreach my $finpath (@{ $paths{"finalpath"} }) {			# for each of the paths that reached the end node
#     my $nodes = scalar @$finpath;					# amount of nodes in the path
#     if ($nodes > $max_nodes) { $max_nodes = $nodes; }			# if more nodes than max, set new max
#   } # foreach my $finpath (@finalpath)
#   delete $paths{"finalpath"};						# reset finalpath for other ancestors
#   my $max_steps = $max_nodes - 1;					# amount of steps is one less than amount of nodes
#   return $max_steps;
# } # sub getLongestPath 
# 
# sub recurseLongestPath {
#   my ($current, $start, $end, $curpath) = @_;				# current node, starting node, end node, path travelled so far
#   foreach my $child (sort keys %{ $paths{"parentToChild"}{$current} }) {	# for each child of the current node
#     my @curpath = split/\t/, $curpath;					# convert current path to array
#     push @curpath, $child;						# add the current child
#     if ($child eq $end) {						# if current child is the end node
#         my @tmpWay = @curpath;						# make a copy of the array
#         push @{ $paths{"finalpath"} }, \@tmpWay; }			# put a reference to the array copy into the finalpath
#       else {								# not the end node yet
#         my $curpath = join"\t", @curpath;				# pass literal current path instead of reference
#         &recurseLongestPath($child, $start, $end, $curpath); }		# recurse to keep looking for the final node
#   } # foreach $child (sort keys %{ $paths{"parentToChild"}{$current} })
# } # sub recurseLongestPath


sub getInferredGenesDynamicSpan {	# takes too long to load all values for all links just to hide most of them anyway
  my ($ancestor) = @_;
#   my $inferredUrl = 'http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=*%2Cscore&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=regulates_closure:%22' . $ancestor . '%22';
#   my $inferredUrl = 'http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=%2Cscore&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=regulates_closure:%22' . $ancestor . '%22';	# just the numFound
  my $inferredUrl = 'http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=id&start=0&rows=10000000&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=regulates_closure:%22' . $ancestor . '%22';
# print "URL $inferredUrl URL<br>";
  my $inferredPage = get $inferredUrl; my $inferredNumFound = 0; my @genes;
  if ($inferredPage =~ m/"numFound":(\d+),/) { $inferredNumFound = $1; }
  my $inferredLink = '[0 gene products]';
  if ($inferredNumFound > 0) {
    (@genes) = $inferredPage =~ m/"id":"WB:(WBGene\d+)"/g;
    my $genes = join" ", @genes;
#     my $ancestor_go = $ancestor; $ancestor_go =~ s/://g;
    $inferredLink = qq([<span style="text-decoration: underline; color: blue; cursor: pointer;" onclick="toggleShowHide('genes_$ancestor');">$inferredNumFound gene products</span>]<span id="genes_$ancestor" style="display: none">$genes</span>); }
  return $inferredLink;
} # sub getInferredGenesDynamicSpan

sub FAKEgetDirectInferredGenes { return ('1', '2'); } 
sub getDirectInferredGenes {		# was getting both sets first, then switched to just one set, back to both sets, but just keeping it separate for ease
  my ($ancestor) = @_;
  my $directUrl = 'http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=*%2Cscore&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=annotation_class_list:%22' . $ancestor . '%22';
  my $directPage = get $directUrl; my $directNumFound = 0;
  if ($directPage =~ m/"numFound":(\d+),/) { $directNumFound = $1; }
#   my $inferredUrl = 'http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=*%2Cscore&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=regulates_closure:%22' . $ancestor . '%22';
  my $inferredUrl = 'http://golr.berkeleybop.org/select?qt=standard&indent=on&wt=json&version=2.2&fl=%2Cscore&fq=&q=*:*&fq=document_category:%22bioentity%22&fq=source:%22WB%22&fq=regulates_closure:%22' . $ancestor . '%22';
  my $inferredPage = get $inferredUrl; my $inferredNumFound = 0;
  if ($inferredPage =~ m/"numFound":(\d+),/) { $inferredNumFound = $1; }
  return ($directNumFound, $inferredNumFound);
} # sub getDirectInferredGenes
    


        "regulates_transitivity_graph_json":"{\"nodes\":[{\"id\":\"GO:0019222\",\"lbl\":\"regulation of metabolic process\"},{\"id\":\"GO:0043487\",\"lbl\":\"regulation of RNA stability\"},{\"id\":\"GO:0044763\",\"lbl\":\"single-organism cellular process\"},{\"id\":\"GO:0043488\",\"lbl\":\"regulation of mRNA stability\"},{\"id\":\"GO:0009987\",\"lbl\":\"cellular process\"},{\"id\":\"GO:0044699\",\"lbl\":\"single-organism process\"},{\"id\":\"GO:0065007\",\"lbl\":\"biological regulation\"},{\"id\":\"GO:0006950\",\"lbl\":\"response to stress\"},{\"id\":\"GO:0065008\",\"lbl\":\"regulation of biological quality\"},{\"id\":\"GO:0008152\",\"lbl\":\"metabolic process\"},{\"id\":\"GO:0033554\",\"lbl\":\"cellular response to stress\"},{\"id\":\"GO:0060255\",\"lbl\":\"regulation of macromolecule metabolic process\"},{\"id\":\"GO:0008150\",\"lbl\":\"biological_process\"},{\"id\":\"GO:0050896\",\"lbl\":\"response to stimulus\"},{\"id\":\"GO:0010608\",\"lbl\":\"posttranscriptional regulation of gene expression\"},{\"id\":\"GO:0051716\",\"lbl\":\"cellular response to stimulus\"},{\"id\":\"GO:0010610\",\"lbl\":\"regulation of mRNA stability involved in response to stress\"},{\"id\":\"GO:0050789\",\"lbl\":\"regulation of biological process\"},{\"id\":\"GO:0010467\",\"lbl\":\"gene expression\"},{\"id\":\"GO:0010468\",\"lbl\":\"regulation of gene expression\"},{\"id\":\"GO:0043170\",\"lbl\":\"macromolecule metabolic process\"},{\"id\":\"GO:0071704\",\"lbl\":\"organic substance metabolic process\"}],\"edges\":[{\"sub\":\"GO:0010610\",\"obj\":\"GO:0006950\",\"pred\":\"part_of\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0044699\",\"pred\":\"part_of\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0065007\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0009987\",\"pred\":\"part_of\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0043170\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0010467\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0019222\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0043170\",\"pred\":\"regulates\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0008150\",\"pred\":\"regulates\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0010608\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0006950\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0008152\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0008152\",\"pred\":\"regulates\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0033554\",\"pred\":\"part_of\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0008150\",\"pred\":\"part_of\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0010467\",\"pred\":\"regulates\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0050896\",\"pred\":\"part_of\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0060255\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0071704\",\"pred\":\"regulates\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0010468\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0050789\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0043487\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0065008\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0033554\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0043488\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0044763\",\"pred\":\"part_of\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0051716\",\"pred\":\"part_of\"}]}",

 "topology_graph_json":"{\"nodes\":[{\"id\":\"GO:0019222\",\"lbl\":\"regulation of metabolic process\"},{\"id\":\"GO:0043487\",\"lbl\":\"regulation of RNA stability\"},{\"id\":\"GO:0044763\",\"lbl\":\"single-organism cellular process\"},{\"id\":\"GO:0009987\",\"lbl\":\"cellular process\"},{\"id\":\"GO:0043488\",\"lbl\":\"regulation of mRNA stability\"},{\"id\":\"GO:0044699\",\"lbl\":\"single-organism process\"},{\"id\":\"GO:0006950\",\"lbl\":\"response to stress\"},{\"id\":\"GO:0065007\",\"lbl\":\"biological regulation\"},{\"id\":\"GO:0065008\",\"lbl\":\"regulation of biological quality\"},{\"id\":\"GO:2000815\",\"lbl\":\"regulation of mRNA stability involved in response to oxidative stress\"},{\"id\":\"GO:0008152\",\"lbl\":\"metabolic process\"},{\"id\":\"GO:0060255\",\"lbl\":\"regulation of macromolecule metabolic process\"},{\"id\":\"GO:0008150\",\"lbl\":\"biological_process\"},{\"id\":\"GO:0033554\",\"lbl\":\"cellular response to stress\"},{\"id\":\"GO:0050896\",\"lbl\":\"response to stimulus\"},{\"id\":\"GO:0010608\",\"lbl\":\"posttranscriptional regulation of gene expression\"},{\"id\":\"GO:0010610\",\"lbl\":\"regulation of mRNA stability involved in response to stress\"},{\"id\":\"GO:0051716\",\"lbl\":\"cellular response to stimulus\"},{\"id\":\"GO:0050789\",\"lbl\":\"regulation of biological process\"},{\"id\":\"GO:0010467\",\"lbl\":\"gene expression\"},{\"id\":\"GO:0010468\",\"lbl\":\"regulation of gene expression\"},{\"id\":\"GO:0043170\",\"lbl\":\"macromolecule metabolic process\"},{\"id\":\"GO:0071704\",\"lbl\":\"organic substance metabolic process\"}],\"edges\":[{\"sub\":\"GO:0006950\",\"obj\":\"GO:0050896\",\"pred\":\"is_a\"},{\"sub\":\"GO:0051716\",\"obj\":\"GO:0050896\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0006950\",\"pred\":\"part_of\"},{\"sub\":\"GO:0019222\",\"obj\":\"GO:0008152\",\"pred\":\"regulates\"},{\"sub\":\"GO:0033554\",\"obj\":\"GO:0006950\",\"pred\":\"is_a\"},{\"sub\":\"GO:0019222\",\"obj\":\"GO:0050789\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010468\",\"obj\":\"GO:0060255\",\"pred\":\"is_a\"},{\"sub\":\"GO:0043170\",\"obj\":\"GO:0071704\",\"pred\":\"is_a\"},{\"sub\":\"GO:0050789\",\"obj\":\"GO:0065007\",\"pred\":\"is_a\"},{\"sub\":\"GO:0043487\",\"obj\":\"GO:0010608\",\"pred\":\"is_a\"},{\"sub\":\"GO:0050896\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0050789\",\"obj\":\"GO:0008150\",\"pred\":\"regulates\"},{\"sub\":\"GO:0044763\",\"obj\":\"GO:0044699\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0033554\",\"pred\":\"part_of\"},{\"sub\":\"GO:0008152\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0071704\",\"obj\":\"GO:0008152\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010468\",\"obj\":\"GO:0010467\",\"pred\":\"regulates\"},{\"sub\":\"GO:0043487\",\"obj\":\"GO:0065008\",\"pred\":\"is_a\"},{\"sub\":\"GO:0065007\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010468\",\"obj\":\"GO:0065007\",\"pred\":\"is_a\"},{\"sub\":\"GO:0065008\",\"obj\":\"GO:0065007\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010608\",\"obj\":\"GO:0010468\",\"pred\":\"is_a\"},{\"sub\":\"GO:0060255\",\"obj\":\"GO:0019222\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010467\",\"obj\":\"GO:0043170\",\"pred\":\"is_a\"},{\"sub\":\"GO:0044699\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0060255\",\"obj\":\"GO:0065007\",\"pred\":\"is_a\"},{\"sub\":\"GO:0019222\",\"obj\":\"GO:0065007\",\"pred\":\"is_a\"},{\"sub\":\"GO:0033554\",\"obj\":\"GO:0051716\",\"pred\":\"is_a\"},{\"sub\":\"GO:0044763\",\"obj\":\"GO:0009987\",\"pred\":\"is_a\"},{\"sub\":\"GO:0043488\",\"obj\":\"GO:0043487\",\"pred\":\"is_a\"},{\"sub\":\"GO:0009987\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0051716\",\"obj\":\"GO:0044763\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010610\",\"obj\":\"GO:0043488\",\"pred\":\"is_a\"},{\"sub\":\"GO:2000815\",\"obj\":\"GO:0010610\",\"pred\":\"is_a\"},{\"sub\":\"GO:0060255\",\"obj\":\"GO:0043170\",\"pred\":\"regulates\"}]}",

http://golr.berkeleybop.org/select?qt=standard&fl=*&version=2.2&wt=json&indent=on&rows=1&q=id:%22GO:0044764%22&fq=document_category:%22ontology_class%22
"regulates_transitivity_graph_json":"{\"nodes\":[{\"id\":\"GO:0051704\",\"lbl\":\"multi-organism process\"},{\"id\":\"GO:0044764\",\"lbl\":\"multi-organism cellular process\"},{\"id\":\"GO:0009987\",\"lbl\":\"cellular process\"},{\"id\":\"GO:0008150\",\"lbl\":\"biological_process\"}],\"edges\":[{\"sub\":\"GO:0044764\",\"obj\":\"GO:0051704\",\"pred\":\"is_a\"},{\"sub\":\"GO:0044764\",\"obj\":\"GO:0009987\",\"pred\":\"is_a\"},{\"sub\":\"GO:0044764\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"}]}",
"topology_graph_json":"{\"nodes\":[{\"id\":\"GO:0016032\",\"lbl\":\"viral process\"},{\"id\":\"GO:0009292\",\"lbl\":\"genetic transfer\"},{\"id\":\"GO:0036281\",\"lbl\":\"coflocculation\"},{\"id\":\"GO:0051704\",\"lbl\":\"multi-organism process\"},{\"id\":\"GO:0042710\",\"lbl\":\"biofilm formation\"},{\"id\":\"GO:0044764\",\"lbl\":\"multi-organism cellular process\"},{\"id\":\"GO:0009987\",\"lbl\":\"cellular process\"},{\"id\":\"GO:0000128\",\"lbl\":\"flocculation\"},{\"id\":\"GO:0048874\",\"lbl\":\"homeostasis of number of cells in a free-living population\"},{\"id\":\"GO:0000746\",\"lbl\":\"conjugation\"},{\"id\":\"GO:0008150\",\"lbl\":\"biological_process\"}],\"edges\":[{\"sub\":\"GO:0044764\",\"obj\":\"GO:0051704\",\"pred\":\"is_a\"},{\"sub\":\"GO:0044764\",\"obj\":\"GO:0009987\",\"pred\":\"is_a\"},{\"sub\":\"GO:0000746\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0051704\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0009987\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0009292\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0016032\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0042710\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0000128\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0048874\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0036281\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"}]}",


regulates_transitivity_graph_json has only ancestors

"regulates_transitivity_graph_json":"{\"
{\"id\":\"GO:0016032\",\"lbl\":\"viral process\"},{\"id\":\"GO:0009292\",\"lbl\":\"genetic transfer\"},{\"id\":\"GO:0036281\",\"lbl\":\"coflocculation\"},{\"id\":\"GO:0042710\",\"lbl\":\"biofilm formation\"},{\"id\":\"GO:0000128\",\"lbl\":\"flocculation\"},{\"id\":\"GO:0048874\",\"lbl\":\"homeostasis of number of cells in a free-living population\"},{\"id\":\"GO:0000746\",\"lbl\":\"conjugation\"}],\"

{\"sub\":\"GO:0044764\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"}]}",
{\"sub\":\"GO:0000746\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0051704\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0009987\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0009292\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0016032\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0042710\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0000128\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0048874\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0036281\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"}]}",


"topology_graph_json":"{\"
nodes\":[{\"id\":\"GO:0016032\",\"lbl\":\"viral process\"},{\"id\":\"GO:0009292\",\"lbl\":\"genetic transfer\"},{\"id\":\"GO:0036281\",\"lbl\":\"coflocculation\"},{\"id\":\"GO:0051704\",\"lbl\":\"multi-organism process\"},{\"id\":\"GO:0042710\",\"lbl\":\"biofilm formation\"},{\"id\":\"GO:0044764\",\"lbl\":\"multi-organism cellular process\"},{\"id\":\"GO:0009987\",\"lbl\":\"cellular process\"},{\"id\":\"GO:0000128\",\"lbl\":\"flocculation\"},{\"id\":\"GO:0048874\",\"lbl\":\"homeostasis of number of cells in a free-living population\"},{\"id\":\"GO:0000746\",\"lbl\":\"conjugation\"},{\"id\":\"GO:0008150\",\"lbl\":\"biological_process\"}],\"
edges\":[{\"sub\":\"GO:0044764\",\"obj\":\"GO:0051704\",\"pred\":\"is_a\"},{\"sub\":\"GO:0044764\",\"obj\":\"GO:0009987\",\"pred\":\"is_a\"},{\"sub\":\"GO:0000746\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0051704\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0009987\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0009292\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0016032\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0042710\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0000128\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0048874\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"},{\"sub\":\"GO:0036281\",\"obj\":\"GO:0044764\",\"pred\":\"is_a\"}]}",




80135
{\"id\":\"GO:0000167\",\"lbl\":\"activation of MAPKKK activity involved in osmosensory signaling pathway\"},
{\"id\":\"GO:0000168\",\"lbl\":\"activation of MAPKK activity involved in osmosensory signaling pathway\"},
{\"id\":\"GO:0000169\",\"lbl\":\"activation of MAPK activity involved in osmosensory signaling pathway\"},
{\"id\":\"GO:0000173\",\"lbl\":\"inactivation of MAPK activity involved in osmosensory signaling pathway\"},
{\"id\":\"GO:0010363\",\"lbl\":\"regulation of plant-type hypersensitive response\"}],\"
{\"id\":\"GO:0010504\",\"lbl\":\"regulation of cell cycle arrest in response to nitrogen starvation\"},
{\"id\":\"GO:0010516\",\"lbl\":\"negative regulation of cellular response to nitrogen starvation\"},
{\"id\":\"GO:0010999\",\"lbl\":\"regulation of eIF2 alpha phosphorylation by heme\"},
{\"id\":\"GO:0016241\",\"lbl\":\"regulation of macroautophagy\"},
{\"id\":\"GO:0060733\",\"lbl\":\"regulation of eIF2 alpha phosphorylation by amino acid starvation\"},
{\"id\":\"GO:0060734\",\"lbl\":\"regulation of eIF2 alpha phosphorylation by endoplasmic reticulum stress\"},
{\"id\":\"GO:0060735\",\"lbl\":\"regulation of eIF2 alpha phosphorylation by dsRNA\"},
{\"id\":\"GO:0060905\",\"lbl\":\"regulation of induction of conjugation upon nitrogen starvation\"},
{\"id\":\"GO:0070302\",\"lbl\":\"regulation of stress-activated protein kinase signaling cascade\"},
{\"id\":\"GO:0070570\",\"lbl\":\"regulation of neuron projection regeneration\"},
{\"id\":\"GO:0080040\",\"lbl\":\"positive regulation of cellular response to phosphate starvation\"},
{\"id\":\"GO:0080136\",\"lbl\":\"priming of cellular response to stress\"},
{\"id\":\"GO:1900034\",\"lbl\":\"regulation of cellular response to heat\"},
{\"id\":\"GO:1900037\",\"lbl\":\"regulation of cellular response to hypoxia\"},
{\"id\":\"GO:1900069\",\"lbl\":\"regulation of cellular hyperosmotic salinity response\"},
{\"id\":\"GO:1900101\",\"lbl\":\"regulation of endoplasmic reticulum unfolded protein response\"},
{\"id\":\"GO:1900407\",\"lbl\":\"regulation of cellular response to oxidative stress\"},
{\"id\":\"GO:1901643\",\"lbl\":\"regulation of tRNA methylation in response to nitrogen starvation\"},
{\"id\":\"GO:1901966\",\"lbl\":\"regulation of cellular response to iron ion starvation\"},
{\"id\":\"GO:1902235\",\"lbl\":\"regulation of intrinsic apoptotic signaling pathway in response to endoplasmic reticulum stress\"},
{\"id\":\"GO:2000638\",\"lbl\":\"regulation of SREBP signaling pathway\"},
{\"id\":\"GO:2000772\",\"lbl\":\"regulation of cellular senescence\"},
{\"id\":\"GO:2001020\",\"lbl\":\"regulation of response to DNA damage stimulus\"},


edges\":[{\"sub\":\"GO:0080136\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0065007\",\"pred\":\"is_a\"},{\"sub\":\"GO:0033554\",\"obj\":\"GO:0006950\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080134\",\"obj\":\"GO:0065007\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0080134\",\"pred\":\"is_a\"},{\"sub\":\"GO:0050794\",\"obj\":\"GO:0065007\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010504\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0050789\",\"obj\":\"GO:0065007\",\"pred\":\"is_a\"},{\"sub\":\"GO:0050896\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080040\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080134\",\"obj\":\"GO:0006950\",\"pred\":\"regulates\"},{\"sub\":\"GO:0044763\",\"obj\":\"GO:0044699\",\"pred\":\"is_a\"},{\"sub\":\"GO:1901643\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0060905\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:1901966\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010363\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010516\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0070302\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0044763\",\"obj\":\"GO:0009987\",\"pred\":\"is_a\"},{\"sub\":\"GO:0000169\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0033554\",\"pred\":\"regulates\"},{\"sub\":\"GO:0000168\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0048583\",\"obj\":\"GO:0065007\",\"pred\":\"is_a\"},{\"sub\":\"GO:0000167\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0051716\",\"obj\":\"GO:0044763\",\"pred\":\"is_a\"},{\"sub\":\"GO:1900407\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0048583\",\"obj\":\"GO:0050789\",\"pred\":\"is_a\"},{\"sub\":\"GO:1900101\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0006950\",\"obj\":\"GO:0050896\",\"pred\":\"is_a\"},{\"sub\":\"GO:0051716\",\"obj\":\"GO:0050896\",\"pred\":\"is_a\"},{\"sub\":\"GO:0048583\",\"obj\":\"GO:0050896\",\"pred\":\"regulates\"},{\"sub\":\"GO:0000173\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:1902235\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0050794\",\"obj\":\"GO:0050789\",\"pred\":\"is_a\"},{\"sub\":\"GO:0010999\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0050794\",\"obj\":\"GO:0009987\",\"pred\":\"regulates\"},{\"sub\":\"GO:2000638\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0050789\",\"obj\":\"GO:0008150\",\"pred\":\"regulates\"},{\"sub\":\"GO:0080134\",\"obj\":\"GO:0048583\",\"pred\":\"is_a\"},{\"sub\":\"GO:2000772\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0065007\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:1900034\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0050794\",\"pred\":\"is_a\"},{\"sub\":\"GO:0044699\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:1900037\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:2001020\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0060734\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0033554\",\"obj\":\"GO:0051716\",\"pred\":\"is_a\"},{\"sub\":\"GO:0060735\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:1900069\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0009987\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0070570\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0016241\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"},{\"sub\":\"GO:0060733\",\"obj\":\"GO:0080135\",\"pred\":\"is_a\"}]}",
edges\":[{\"sub\":\"GO:0080135\",\"obj\":\"GO:0009987\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0050896\",\"pred\":\"regulates\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0065007\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0033554\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0080134\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0050794\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0008150\",\"pred\":\"regulates\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0050896\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0050789\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0009987\",\"pred\":\"regulates\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0033554\",\"pred\":\"regulates\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0006950\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0008150\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0044763\",\"pred\":\"regulates\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0006950\",\"pred\":\"regulates\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0048583\",\"pred\":\"is_a\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0051716\",\"pred\":\"regulates\"},{\"sub\":\"GO:0080135\",\"obj\":\"GO:0044699\",\"pred\":\"regulates\"}]}",
